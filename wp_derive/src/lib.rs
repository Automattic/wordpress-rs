//! [WordPress.org REST API](https://developer.wordpress.org/rest-api/reference/) endpoints accept
//! a `context` argument - "edit", "embed" or "view" (default) - which will dictate which fields will be
//! returned in the response. This is in addition to the `_filter` argument which lets developers
//! pick the returned fields one by one.
//!
//! This present a challenge in parsing the response because there are several schema variations
//! for each endpoint. One basic option to get around this would be to use a type where each field
//! is an [`Option`]. However, this would force developers to deal with nullability when they
//! shouldn't have to. The alternative would be to have a type for each known variation. The goal
//! of [`WPContextual`] derive macro is to simplify this process.
//!
//! ---
//!
//! Let's work through a simplified example to better understand why we need this macro and how to
//! work with it.
//!
//! The [`/posts` endpoint](https://developer.wordpress.org/rest-api/reference/posts/)
//! lists the following fields, among many others:
//!
//! | Field   | Description |
//! | :---:   | ----------- |
//! | id      | JSON data type: `integer`<br>Context: `view`, `edit`, `embed` |
//! | content | JSON data type: `object`<br>Context: `view`, `edit` |
//!
//! Although it's not documented, here are some of the fields for `content`:
//!
//! | Field   | Description |
//! | :---:   | ----------- |
//! | raw      | Context: `view`, `edit` |
//! | rendered | Context: `view` |
//!
//! One possible approach to parse these would be to use the following types:
//!
//! ```
//! pub struct Post {
//!     pub id: Option<u32>,
//!     pub content: Option<PostContent>,
//! }
//! pub struct PostContent {
//!    pub raw: Option<String>,
//!    pub rendered: Option<String>
//! }
//! ```
//!
//! We can use these types to parse the response for every context type. However, consider the case
//! where we make a request for `edit` context. Even though we know that, all these fields are
//! present in the response, we'll have to work with nullable values and unwrap them in the
//! consumer which is error prone.
//!
//! If we want to have non-optional context based types, it could look like this:
//!
//! ```
//! pub struct PostWithEditContext {
//!     pub id: u32,
//!     pub content: PostContentWithEditContext,
//! }
//! pub struct PostWithEmbedContext {
//!     pub id: u32,
//! }
//! pub struct PostWithViewContext {
//!     pub id: u32,
//!     pub content: PostContentWithViewContext,
//! }
//! pub struct PostContentWithEditContext {
//!    pub raw: String,
//!    pub rendered: String
//! }
//! pub struct PostContentWithViewContext {
//!    pub rendered: String
//! }
//! ```
//!
//! This is a much better solution, because we have strongly typed values. However, that's a lot
//! of code just for 2 types with only 2 fields. Furthermore, it's very difficult to tell which
//! fields are available for each `context` and has a higher maintainance cost.
//!
//! In order to address this, we have [`WPContextual`] derive macro. Let's start from simple, and
//! build up to the example:
//!
//! ```
//! # use wp_derive::WPContextual;
//! #[derive(WPContextual)]
//! pub struct SparsePostContent {
//!     #[WPContext(edit)]
//!     pub raw: Option<String>,
//!     #[WPContext(edit, view)]
//!     pub rendered: Option<String>,
//! }
//!
//! # // We need these 2 lines for UniFFI
//! # uniffi::setup_scaffolding!();
//! # fn main() {}
//! ```
//!
//! If we look at only the type information, it is almost identical to our first approach:
//!
//! ```
//! pub struct SparsePostContent {
//!    pub raw: Option<String>,
//!    pub rendered: Option<String>
//! }
//! ```
//!
//! The only difference is that the new type starts with the `Sparse` prefix. This is a requirement
//! of [`WPContextual`]. `Sparse` is prefix commonly used to describe types that only have some of
//! the elements present. We have decided to add this requirement to convey this information, to
//! have consistency among our types and most importantly to avoid developers accidentally
//! defaulting to the sparse types instead of the strongly typed objects that are generated by the
//! derive macro.
//!
//! When we derive [`WPContextual`] for this `SparsePostContent` type we are telling the compiler
//! that we want to generate 3 new types from it: `PostContentWithEditContext`,
//! `PostContentWithEmbedContext`, `PostContentWithViewContext`. However, this is not enough,
//! because the compiler also needs to know which fields should be present for each field. This is
//! why we also need the `WPContext` attribute. Here is what the compiler will generate for this
//! type:
//! ```
//! # use wp_derive::WPContextual;
//! #[derive(WPContextual)]
//! pub struct SparsePostContent {
//!     #[WPContext(edit)]
//!     pub raw: Option<String>,
//!     #[WPContext(edit, view)]
//!     pub rendered: Option<String>,
//! }
//! # // We need these 2 lines for UniFFI
//! # uniffi::setup_scaffolding!();
//! # fn main() {}
//! ```
//!
//! Given the above type, the compiler will generate these 2 types:
//!
//! ```
//! pub struct PostContentWithEditContext {
//!    pub raw: String,
//!    pub rendered: String
//! }
//! pub struct PostContentWithViewContext {
//!    pub rendered: String
//! }
//!
//! ```
//!
//! You should note a few things:
//! * `PostContentWithEmbedContext` type is missing. That's because, in this example, there are
//! no fields in `SparsePostContent` that's available in `embed` context.
//! * The type of generated fields are `String` instead of `Option<String>` which is exactly what
//! we did when we manually wrote these types.
//! * The information about which fields are available for each context are right there on top of
//! the fields, so the syntax acts as a documentation.
//!
//! Let's do the same for `Post` type as well:
//!
//! ```
//! # use wp_derive::WPContextual;
//! #[derive(WPContextual)]
//! pub struct SparsePost {
//!     #[WPContext(edit, embed, view)]
//!     pub id: Option<u32>,
//!     #[WPContext(edit)]
//!     ##[WPContextualField]
//!     pub content: Option<SparsePostContent>,
//! }
//! # #[derive(WPContextual)]
//! # pub struct SparsePostContent {
//! #     #[WPContext(edit)]
//! #     pub raw: Option<String>,
//! #     #[WPContext(edit, view)]
//! #     pub rendered: Option<String>,
//! # }
//! # // We need these 2 lines for UniFFI
//! # uniffi::setup_scaffolding!();
//! # fn main() {}
//! ```
//!
//! Given the above type and the `SparsePostContent` which was omitted for brevity, the compiler
//! will generate the following types:
//!
//! ```
//! pub struct PostWithEditContext {
//!     pub id: u32,
//!     pub content: SparsePostContent,
//! }
//! pub struct PostWithEmbedContext {
//!     pub id: u32,
//! }
//! pub struct PostWithViewContext {
//!     pub id: u32,
//!     pub content: SparsePostContent,
//! }
//! # struct SparsePostContent {}
//! ```
//!
//! This doesn't look correct. Notice the type of the `content` field is `SparsePostContent` in
//! each case. This is because the compiler doesn't know that `SparsePostContent` is also a
//! [`WPContextual`] type. We can help the compiler by adding the `WPContextualField` attribute:
//!
//! ```
//! # use wp_derive::WPContextual;
//! #[derive(WPContextual)]
//! pub struct SparsePost {
//!     #[WPContext(edit, embed, view)]
//!     pub id: Option<u32>,
//!     #[WPContext(edit)]
//!     #[WPContextualField]
//!     pub content: Option<SparsePostContent>,
//! }
//! # #[derive(WPContextual)]
//! # pub struct SparsePostContent {
//! #     #[WPContext(edit)]
//! #     pub raw: Option<String>,
//! #     #[WPContext(edit, view)]
//! #     pub rendered: Option<String>,
//! # }
//! # // We need these 2 lines for UniFFI
//! # uniffi::setup_scaffolding!();
//! # fn main() {}
//! ```
//!
//! This will generate the following instead:
//!
//! ```
//! pub struct PostWithEditContext {
//!     pub id: u32,
//!     pub content: PostContentWithEditContext,
//! }
//! pub struct PostWithEmbedContext {
//!     pub id: u32,
//! }
//! pub struct PostWithViewContext {
//!     pub id: u32,
//!     pub content: PostContentWithViewContext,
//! }
//! # struct PostContentWithEditContext {}
//! # struct PostContentWithViewContext {}
//! ```
//!
//! Notice that the types of the `content` fields are now `PostContentWithEditContext` &
//! `PostContentWithViewContext` which are the types that we used in our manually typed
//! example.
//!
//! Please see the documentation for [`WPContextual`] for technical details.
use proc_macro::TokenStream;
use syn::parse_macro_input;

mod wp_contextual;

/// Given `SparseFoo`, it will generate `FooWithEditContext`, `FooWithEmbedContext` &
/// `FooWithViewContext` types by turning `Option<T>` fields into `T`
///
/// * `[WPContextual]` types have to start `Sparse` prefix. This is a design decision we have made
/// to keep our type names descriptive and consistent.
/// * `[WPContext]` attribute is used to describe which `context`s the field belongs to.
/// * `[WPContextualField]` is used when a [`WPContextual`] type is a **field** of another
/// [`WPContextual`] type. This will tell the compiler to replace the given `Option<SparseBaz>`
/// type with the appropriate contextual type: `BazWithEditContext`, `BazWithEmbedContext` or
/// `BazWithViewContext`.
/// * Generated types will have the following derive macros:
/// `#[derive(Debug, serde::Serialize, serde::Deserialize, uniffi::Record)]`. These types are meant
/// to be used for the
/// [WordPress.org REST API](https://developer.wordpress.org/rest-api/reference/), so
/// [`serde::Serialize`] and [`serde::Deserialize`] are needed for parsing. We also would like
/// to use these types through FFI, so they need to derive [`uniffi::Record`].
/// * If the generated type won't have any fields, that type will not be generated.
/// * If a **field** type is not `Option<T>`, it'll not be altered. Only `Option<T>` fields turn
/// into `T`.
///
/// Here is a full example:
///
/// ```
/// use wp_derive::WPContextual;
///
/// #[derive(WPContextual)]
/// pub struct SparseFoo {
///     #[WPContext(edit, embed, view)]
///     pub bar: Option<u32>,
///     #[WPContext(edit)]
///     #[WPContextualField]
///     pub baz: Option<SparseBaz>,
/// }
///
/// #[derive(WPContextual)]
/// pub struct SparseBaz {
///     #[WPContext(edit)]
///     pub baz: Option<String>,
///     #[WPContext(edit)]
///     pub qux: Vec<u32>,
/// }
/// # // We need these 2 lines for UniFFI
/// # uniffi::setup_scaffolding!();
/// # fn main() {}
/// ```
///
/// Given above, compiler will generate the following types:
///
/// ```
/// #[derive(Debug, serde::Serialize, serde::Deserialize, uniffi::Record)]
/// pub struct FooWithEditContext {
///     pub bar: u32,
///     pub baz: BazWithEditContext,
/// }
/// #[derive(Debug, serde::Serialize, serde::Deserialize, uniffi::Record)]
/// pub struct FooWithEmbedContext {
///     pub bar: u32,
/// }
/// #[derive(Debug, serde::Serialize, serde::Deserialize, uniffi::Record)]
/// pub struct FooWithViewContext {
///     pub bar: u32,
/// }
/// #[derive(Debug, serde::Serialize, serde::Deserialize, uniffi::Record)]
/// pub struct BazWithEditContext {
///     pub baz: String,
///     pub qux: Vec<u32>,
/// }
/// # // We need these 2 lines for UniFFI
/// # uniffi::setup_scaffolding!();
/// # fn main() {}
/// ```
///
/// * Notice that `BazWithEmbedContext` & `BazWithViewContext` types weren't generated since
/// they wouldn't have any fields.
/// * Notice the type for `qux: Vec<u32>` was preserved as this wasn't an `Option<T>` type.
#[proc_macro_derive(WPContextual, attributes(WPContext, WPContextualField))]
pub fn derive(input: TokenStream) -> TokenStream {
    wp_contextual::wp_contextual(parse_macro_input!(input))
        .unwrap_or_else(|err| err.into_compile_error().into())
}
