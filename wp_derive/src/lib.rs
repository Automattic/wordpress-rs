//! [WordPress.org REST API](https://developer.wordpress.org/rest-api/reference/) endpoints accept
//! a `context` argument - "edit", "embed" or "view" (default) - which will dictate which fields will be
//! returned in the response. This is in addition to the `_filter` argument which lets developers
//! pick the returned fields one by one.
//!
//! This present a challenge in parsing the response because there are several schema variations
//! for each endpoint. One basic option to get around this would be to use a type where each field
//! is an [`Option`]. However, this would force developers to deal with nullability when they
//! shouldn't have to. The alternative would be to have a type for each known variation. The goal
//! of [`WPContextual`] derive macro is to simplify this process.
//!
//! ---
//!
//! Let's work through a simplified example to better understand why we need this macro and how to
//! work with it.
//!
//! The [`/posts` endpoint](https://developer.wordpress.org/rest-api/reference/posts/)
//! lists the following fields, among many others:
//!
//! | Field   | Description |
//! | :---:   | ----------- |
//! | id      | JSON data type: `integer`<br>Context: `view`, `edit`, `embed` |
//! | content | JSON data type: `object`<br>Context: `view`, `edit` |
//!
//! Although it's not documented, here are some of the fields for `content`:
//!
//! | Field   | Description |
//! | :---:   | ----------- |
//! | raw      | Context: `view`, `edit` |
//! | rendered | Context: `view` |
//!
//! One possible approach to parse these would be to use the following types:
//!
//! ```
//! pub struct Post {
//!     pub id: Option<u32>,
//!     pub content: Option<PostContent>,
//! }
//! pub struct PostContent {
//!    pub raw: Option<String>,
//!    pub rendered: Option<String>
//! }
//! ```
//!
//! We can use these types to parse the response for every context type. However, consider the case
//! where we make a request for `edit` context. Even though we know that, all these fields are
//! present in the response, we'll have to work with nullable values and unwrap them in the
//! consumer which is error prone.
//!
//! If we want to have non-optional context based types, it could look like this:
//!
//! ```
//! pub struct PostWithEditContext {
//!     pub id: u32,
//!     pub content: PostContentWithEditContext,
//! }
//! pub struct PostWithEmbedContext {
//!     pub id: u32,
//! }
//! pub struct PostWithViewContext {
//!     pub id: u32,
//!     pub content: PostContentWithViewContext,
//! }
//! pub struct PostContentWithEditContext {
//!    pub raw: String,
//!    pub rendered: String
//! }
//! pub struct PostContentWithViewContext {
//!    pub rendered: String
//! }
//! ```
//!
//! This is a much better solution, because we have strongly typed values. However, that's a lot
//! of code just for 2 types with only 2 fields. Furthermore, it's very difficult to tell which
//! fields are available for each `context` and has a higher maintainance cost.
//!
//! In order to address this, we have [`WPContextual`] derive macro. Let's start from simple, and
//! build up to the example:
//!
//! ```
//! # use wp_derive::WPContextual;
//! #[derive(WPContextual)]
//! pub struct SparsePostContent {
//!     #[WPContext(edit)]
//!     pub raw: Option<String>,
//!     #[WPContext(edit, view)]
//!     pub rendered: Option<String>,
//! }
//!
//! # // We need these 2 lines for UniFFI
//! # uniffi::setup_scaffolding!();
//! # fn main() {}
//! ```
//!
//! If we look at only the type information, it is almost identical to our first approach:
//!
//! ```
//! pub struct SparsePostContent {
//!    pub raw: Option<String>,
//!    pub rendered: Option<String>
//! }
//! ```
//!
//! The only difference is that the new type starts with the `Sparse` prefix. This is a requirement
//! of [`WPContextual`]. `Sparse` is prefix commonly used to describe types that only have some of
//! the elements present. We have decided to add this requirement to convey this information, to
//! have consistency among our types and most importantly to avoid developers accidentally
//! defaulting to the sparse types instead of the strongly typed objects that are generated by the
//! derive macro.
//!
//! When we derive [`WPContextual`] for this `SparsePostContent` type we are telling the compiler
//! that we want to generate 3 new types from it: `PostContentWithEditContext`,
//! `PostContentWithEmbedContext`, `PostContentWithViewContext`. However, this is not enough,
//! because the compiler also needs to know which fields should be present for each field. This is
//! why we also need the `WPContext` attribute. Here is what the compiler will generate for this
//! type:
//! ```
//! # use wp_derive::WPContextual;
//! #[derive(WPContextual)]
//! pub struct SparsePostContent {
//!     #[WPContext(edit)]
//!     pub raw: Option<String>,
//!     #[WPContext(edit, view)]
//!     pub rendered: Option<String>,
//! }
//! # // We need these 2 lines for UniFFI
//! # uniffi::setup_scaffolding!();
//! # fn main() {}
//! ```
//!
//! Given the above type, the compiler will generate these 2 types:
//!
//! ```
//! pub struct PostContentWithEditContext {
//!    pub raw: String,
//!    pub rendered: String
//! }
//! pub struct PostContentWithViewContext {
//!    pub rendered: String
//! }
//!
//! ```
//!
//! You should note a few things:
//! * `PostContentWithEmbedContext` type is missing. That's because, in this example, there are
//! no fields in `SparsePostContent` that's available in `embed` context.
//! * The type of generated fields are `String` instead of `Option<String>` which is exactly what
//! we did when we manually wrote these types.
//! * The information about which fields are available for each context are right there on top of
//! the fields, so the syntax acts as a documentation.
//!
//! Let's do the same for `Post` type as well:
//!
//! ```
//! # use wp_derive::WPContextual;
//! #[derive(WPContextual)]
//! pub struct SparsePost {
//!     #[WPContext(edit, embed, view)]
//!     pub id: Option<u32>,
//!     #[WPContext(edit)]
//!     ##[WPContextualField]
//!     pub content: Option<SparsePostContent>,
//! }
//! # #[derive(WPContextual)]
//! # pub struct SparsePostContent {
//! #     #[WPContext(edit)]
//! #     pub raw: Option<String>,
//! #     #[WPContext(edit, view)]
//! #     pub rendered: Option<String>,
//! # }
//! # // We need these 2 lines for UniFFI
//! # uniffi::setup_scaffolding!();
//! # fn main() {}
//! ```
//!
//! Given the above type and the `SparsePostContent` which was omitted for brevity, the compiler
//! will generate the following types:
//!
//! ```
//! pub struct PostWithEditContext {
//!     pub id: u32,
//!     pub content: SparsePostContent,
//! }
//! pub struct PostWithEmbedContext {
//!     pub id: u32,
//! }
//! pub struct PostWithViewContext {
//!     pub id: u32,
//!     pub content: SparsePostContent,
//! }
//! # struct SparsePostContent {}
//! ```
//!
//! This doesn't look correct. Notice the type of the `content` field is `SparsePostContent` in
//! each case. This is because the compiler doesn't know that `SparsePostContent` is also a
//! [`WPContextual`] type. We can help the compiler by adding the `WPContextualField` attribute:
//!
//! ```
//! # use wp_derive::WPContextual;
//! #[derive(WPContextual)]
//! pub struct SparsePost {
//!     #[WPContext(edit, embed, view)]
//!     pub id: Option<u32>,
//!     #[WPContext(edit)]
//!     #[WPContextualField]
//!     pub content: Option<SparsePostContent>,
//! }
//! # #[derive(WPContextual)]
//! # pub struct SparsePostContent {
//! #     #[WPContext(edit)]
//! #     pub raw: Option<String>,
//! #     #[WPContext(edit, view)]
//! #     pub rendered: Option<String>,
//! # }
//! # // We need these 2 lines for UniFFI
//! # uniffi::setup_scaffolding!();
//! # fn main() {}
//! ```
//!
//! This will generate the following instead:
//!
//! ```
//! pub struct PostWithEditContext {
//!     pub id: u32,
//!     pub content: PostContentWithEditContext,
//! }
//! pub struct PostWithEmbedContext {
//!     pub id: u32,
//! }
//! pub struct PostWithViewContext {
//!     pub id: u32,
//!     pub content: PostContentWithViewContext,
//! }
//! # struct PostContentWithEditContext {}
//! # struct PostContentWithViewContext {}
//! ```
//!
//! Notice that the type of the `content` field is now `PostContentWithEditContext` &
//! `PostContentWithViewContext` which are exactly the types that we used in our manually typed
//! example.
//!
//! One last bit to wrap up this example. In the manually typed example, we have replaced the
//! `Sparse` types with the strongly typed contextual types. However, we still need to the `Sparse`
//! types, because we still want to be able to manually filter the fields, with `_filter` argument.
//! With that in mind, here is the full comparison:
//!
//! ```
//! // Before
//! pub struct SparsePost {
//!     pub id: Option<u32>,
//!     pub content: Option<SparsePostContent>,
//! }
//! pub struct SparsePostContent {
//!    pub raw: Option<String>,
//!    pub rendered: Option<String>
//! }
//! pub struct PostWithEditContext {
//!     pub id: u32,
//!     pub content: PostContentWithEditContext,
//! }
//! pub struct PostWithEmbedContext {
//!     pub id: u32,
//! }
//! pub struct PostWithViewContext {
//!     pub id: u32,
//!     pub content: PostContentWithViewContext,
//! }
//! pub struct PostContentWithEditContext {
//!    pub raw: String,
//!    pub rendered: String
//! }
//! pub struct PostContentWithViewContext {
//!    pub rendered: String
//! }
//! ```
//!
//! ```
//! // After
//! use wp_derive::WPContextual;
//!
//! #[derive(WPContextual)]
//! pub struct SparsePost {
//!     #[WPContext(edit, embed, view)]
//!     pub id: Option<u32>,
//!     #[WPContext(edit)]
//!     #[WPContextualField]
//!     pub content: Option<SparsePostContent>,
//! }
//!
//! #[derive(WPContextual)]
//! pub struct SparsePostContent {
//!     #[WPContext(edit)]
//!     pub raw: Option<String>,
//!     #[WPContext(edit, view)]
//!     pub rendered: Option<String>,
//! }
//! # // We need these 2 lines for UniFFI
//! # uniffi::setup_scaffolding!();
//! # fn main() {}
//! ```
//!
use proc_macro::TokenStream;
use syn::parse_macro_input;

mod wp_contextual;

#[proc_macro_derive(WPContextual, attributes(WPContext, WPContextualField))]
pub fn derive(input: TokenStream) -> TokenStream {
    wp_contextual::wp_contextual(parse_macro_input!(input))
        .unwrap_or_else(|err| err.into_compile_error().into())
}
