use async_trait::async_trait;
use serde::Serialize;
use std::sync::Arc;
use url::Url;
use wp_api::{
    request::{
        RequestExecutor, RequestMethod, WpNetworkHeaderMap, WpNetworkRequest, WpNetworkResponse,
    },
    users::UserId,
    ParsedUrl, RequestExecutionError, WpApiClient, WpApiError, WpAuthentication, WpErrorCode,
};
use wp_cli::{WpCliSiteSettings, WpCliUser, WpCliUserMeta};

pub mod fs_utils;
pub mod wp_db;

include!(concat!(env!("OUT_DIR"), "/generated_test_credentials.rs"));

pub(crate) const TEST_SITE_WP_CONTENT_PATH: &str = "/var/www/html/wp-content";

const BACKEND_ADDRESS: &str = "http://127.0.0.1:4000";
const BACKEND_PATH_RESTORE: &str = "/restore";
const BACKEND_PATH_SITE_SETTINGS: &str = "/wp-cli/site-settings";
const BACKEND_PATH_USER: &str = "/wp-cli/user";
const BACKEND_PATH_USERS: &str = "/wp-cli/users";
const BACKEND_PATH_USER_META: &str = "/wp-cli/user-meta";

// The first user is also the current user
pub const FIRST_USER_ID: UserId = UserId(1);
pub const FIRST_USER_EMAIL: &str = "test@example.com";
pub const SECOND_USER_ID: UserId = UserId(2);
pub const SECOND_USER_EMAIL: &str = "themeshaperwp+demos@gmail.com";
pub const SECOND_USER_SLUG: &str = "themedemos";
pub const HELLO_DOLLY_PLUGIN_SLUG: &str = "hello-dolly/hello";
pub const CLASSIC_EDITOR_PLUGIN_SLUG: &str = "classic-editor/classic-editor";
pub const WP_ORG_PLUGIN_SLUG_CLASSIC_WIDGETS: &str = "classic-widgets";

pub fn api_client() -> WpApiClient {
    let authentication = WpAuthentication::from_username_and_password(
        TEST_CREDENTIALS_ADMIN_USERNAME.to_string(),
        TEST_CREDENTIALS_ADMIN_PASSWORD.to_string(),
    );
    WpApiClient::new(
        test_site_url(),
        authentication,
        Arc::new(AsyncWpNetworking::default()),
    )
}

pub fn api_client_as_subscriber() -> WpApiClient {
    let authentication = WpAuthentication::from_username_and_password(
        TEST_CREDENTIALS_SUBSCRIBER_USERNAME.to_string(),
        TEST_CREDENTIALS_SUBSCRIBER_PASSWORD.to_string(),
    );
    WpApiClient::new(
        test_site_url(),
        authentication,
        Arc::new(AsyncWpNetworking::default()),
    )
}

pub fn api_client_as_unauthenticated() -> WpApiClient {
    WpApiClient::new(
        test_site_url(),
        WpAuthentication::None,
        Arc::new(AsyncWpNetworking::default()),
    )
}

pub fn test_site_url() -> Arc<ParsedUrl> {
    ParsedUrl::parse(TEST_CREDENTIALS_SITE_URL)
        .expect("Site url is generated by our tooling")
        .into()
}

pub trait AssertWpError<T: std::fmt::Debug> {
    fn assert_wp_error(self, expected_error_code: WpErrorCode);
}

impl<T: std::fmt::Debug> AssertWpError<T> for Result<T, WpApiError> {
    fn assert_wp_error(self, expected_error_code: WpErrorCode) {
        let err = self.unwrap_err();
        if let WpApiError::WpError {
            error_code,
            response,
            ..
        } = err
        {
            assert_eq!(
                expected_error_code, error_code,
                "Incorrect error code. Expected '{:?}', found '{:?}'. Response was: '{:?}'",
                expected_error_code, error_code, response
            );
        } else {
            panic!("Unexpected wp_error '{:?}'", err);
        }
    }
}

#[derive(Debug)]
pub struct AsyncWpNetworking {
    client: reqwest::Client,
}

impl Default for AsyncWpNetworking {
    fn default() -> Self {
        Self {
            client: reqwest::Client::new(),
        }
    }
}

impl AsyncWpNetworking {
    pub async fn async_request(
        &self,
        wp_request: Arc<WpNetworkRequest>,
    ) -> Result<WpNetworkResponse, reqwest::Error> {
        let mut request = self
            .client
            .request(
                Self::request_method(wp_request.method()),
                wp_request.url().0.as_str(),
            )
            .headers(wp_request.header_map().as_header_map());
        if let Some(body) = wp_request.body() {
            request = request.body(body.contents());
        }
        let mut response = request.send().await?;

        let header_map = std::mem::take(response.headers_mut());
        Ok(WpNetworkResponse {
            status_code: response.status().as_u16(),
            body: response.bytes().await.unwrap().to_vec(),
            header_map: Arc::new(WpNetworkHeaderMap::new(header_map)),
        })
    }

    fn request_method(method: RequestMethod) -> http::Method {
        match method {
            RequestMethod::GET => reqwest::Method::GET,
            RequestMethod::POST => reqwest::Method::POST,
            RequestMethod::PUT => reqwest::Method::PUT,
            RequestMethod::DELETE => reqwest::Method::DELETE,
            RequestMethod::HEAD => reqwest::Method::HEAD,
        }
    }
}
#[async_trait]
impl RequestExecutor for AsyncWpNetworking {
    async fn execute(
        &self,
        request: Arc<WpNetworkRequest>,
    ) -> Result<WpNetworkResponse, RequestExecutionError> {
        self.async_request(request).await.map_err(|err| {
            RequestExecutionError::RequestExecutionFailed {
                status_code: err.status().map(|s| s.as_u16()),
                reason: err.to_string(),
            }
        })
    }
}

pub trait AssertResponse {
    type Item;

    fn assert_response(self) -> Self::Item;
}

impl<T: std::fmt::Debug, E: std::error::Error> AssertResponse for Result<T, E> {
    type Item = T;

    fn assert_response(self) -> T {
        assert!(
            self.is_ok(),
            "Request failed with: {:#?}",
            self.unwrap_err()
        );
        self.unwrap()
    }
}

#[derive(Debug)]
pub struct BackendSupport {
    client: reqwest::Client,
}

impl Default for BackendSupport {
    fn default() -> Self {
        Self {
            client: reqwest::Client::new(),
        }
    }
}

impl BackendSupport {
    pub async fn site_settings() -> Result<WpCliSiteSettings, reqwest::Error> {
        Self::default()
            .client
            .get(format!("{}{}", BACKEND_ADDRESS, BACKEND_PATH_SITE_SETTINGS))
            .send()
            .await?
            .json()
            .await
    }
    pub async fn user(user_id: UserId) -> WpCliUser {
        Self::default()
            .client
            .get(format!(
                "{}{}?user_id={}",
                BACKEND_ADDRESS, BACKEND_PATH_USER, user_id
            ))
            .send()
            .await
            .expect("Failed to fetch user from wp_cli")
            .json()
            .await
            .expect("Failed to parse fetched user from wp_cli")
    }
    pub async fn users() -> Vec<WpCliUser> {
        Self::default()
            .client
            .get(format!("{}{}", BACKEND_ADDRESS, BACKEND_PATH_USERS))
            .send()
            .await
            .expect("Failed to fetch users from wp_cli")
            .json()
            .await
            .expect("Failed to parse fetched users from wp_cli")
    }
    pub async fn user_meta(user_id: UserId) -> Vec<WpCliUserMeta> {
        Self::default()
            .client
            .get(format!(
                "{}{}?user_id={}",
                BACKEND_ADDRESS, BACKEND_PATH_USER_META, user_id
            ))
            .send()
            .await
            .expect("Failed to fetch user meta from wp_cli")
            .json()
            .await
            .expect("Failed to parse fetched user meta from wp_cli")
    }
}

#[derive(Debug, Serialize)]
pub struct ServerRestore;

impl ServerRestore {
    pub async fn db() {
        Self::restore(true, false).await;
    }

    pub async fn all() {
        Self::restore(true, true).await;
    }

    async fn restore(db: bool, plugins: bool) {
        let mut url = Url::parse(BACKEND_ADDRESS)
            .expect("BACKEND_ADDRESS is a valid URL")
            .join(BACKEND_PATH_RESTORE)
            .expect("BACKEND_PATH_RESTORE is a valid path");
        url.query_pairs_mut()
            .append_pair("db", db.to_string().as_str())
            .append_pair("plugins", plugins.to_string().as_str());
        reqwest::get(url).await.unwrap_or_else(|_| {
            panic!(
                "Restoring server failed: (db({}), plugins({}))",
                db, plugins
            )
        });
    }
}
