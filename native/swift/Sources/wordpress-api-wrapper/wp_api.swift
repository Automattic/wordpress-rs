// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(libwordpressFFI)
import libwordpressFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_wp_api_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_wp_api_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol ApplicationPasswordsRequestBuilderProtocol : AnyObject {
    
    func create(userId: UserId, params: ApplicationPasswordCreateParams)  -> WpNetworkRequest
    
    func delete(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)  -> WpNetworkRequest
    
    func deleteAll(userId: UserId)  -> WpNetworkRequest
    
    func filterListWithEditContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEditContext])  -> WpNetworkRequest
    
    func filterListWithEmbedContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEmbedContext])  -> WpNetworkRequest
    
    func filterListWithViewContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithViewContext])  -> WpNetworkRequest
    
    func filterRetrieveCurrentWithEditContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEditContext])  -> WpNetworkRequest
    
    func filterRetrieveCurrentWithEmbedContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEmbedContext])  -> WpNetworkRequest
    
    func filterRetrieveCurrentWithViewContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithViewContext])  -> WpNetworkRequest
    
    func filterRetrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithEditContext])  -> WpNetworkRequest
    
    func filterRetrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithEmbedContext])  -> WpNetworkRequest
    
    func filterRetrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithViewContext])  -> WpNetworkRequest
    
    func listWithEditContext(userId: UserId)  -> WpNetworkRequest
    
    func listWithEmbedContext(userId: UserId)  -> WpNetworkRequest
    
    func listWithViewContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveCurrentWithEditContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveCurrentWithEmbedContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveCurrentWithViewContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)  -> WpNetworkRequest
    
    func retrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)  -> WpNetworkRequest
    
    func retrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)  -> WpNetworkRequest
    
    func update(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, params: ApplicationPasswordUpdateParams)  -> WpNetworkRequest
    
}

open class ApplicationPasswordsRequestBuilder:
    ApplicationPasswordsRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_applicationpasswordsrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_applicationpasswordsrequestbuilder(pointer, $0) }
    }

    

    
open func create(userId: UserId, params: ApplicationPasswordCreateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_create(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordCreateParams.lower(params),$0
    )
})
}
    
open func delete(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_delete(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),$0
    )
})
}
    
open func deleteAll(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_delete_all(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func filterListWithEditContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEditContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_list_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEditContext.lower(fields),$0
    )
})
}
    
open func filterListWithEmbedContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEmbedContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_list_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEmbedContext.lower(fields),$0
    )
})
}
    
open func filterListWithViewContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithViewContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_list_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterSequenceTypeSparseApplicationPasswordFieldWithViewContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveCurrentWithEditContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEditContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_retrieve_current_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEditContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveCurrentWithEmbedContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEmbedContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_retrieve_current_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEmbedContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveCurrentWithViewContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithViewContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_retrieve_current_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterSequenceTypeSparseApplicationPasswordFieldWithViewContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithEditContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),
        FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEditContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithEmbedContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),
        FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEmbedContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithViewContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),
        FfiConverterSequenceTypeSparseApplicationPasswordFieldWithViewContext.lower(fields),$0
    )
})
}
    
open func listWithEditContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_list_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func listWithEmbedContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_list_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func listWithViewContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_list_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveCurrentWithEditContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_current_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveCurrentWithEmbedContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_current_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveCurrentWithViewContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_current_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),$0
    )
})
}
    
open func retrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),$0
    )
})
}
    
open func retrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),$0
    )
})
}
    
open func update(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, params: ApplicationPasswordUpdateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_update(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),
        FfiConverterTypeApplicationPasswordUpdateParams.lower(params),$0
    )
})
}
    

}

public struct FfiConverterTypeApplicationPasswordsRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ApplicationPasswordsRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ApplicationPasswordsRequestBuilder {
        return ApplicationPasswordsRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ApplicationPasswordsRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordsRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ApplicationPasswordsRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeApplicationPasswordsRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ApplicationPasswordsRequestBuilder {
    return try FfiConverterTypeApplicationPasswordsRequestBuilder.lift(pointer)
}

public func FfiConverterTypeApplicationPasswordsRequestBuilder_lower(_ value: ApplicationPasswordsRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeApplicationPasswordsRequestBuilder.lower(value)
}




public protocol ApplicationPasswordsRequestExecutorProtocol : AnyObject {
    
    func create(userId: UserId, params: ApplicationPasswordCreateParams) async throws  -> ApplicationPasswordWithEditContext
    
    func delete(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) async throws  -> ApplicationPasswordDeleteResponse
    
    func deleteAll(userId: UserId) async throws  -> ApplicationPasswordDeleteAllResponse
    
    func filterListWithEditContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEditContext]) async throws  -> [SparseApplicationPasswordWithEditContext]
    
    func filterListWithEmbedContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEmbedContext]) async throws  -> [SparseApplicationPasswordWithEmbedContext]
    
    func filterListWithViewContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithViewContext]) async throws  -> [SparseApplicationPasswordWithViewContext]
    
    func filterRetrieveCurrentWithEditContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEditContext]) async throws  -> SparseApplicationPasswordWithEditContext
    
    func filterRetrieveCurrentWithEmbedContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEmbedContext]) async throws  -> SparseApplicationPasswordWithEmbedContext
    
    func filterRetrieveCurrentWithViewContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithViewContext]) async throws  -> SparseApplicationPasswordWithViewContext
    
    func filterRetrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithEditContext]) async throws  -> SparseApplicationPasswordWithEditContext
    
    func filterRetrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithEmbedContext]) async throws  -> SparseApplicationPasswordWithEmbedContext
    
    func filterRetrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithViewContext]) async throws  -> SparseApplicationPasswordWithViewContext
    
    func listWithEditContext(userId: UserId) async throws  -> [ApplicationPasswordWithEditContext]
    
    func listWithEmbedContext(userId: UserId) async throws  -> [ApplicationPasswordWithEmbedContext]
    
    func listWithViewContext(userId: UserId) async throws  -> [ApplicationPasswordWithViewContext]
    
    func retrieveCurrentWithEditContext(userId: UserId) async throws  -> ApplicationPasswordWithEditContext
    
    func retrieveCurrentWithEmbedContext(userId: UserId) async throws  -> ApplicationPasswordWithEmbedContext
    
    func retrieveCurrentWithViewContext(userId: UserId) async throws  -> ApplicationPasswordWithViewContext
    
    func retrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) async throws  -> ApplicationPasswordWithEditContext
    
    func retrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) async throws  -> ApplicationPasswordWithEmbedContext
    
    func retrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) async throws  -> ApplicationPasswordWithViewContext
    
    func update(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, params: ApplicationPasswordUpdateParams) async throws  -> ApplicationPasswordWithEditContext
    
}

open class ApplicationPasswordsRequestExecutor:
    ApplicationPasswordsRequestExecutorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_applicationpasswordsrequestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_applicationpasswordsrequestexecutor(pointer, $0) }
    }

    

    
open func create(userId: UserId, params: ApplicationPasswordCreateParams)async throws  -> ApplicationPasswordWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_create(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordCreateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func delete(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)async throws  -> ApplicationPasswordDeleteResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordDeleteResponse.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func deleteAll(userId: UserId)async throws  -> ApplicationPasswordDeleteAllResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_delete_all(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordDeleteAllResponse.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterListWithEditContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEditContext])async throws  -> [SparseApplicationPasswordWithEditContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_list_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEditContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparseApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterListWithEmbedContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEmbedContext])async throws  -> [SparseApplicationPasswordWithEmbedContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_list_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEmbedContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparseApplicationPasswordWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterListWithViewContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithViewContext])async throws  -> [SparseApplicationPasswordWithViewContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_list_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterSequenceTypeSparseApplicationPasswordFieldWithViewContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparseApplicationPasswordWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveCurrentWithEditContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEditContext])async throws  -> SparseApplicationPasswordWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_retrieve_current_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEditContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveCurrentWithEmbedContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithEmbedContext])async throws  -> SparseApplicationPasswordWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_retrieve_current_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEmbedContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseApplicationPasswordWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveCurrentWithViewContext(userId: UserId, fields: [SparseApplicationPasswordFieldWithViewContext])async throws  -> SparseApplicationPasswordWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_retrieve_current_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterSequenceTypeSparseApplicationPasswordFieldWithViewContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseApplicationPasswordWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithEditContext])async throws  -> SparseApplicationPasswordWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEditContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithEmbedContext])async throws  -> SparseApplicationPasswordWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEmbedContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseApplicationPasswordWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, fields: [SparseApplicationPasswordFieldWithViewContext])async throws  -> SparseApplicationPasswordWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),FfiConverterSequenceTypeSparseApplicationPasswordFieldWithViewContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseApplicationPasswordWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEditContext(userId: UserId)async throws  -> [ApplicationPasswordWithEditContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_list_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEmbedContext(userId: UserId)async throws  -> [ApplicationPasswordWithEmbedContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_list_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeApplicationPasswordWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithViewContext(userId: UserId)async throws  -> [ApplicationPasswordWithViewContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_list_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeApplicationPasswordWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveCurrentWithEditContext(userId: UserId)async throws  -> ApplicationPasswordWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_current_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveCurrentWithEmbedContext(userId: UserId)async throws  -> ApplicationPasswordWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_current_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveCurrentWithViewContext(userId: UserId)async throws  -> ApplicationPasswordWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_current_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)async throws  -> ApplicationPasswordWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)async throws  -> ApplicationPasswordWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)async throws  -> ApplicationPasswordWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func update(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, params: ApplicationPasswordUpdateParams)async throws  -> ApplicationPasswordWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_update(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),FfiConverterTypeApplicationPasswordUpdateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    

}

public struct FfiConverterTypeApplicationPasswordsRequestExecutor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ApplicationPasswordsRequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ApplicationPasswordsRequestExecutor {
        return ApplicationPasswordsRequestExecutor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ApplicationPasswordsRequestExecutor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordsRequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ApplicationPasswordsRequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeApplicationPasswordsRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> ApplicationPasswordsRequestExecutor {
    return try FfiConverterTypeApplicationPasswordsRequestExecutor.lift(pointer)
}

public func FfiConverterTypeApplicationPasswordsRequestExecutor_lower(_ value: ApplicationPasswordsRequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeApplicationPasswordsRequestExecutor.lower(value)
}




public protocol ParsedUrlProtocol : AnyObject {
    
    func url()  -> String
    
}

open class ParsedUrl:
    ParsedUrlProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_parsedurl(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_parsedurl(pointer, $0) }
    }

    
public static func parse(input: String)throws  -> ParsedUrl {
    return try  FfiConverterTypeParsedUrl.lift(try rustCallWithError(FfiConverterTypeParseUrlError.lift) {
    uniffi_wp_api_fn_constructor_parsedurl_parse(
        FfiConverterString.lower(input),$0
    )
})
}
    

    
open func url() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_wp_api_fn_method_parsedurl_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeParsedUrl: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ParsedUrl

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ParsedUrl {
        return ParsedUrl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ParsedUrl) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedUrl {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ParsedUrl, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeParsedUrl_lift(_ pointer: UnsafeMutableRawPointer) throws -> ParsedUrl {
    return try FfiConverterTypeParsedUrl.lift(pointer)
}

public func FfiConverterTypeParsedUrl_lower(_ value: ParsedUrl) -> UnsafeMutableRawPointer {
    return FfiConverterTypeParsedUrl.lower(value)
}




public protocol PluginsRequestBuilderProtocol : AnyObject {
    
    func create(params: PluginCreateParams)  -> WpNetworkRequest
    
    func delete(pluginSlug: PluginSlug)  -> WpNetworkRequest
    
    func filterListWithEditContext(params: PluginListParams, fields: [SparsePluginFieldWithEditContext])  -> WpNetworkRequest
    
    func filterListWithEmbedContext(params: PluginListParams, fields: [SparsePluginFieldWithEmbedContext])  -> WpNetworkRequest
    
    func filterListWithViewContext(params: PluginListParams, fields: [SparsePluginFieldWithViewContext])  -> WpNetworkRequest
    
    func filterRetrieveWithEditContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithEditContext])  -> WpNetworkRequest
    
    func filterRetrieveWithEmbedContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithEmbedContext])  -> WpNetworkRequest
    
    func filterRetrieveWithViewContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithViewContext])  -> WpNetworkRequest
    
    func listWithEditContext(params: PluginListParams)  -> WpNetworkRequest
    
    func listWithEmbedContext(params: PluginListParams)  -> WpNetworkRequest
    
    func listWithViewContext(params: PluginListParams)  -> WpNetworkRequest
    
    func retrieveWithEditContext(pluginSlug: PluginSlug)  -> WpNetworkRequest
    
    func retrieveWithEmbedContext(pluginSlug: PluginSlug)  -> WpNetworkRequest
    
    func retrieveWithViewContext(pluginSlug: PluginSlug)  -> WpNetworkRequest
    
    func update(pluginSlug: PluginSlug, params: PluginUpdateParams)  -> WpNetworkRequest
    
}

open class PluginsRequestBuilder:
    PluginsRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_pluginsrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_pluginsrequestbuilder(pointer, $0) }
    }

    

    
open func create(params: PluginCreateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_create(self.uniffiClonePointer(),
        FfiConverterTypePluginCreateParams.lower(params),$0
    )
})
}
    
open func delete(pluginSlug: PluginSlug) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_delete(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),$0
    )
})
}
    
open func filterListWithEditContext(params: PluginListParams, fields: [SparsePluginFieldWithEditContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_filter_list_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypePluginListParams.lower(params),
        FfiConverterSequenceTypeSparsePluginFieldWithEditContext.lower(fields),$0
    )
})
}
    
open func filterListWithEmbedContext(params: PluginListParams, fields: [SparsePluginFieldWithEmbedContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_filter_list_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypePluginListParams.lower(params),
        FfiConverterSequenceTypeSparsePluginFieldWithEmbedContext.lower(fields),$0
    )
})
}
    
open func filterListWithViewContext(params: PluginListParams, fields: [SparsePluginFieldWithViewContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_filter_list_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypePluginListParams.lower(params),
        FfiConverterSequenceTypeSparsePluginFieldWithViewContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithEditContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithEditContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_filter_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),
        FfiConverterSequenceTypeSparsePluginFieldWithEditContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithEmbedContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithEmbedContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_filter_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),
        FfiConverterSequenceTypeSparsePluginFieldWithEmbedContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithViewContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithViewContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_filter_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),
        FfiConverterSequenceTypeSparsePluginFieldWithViewContext.lower(fields),$0
    )
})
}
    
open func listWithEditContext(params: PluginListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_list_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypePluginListParams.lower(params),$0
    )
})
}
    
open func listWithEmbedContext(params: PluginListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_list_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypePluginListParams.lower(params),$0
    )
})
}
    
open func listWithViewContext(params: PluginListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_list_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypePluginListParams.lower(params),$0
    )
})
}
    
open func retrieveWithEditContext(pluginSlug: PluginSlug) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),$0
    )
})
}
    
open func retrieveWithEmbedContext(pluginSlug: PluginSlug) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),$0
    )
})
}
    
open func retrieveWithViewContext(pluginSlug: PluginSlug) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),$0
    )
})
}
    
open func update(pluginSlug: PluginSlug, params: PluginUpdateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_update(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),
        FfiConverterTypePluginUpdateParams.lower(params),$0
    )
})
}
    

}

public struct FfiConverterTypePluginsRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PluginsRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PluginsRequestBuilder {
        return PluginsRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PluginsRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginsRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PluginsRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypePluginsRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> PluginsRequestBuilder {
    return try FfiConverterTypePluginsRequestBuilder.lift(pointer)
}

public func FfiConverterTypePluginsRequestBuilder_lower(_ value: PluginsRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypePluginsRequestBuilder.lower(value)
}




public protocol PluginsRequestExecutorProtocol : AnyObject {
    
    func create(params: PluginCreateParams) async throws  -> PluginWithEditContext
    
    func delete(pluginSlug: PluginSlug) async throws  -> PluginDeleteResponse
    
    func filterListWithEditContext(params: PluginListParams, fields: [SparsePluginFieldWithEditContext]) async throws  -> [SparsePluginWithEditContext]
    
    func filterListWithEmbedContext(params: PluginListParams, fields: [SparsePluginFieldWithEmbedContext]) async throws  -> [SparsePluginWithEmbedContext]
    
    func filterListWithViewContext(params: PluginListParams, fields: [SparsePluginFieldWithViewContext]) async throws  -> [SparsePluginWithViewContext]
    
    func filterRetrieveWithEditContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithEditContext]) async throws  -> SparsePluginWithEditContext
    
    func filterRetrieveWithEmbedContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithEmbedContext]) async throws  -> SparsePluginWithEmbedContext
    
    func filterRetrieveWithViewContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithViewContext]) async throws  -> SparsePluginWithViewContext
    
    func listWithEditContext(params: PluginListParams) async throws  -> [PluginWithEditContext]
    
    func listWithEmbedContext(params: PluginListParams) async throws  -> [PluginWithEmbedContext]
    
    func listWithViewContext(params: PluginListParams) async throws  -> [PluginWithViewContext]
    
    func retrieveWithEditContext(pluginSlug: PluginSlug) async throws  -> PluginWithEditContext
    
    func retrieveWithEmbedContext(pluginSlug: PluginSlug) async throws  -> PluginWithEmbedContext
    
    func retrieveWithViewContext(pluginSlug: PluginSlug) async throws  -> PluginWithViewContext
    
    func update(pluginSlug: PluginSlug, params: PluginUpdateParams) async throws  -> PluginWithEditContext
    
}

open class PluginsRequestExecutor:
    PluginsRequestExecutorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_pluginsrequestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_pluginsrequestexecutor(pointer, $0) }
    }

    

    
open func create(params: PluginCreateParams)async throws  -> PluginWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_create(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginCreateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func delete(pluginSlug: PluginSlug)async throws  -> PluginDeleteResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginDeleteResponse.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterListWithEditContext(params: PluginListParams, fields: [SparsePluginFieldWithEditContext])async throws  -> [SparsePluginWithEditContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_filter_list_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginListParams.lower(params),FfiConverterSequenceTypeSparsePluginFieldWithEditContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparsePluginWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterListWithEmbedContext(params: PluginListParams, fields: [SparsePluginFieldWithEmbedContext])async throws  -> [SparsePluginWithEmbedContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_filter_list_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginListParams.lower(params),FfiConverterSequenceTypeSparsePluginFieldWithEmbedContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparsePluginWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterListWithViewContext(params: PluginListParams, fields: [SparsePluginFieldWithViewContext])async throws  -> [SparsePluginWithViewContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_filter_list_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginListParams.lower(params),FfiConverterSequenceTypeSparsePluginFieldWithViewContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparsePluginWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithEditContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithEditContext])async throws  -> SparsePluginWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_filter_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug),FfiConverterSequenceTypeSparsePluginFieldWithEditContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparsePluginWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithEmbedContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithEmbedContext])async throws  -> SparsePluginWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_filter_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug),FfiConverterSequenceTypeSparsePluginFieldWithEmbedContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparsePluginWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithViewContext(pluginSlug: PluginSlug, fields: [SparsePluginFieldWithViewContext])async throws  -> SparsePluginWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_filter_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug),FfiConverterSequenceTypeSparsePluginFieldWithViewContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparsePluginWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEditContext(params: PluginListParams)async throws  -> [PluginWithEditContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_list_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePluginWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEmbedContext(params: PluginListParams)async throws  -> [PluginWithEmbedContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_list_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePluginWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithViewContext(params: PluginListParams)async throws  -> [PluginWithViewContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_list_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePluginWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEditContext(pluginSlug: PluginSlug)async throws  -> PluginWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEmbedContext(pluginSlug: PluginSlug)async throws  -> PluginWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithViewContext(pluginSlug: PluginSlug)async throws  -> PluginWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func update(pluginSlug: PluginSlug, params: PluginUpdateParams)async throws  -> PluginWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_update(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug),FfiConverterTypePluginUpdateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    

}

public struct FfiConverterTypePluginsRequestExecutor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PluginsRequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PluginsRequestExecutor {
        return PluginsRequestExecutor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PluginsRequestExecutor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginsRequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PluginsRequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypePluginsRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> PluginsRequestExecutor {
    return try FfiConverterTypePluginsRequestExecutor.lift(pointer)
}

public func FfiConverterTypePluginsRequestExecutor_lower(_ value: PluginsRequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypePluginsRequestExecutor.lower(value)
}




public protocol PostTypesRequestBuilderProtocol : AnyObject {
    
    func filterRetrieveWithEditContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithEditContext])  -> WpNetworkRequest
    
    func filterRetrieveWithEmbedContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithEmbedContext])  -> WpNetworkRequest
    
    func filterRetrieveWithViewContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithViewContext])  -> WpNetworkRequest
    
    func listWithEditContext()  -> WpNetworkRequest
    
    func listWithEmbedContext()  -> WpNetworkRequest
    
    func listWithViewContext()  -> WpNetworkRequest
    
    func retrieveWithEditContext(postType: PostType)  -> WpNetworkRequest
    
    func retrieveWithEmbedContext(postType: PostType)  -> WpNetworkRequest
    
    func retrieveWithViewContext(postType: PostType)  -> WpNetworkRequest
    
}

open class PostTypesRequestBuilder:
    PostTypesRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_posttypesrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_posttypesrequestbuilder(pointer, $0) }
    }

    

    
open func filterRetrieveWithEditContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithEditContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_posttypesrequestbuilder_filter_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypePostType.lower(postType),
        FfiConverterSequenceTypeSparsePostTypeDetailsFieldWithEditContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithEmbedContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithEmbedContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_posttypesrequestbuilder_filter_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypePostType.lower(postType),
        FfiConverterSequenceTypeSparsePostTypeDetailsFieldWithEmbedContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithViewContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithViewContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_posttypesrequestbuilder_filter_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypePostType.lower(postType),
        FfiConverterSequenceTypeSparsePostTypeDetailsFieldWithViewContext.lower(fields),$0
    )
})
}
    
open func listWithEditContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_posttypesrequestbuilder_list_with_edit_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func listWithEmbedContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_posttypesrequestbuilder_list_with_embed_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func listWithViewContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_posttypesrequestbuilder_list_with_view_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func retrieveWithEditContext(postType: PostType) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_posttypesrequestbuilder_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypePostType.lower(postType),$0
    )
})
}
    
open func retrieveWithEmbedContext(postType: PostType) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_posttypesrequestbuilder_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypePostType.lower(postType),$0
    )
})
}
    
open func retrieveWithViewContext(postType: PostType) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_posttypesrequestbuilder_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypePostType.lower(postType),$0
    )
})
}
    

}

public struct FfiConverterTypePostTypesRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PostTypesRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PostTypesRequestBuilder {
        return PostTypesRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PostTypesRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypesRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PostTypesRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypePostTypesRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> PostTypesRequestBuilder {
    return try FfiConverterTypePostTypesRequestBuilder.lift(pointer)
}

public func FfiConverterTypePostTypesRequestBuilder_lower(_ value: PostTypesRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypePostTypesRequestBuilder.lower(value)
}




public protocol PostTypesRequestExecutorProtocol : AnyObject {
    
    func filterRetrieveWithEditContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithEditContext]) async throws  -> SparsePostTypeDetailsWithEditContext
    
    func filterRetrieveWithEmbedContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithEmbedContext]) async throws  -> SparsePostTypeDetailsWithEmbedContext
    
    func filterRetrieveWithViewContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithViewContext]) async throws  -> SparsePostTypeDetailsWithViewContext
    
    func listWithEditContext() async throws  -> PostTypesResponseWithEditContext
    
    func listWithEmbedContext() async throws  -> PostTypesResponseWithEmbedContext
    
    func listWithViewContext() async throws  -> PostTypesResponseWithViewContext
    
    func retrieveWithEditContext(postType: PostType) async throws  -> PostTypeDetailsWithEditContext
    
    func retrieveWithEmbedContext(postType: PostType) async throws  -> PostTypeDetailsWithEmbedContext
    
    func retrieveWithViewContext(postType: PostType) async throws  -> PostTypeDetailsWithViewContext
    
}

open class PostTypesRequestExecutor:
    PostTypesRequestExecutorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_posttypesrequestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_posttypesrequestexecutor(pointer, $0) }
    }

    

    
open func filterRetrieveWithEditContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithEditContext])async throws  -> SparsePostTypeDetailsWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_posttypesrequestexecutor_filter_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePostType.lower(postType),FfiConverterSequenceTypeSparsePostTypeDetailsFieldWithEditContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparsePostTypeDetailsWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithEmbedContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithEmbedContext])async throws  -> SparsePostTypeDetailsWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_posttypesrequestexecutor_filter_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePostType.lower(postType),FfiConverterSequenceTypeSparsePostTypeDetailsFieldWithEmbedContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparsePostTypeDetailsWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithViewContext(postType: PostType, fields: [SparsePostTypeDetailsFieldWithViewContext])async throws  -> SparsePostTypeDetailsWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_posttypesrequestexecutor_filter_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePostType.lower(postType),FfiConverterSequenceTypeSparsePostTypeDetailsFieldWithViewContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparsePostTypeDetailsWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEditContext()async throws  -> PostTypesResponseWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_posttypesrequestexecutor_list_with_edit_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePostTypesResponseWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEmbedContext()async throws  -> PostTypesResponseWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_posttypesrequestexecutor_list_with_embed_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePostTypesResponseWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithViewContext()async throws  -> PostTypesResponseWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_posttypesrequestexecutor_list_with_view_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePostTypesResponseWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEditContext(postType: PostType)async throws  -> PostTypeDetailsWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_posttypesrequestexecutor_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePostType.lower(postType)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePostTypeDetailsWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEmbedContext(postType: PostType)async throws  -> PostTypeDetailsWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_posttypesrequestexecutor_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePostType.lower(postType)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePostTypeDetailsWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithViewContext(postType: PostType)async throws  -> PostTypeDetailsWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_posttypesrequestexecutor_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePostType.lower(postType)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePostTypeDetailsWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    

}

public struct FfiConverterTypePostTypesRequestExecutor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PostTypesRequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PostTypesRequestExecutor {
        return PostTypesRequestExecutor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PostTypesRequestExecutor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypesRequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PostTypesRequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypePostTypesRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> PostTypesRequestExecutor {
    return try FfiConverterTypePostTypesRequestExecutor.lift(pointer)
}

public func FfiConverterTypePostTypesRequestExecutor_lower(_ value: PostTypesRequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypePostTypesRequestExecutor.lower(value)
}




public protocol RequestExecutor : AnyObject {
    
    func execute(request: WpNetworkRequest) async throws  -> WpNetworkResponse
    
}

open class RequestExecutorImpl:
    RequestExecutor {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_requestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_requestexecutor(pointer, $0) }
    }

    

    
open func execute(request: WpNetworkRequest)async throws  -> WpNetworkResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_requestexecutor_execute(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWpNetworkRequest.lower(request)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWpNetworkResponse.lift,
            errorHandler: FfiConverterTypeRequestExecutionError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRequestExecutor {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRequestExecutor = UniffiVTableCallbackInterfaceRequestExecutor(
        execute: { (
            uniffiHandle: UInt64,
            request: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> WpNetworkResponse in
                guard let uniffiObj = try? FfiConverterTypeRequestExecutor.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.execute(
                     request: try FfiConverterTypeWpNetworkRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: WpNetworkResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeWpNetworkResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeRequestExecutionError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeRequestExecutor.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RequestExecutor: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRequestExecutor() {
    uniffi_wp_api_fn_init_callback_vtable_requestexecutor(&UniffiCallbackInterfaceRequestExecutor.vtable)
}

public struct FfiConverterTypeRequestExecutor: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<RequestExecutor>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RequestExecutor {
        return RequestExecutorImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RequestExecutor) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> RequestExecutor {
    return try FfiConverterTypeRequestExecutor.lift(pointer)
}

public func FfiConverterTypeRequestExecutor_lower(_ value: RequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRequestExecutor.lower(value)
}




public protocol SiteSettingsRequestBuilderProtocol : AnyObject {
    
    func filterRetrieveWithEditContext(fields: [SparseSiteSettingsFieldWithEditContext])  -> WpNetworkRequest
    
    func filterRetrieveWithEmbedContext(fields: [SparseSiteSettingsFieldWithEmbedContext])  -> WpNetworkRequest
    
    func filterRetrieveWithViewContext(fields: [SparseSiteSettingsFieldWithViewContext])  -> WpNetworkRequest
    
    func retrieveWithEditContext()  -> WpNetworkRequest
    
    func retrieveWithEmbedContext()  -> WpNetworkRequest
    
    func retrieveWithViewContext()  -> WpNetworkRequest
    
    func update(params: SiteSettingsUpdateParams)  -> WpNetworkRequest
    
}

open class SiteSettingsRequestBuilder:
    SiteSettingsRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_sitesettingsrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_sitesettingsrequestbuilder(pointer, $0) }
    }

    

    
open func filterRetrieveWithEditContext(fields: [SparseSiteSettingsFieldWithEditContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_sitesettingsrequestbuilder_filter_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseSiteSettingsFieldWithEditContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithEmbedContext(fields: [SparseSiteSettingsFieldWithEmbedContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_sitesettingsrequestbuilder_filter_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseSiteSettingsFieldWithEmbedContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithViewContext(fields: [SparseSiteSettingsFieldWithViewContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_sitesettingsrequestbuilder_filter_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseSiteSettingsFieldWithViewContext.lower(fields),$0
    )
})
}
    
open func retrieveWithEditContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_sitesettingsrequestbuilder_retrieve_with_edit_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func retrieveWithEmbedContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_sitesettingsrequestbuilder_retrieve_with_embed_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func retrieveWithViewContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_sitesettingsrequestbuilder_retrieve_with_view_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func update(params: SiteSettingsUpdateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_sitesettingsrequestbuilder_update(self.uniffiClonePointer(),
        FfiConverterTypeSiteSettingsUpdateParams.lower(params),$0
    )
})
}
    

}

public struct FfiConverterTypeSiteSettingsRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SiteSettingsRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SiteSettingsRequestBuilder {
        return SiteSettingsRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SiteSettingsRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SiteSettingsRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SiteSettingsRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSiteSettingsRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SiteSettingsRequestBuilder {
    return try FfiConverterTypeSiteSettingsRequestBuilder.lift(pointer)
}

public func FfiConverterTypeSiteSettingsRequestBuilder_lower(_ value: SiteSettingsRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSiteSettingsRequestBuilder.lower(value)
}




public protocol SiteSettingsRequestExecutorProtocol : AnyObject {
    
    func filterRetrieveWithEditContext(fields: [SparseSiteSettingsFieldWithEditContext]) async throws  -> SparseSiteSettingsWithEditContext
    
    func filterRetrieveWithEmbedContext(fields: [SparseSiteSettingsFieldWithEmbedContext]) async throws  -> SparseSiteSettingsWithEmbedContext
    
    func filterRetrieveWithViewContext(fields: [SparseSiteSettingsFieldWithViewContext]) async throws  -> SparseSiteSettingsWithViewContext
    
    func retrieveWithEditContext() async throws  -> SiteSettingsWithEditContext
    
    func retrieveWithEmbedContext() async throws  -> SiteSettingsWithEmbedContext
    
    func retrieveWithViewContext() async throws  -> SiteSettingsWithViewContext
    
    func update(params: SiteSettingsUpdateParams) async throws  -> SiteSettingsWithEditContext
    
}

open class SiteSettingsRequestExecutor:
    SiteSettingsRequestExecutorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_sitesettingsrequestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_sitesettingsrequestexecutor(pointer, $0) }
    }

    

    
open func filterRetrieveWithEditContext(fields: [SparseSiteSettingsFieldWithEditContext])async throws  -> SparseSiteSettingsWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_sitesettingsrequestexecutor_filter_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseSiteSettingsFieldWithEditContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseSiteSettingsWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithEmbedContext(fields: [SparseSiteSettingsFieldWithEmbedContext])async throws  -> SparseSiteSettingsWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_sitesettingsrequestexecutor_filter_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseSiteSettingsFieldWithEmbedContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseSiteSettingsWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithViewContext(fields: [SparseSiteSettingsFieldWithViewContext])async throws  -> SparseSiteSettingsWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_sitesettingsrequestexecutor_filter_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseSiteSettingsFieldWithViewContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseSiteSettingsWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEditContext()async throws  -> SiteSettingsWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_sitesettingsrequestexecutor_retrieve_with_edit_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSiteSettingsWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEmbedContext()async throws  -> SiteSettingsWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_sitesettingsrequestexecutor_retrieve_with_embed_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSiteSettingsWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithViewContext()async throws  -> SiteSettingsWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_sitesettingsrequestexecutor_retrieve_with_view_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSiteSettingsWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func update(params: SiteSettingsUpdateParams)async throws  -> SiteSettingsWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_sitesettingsrequestexecutor_update(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSiteSettingsUpdateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSiteSettingsWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    

}

public struct FfiConverterTypeSiteSettingsRequestExecutor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SiteSettingsRequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SiteSettingsRequestExecutor {
        return SiteSettingsRequestExecutor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SiteSettingsRequestExecutor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SiteSettingsRequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SiteSettingsRequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSiteSettingsRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> SiteSettingsRequestExecutor {
    return try FfiConverterTypeSiteSettingsRequestExecutor.lift(pointer)
}

public func FfiConverterTypeSiteSettingsRequestExecutor_lower(_ value: SiteSettingsRequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSiteSettingsRequestExecutor.lower(value)
}




public protocol UniffiWpApiClientProtocol : AnyObject {
    
    func applicationPasswords()  -> ApplicationPasswordsRequestExecutor
    
    func plugins()  -> PluginsRequestExecutor
    
    func postTypes()  -> PostTypesRequestExecutor
    
    func siteSettings()  -> SiteSettingsRequestExecutor
    
    func users()  -> UsersRequestExecutor
    
    func wpSiteHealthTests()  -> WpSiteHealthTestsRequestExecutor
    
}

open class UniffiWpApiClient:
    UniffiWpApiClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_uniffiwpapiclient(self.pointer, $0) }
    }
public convenience init(siteUrl: ParsedUrl, authentication: WpAuthentication, requestExecutor: RequestExecutor) {
    let pointer =
        try! rustCall() {
    uniffi_wp_api_fn_constructor_uniffiwpapiclient_new(
        FfiConverterTypeParsedUrl.lower(siteUrl),
        FfiConverterTypeWpAuthentication.lower(authentication),
        FfiConverterTypeRequestExecutor.lower(requestExecutor),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_uniffiwpapiclient(pointer, $0) }
    }

    

    
open func applicationPasswords() -> ApplicationPasswordsRequestExecutor {
    return try!  FfiConverterTypeApplicationPasswordsRequestExecutor.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapiclient_application_passwords(self.uniffiClonePointer(),$0
    )
})
}
    
open func plugins() -> PluginsRequestExecutor {
    return try!  FfiConverterTypePluginsRequestExecutor.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapiclient_plugins(self.uniffiClonePointer(),$0
    )
})
}
    
open func postTypes() -> PostTypesRequestExecutor {
    return try!  FfiConverterTypePostTypesRequestExecutor.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapiclient_post_types(self.uniffiClonePointer(),$0
    )
})
}
    
open func siteSettings() -> SiteSettingsRequestExecutor {
    return try!  FfiConverterTypeSiteSettingsRequestExecutor.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapiclient_site_settings(self.uniffiClonePointer(),$0
    )
})
}
    
open func users() -> UsersRequestExecutor {
    return try!  FfiConverterTypeUsersRequestExecutor.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapiclient_users(self.uniffiClonePointer(),$0
    )
})
}
    
open func wpSiteHealthTests() -> WpSiteHealthTestsRequestExecutor {
    return try!  FfiConverterTypeWpSiteHealthTestsRequestExecutor.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapiclient_wp_site_health_tests(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeUniffiWpApiClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UniffiWpApiClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpApiClient {
        return UniffiWpApiClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UniffiWpApiClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiWpApiClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UniffiWpApiClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUniffiWpApiClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpApiClient {
    return try FfiConverterTypeUniffiWpApiClient.lift(pointer)
}

public func FfiConverterTypeUniffiWpApiClient_lower(_ value: UniffiWpApiClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUniffiWpApiClient.lower(value)
}




public protocol UniffiWpApiRequestBuilderProtocol : AnyObject {
    
    func applicationPasswords()  -> ApplicationPasswordsRequestBuilder
    
    func plugins()  -> PluginsRequestBuilder
    
    func postTypes()  -> PostTypesRequestBuilder
    
    func siteSettings()  -> SiteSettingsRequestBuilder
    
    func users()  -> UsersRequestBuilder
    
    func wpSiteHealthTests()  -> WpSiteHealthTestsRequestBuilder
    
}

open class UniffiWpApiRequestBuilder:
    UniffiWpApiRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_uniffiwpapirequestbuilder(self.pointer, $0) }
    }
public convenience init(siteUrl: ParsedUrl, authentication: WpAuthentication) {
    let pointer =
        try! rustCall() {
    uniffi_wp_api_fn_constructor_uniffiwpapirequestbuilder_new(
        FfiConverterTypeParsedUrl.lower(siteUrl),
        FfiConverterTypeWpAuthentication.lower(authentication),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_uniffiwpapirequestbuilder(pointer, $0) }
    }

    

    
open func applicationPasswords() -> ApplicationPasswordsRequestBuilder {
    return try!  FfiConverterTypeApplicationPasswordsRequestBuilder.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapirequestbuilder_application_passwords(self.uniffiClonePointer(),$0
    )
})
}
    
open func plugins() -> PluginsRequestBuilder {
    return try!  FfiConverterTypePluginsRequestBuilder.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapirequestbuilder_plugins(self.uniffiClonePointer(),$0
    )
})
}
    
open func postTypes() -> PostTypesRequestBuilder {
    return try!  FfiConverterTypePostTypesRequestBuilder.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapirequestbuilder_post_types(self.uniffiClonePointer(),$0
    )
})
}
    
open func siteSettings() -> SiteSettingsRequestBuilder {
    return try!  FfiConverterTypeSiteSettingsRequestBuilder.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapirequestbuilder_site_settings(self.uniffiClonePointer(),$0
    )
})
}
    
open func users() -> UsersRequestBuilder {
    return try!  FfiConverterTypeUsersRequestBuilder.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapirequestbuilder_users(self.uniffiClonePointer(),$0
    )
})
}
    
open func wpSiteHealthTests() -> WpSiteHealthTestsRequestBuilder {
    return try!  FfiConverterTypeWpSiteHealthTestsRequestBuilder.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapirequestbuilder_wp_site_health_tests(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeUniffiWpApiRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UniffiWpApiRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpApiRequestBuilder {
        return UniffiWpApiRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UniffiWpApiRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiWpApiRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UniffiWpApiRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUniffiWpApiRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpApiRequestBuilder {
    return try FfiConverterTypeUniffiWpApiRequestBuilder.lift(pointer)
}

public func FfiConverterTypeUniffiWpApiRequestBuilder_lower(_ value: UniffiWpApiRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUniffiWpApiRequestBuilder.lower(value)
}




public protocol UniffiWpLoginClientProtocol : AnyObject {
    
    func apiDiscovery(siteUrl: String) async throws  -> UrlDiscoverySuccess
    
}

open class UniffiWpLoginClient:
    UniffiWpLoginClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_uniffiwploginclient(self.pointer, $0) }
    }
public convenience init(requestExecutor: RequestExecutor) {
    let pointer =
        try! rustCall() {
    uniffi_wp_api_fn_constructor_uniffiwploginclient_new(
        FfiConverterTypeRequestExecutor.lower(requestExecutor),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_uniffiwploginclient(pointer, $0) }
    }

    

    
open func apiDiscovery(siteUrl: String)async throws  -> UrlDiscoverySuccess {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_uniffiwploginclient_api_discovery(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(siteUrl)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUrlDiscoverySuccess.lift,
            errorHandler: FfiConverterTypeUrlDiscoveryError.lift
        )
}
    

}

public struct FfiConverterTypeUniffiWpLoginClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UniffiWpLoginClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpLoginClient {
        return UniffiWpLoginClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UniffiWpLoginClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiWpLoginClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UniffiWpLoginClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUniffiWpLoginClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpLoginClient {
    return try FfiConverterTypeUniffiWpLoginClient.lift(pointer)
}

public func FfiConverterTypeUniffiWpLoginClient_lower(_ value: UniffiWpLoginClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUniffiWpLoginClient.lower(value)
}




public protocol UsersRequestBuilderProtocol : AnyObject {
    
    func create(params: UserCreateParams)  -> WpNetworkRequest
    
    func delete(userId: UserId, params: UserDeleteParams)  -> WpNetworkRequest
    
    func deleteMe(params: UserDeleteParams)  -> WpNetworkRequest
    
    func filterListWithEditContext(params: UserListParams, fields: [SparseUserFieldWithEditContext])  -> WpNetworkRequest
    
    func filterListWithEmbedContext(params: UserListParams, fields: [SparseUserFieldWithEmbedContext])  -> WpNetworkRequest
    
    func filterListWithViewContext(params: UserListParams, fields: [SparseUserFieldWithViewContext])  -> WpNetworkRequest
    
    func filterRetrieveMeWithEditContext(fields: [SparseUserFieldWithEditContext])  -> WpNetworkRequest
    
    func filterRetrieveMeWithEmbedContext(fields: [SparseUserFieldWithEmbedContext])  -> WpNetworkRequest
    
    func filterRetrieveMeWithViewContext(fields: [SparseUserFieldWithViewContext])  -> WpNetworkRequest
    
    func filterRetrieveWithEditContext(userId: UserId, fields: [SparseUserFieldWithEditContext])  -> WpNetworkRequest
    
    func filterRetrieveWithEmbedContext(userId: UserId, fields: [SparseUserFieldWithEmbedContext])  -> WpNetworkRequest
    
    func filterRetrieveWithViewContext(userId: UserId, fields: [SparseUserFieldWithViewContext])  -> WpNetworkRequest
    
    func listWithEditContext(params: UserListParams)  -> WpNetworkRequest
    
    func listWithEmbedContext(params: UserListParams)  -> WpNetworkRequest
    
    func listWithViewContext(params: UserListParams)  -> WpNetworkRequest
    
    func retrieveMeWithEditContext()  -> WpNetworkRequest
    
    func retrieveMeWithEmbedContext()  -> WpNetworkRequest
    
    func retrieveMeWithViewContext()  -> WpNetworkRequest
    
    func retrieveWithEditContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveWithEmbedContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveWithViewContext(userId: UserId)  -> WpNetworkRequest
    
    func update(userId: UserId, params: UserUpdateParams)  -> WpNetworkRequest
    
    func updateMe(params: UserUpdateParams)  -> WpNetworkRequest
    
}

open class UsersRequestBuilder:
    UsersRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_usersrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_usersrequestbuilder(pointer, $0) }
    }

    

    
open func create(params: UserCreateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_create(self.uniffiClonePointer(),
        FfiConverterTypeUserCreateParams.lower(params),$0
    )
})
}
    
open func delete(userId: UserId, params: UserDeleteParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_delete(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeUserDeleteParams.lower(params),$0
    )
})
}
    
open func deleteMe(params: UserDeleteParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_delete_me(self.uniffiClonePointer(),
        FfiConverterTypeUserDeleteParams.lower(params),$0
    )
})
}
    
open func filterListWithEditContext(params: UserListParams, fields: [SparseUserFieldWithEditContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_list_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserListParams.lower(params),
        FfiConverterSequenceTypeSparseUserFieldWithEditContext.lower(fields),$0
    )
})
}
    
open func filterListWithEmbedContext(params: UserListParams, fields: [SparseUserFieldWithEmbedContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_list_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserListParams.lower(params),
        FfiConverterSequenceTypeSparseUserFieldWithEmbedContext.lower(fields),$0
    )
})
}
    
open func filterListWithViewContext(params: UserListParams, fields: [SparseUserFieldWithViewContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_list_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserListParams.lower(params),
        FfiConverterSequenceTypeSparseUserFieldWithViewContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveMeWithEditContext(fields: [SparseUserFieldWithEditContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_retrieve_me_with_edit_context(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseUserFieldWithEditContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveMeWithEmbedContext(fields: [SparseUserFieldWithEmbedContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_retrieve_me_with_embed_context(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseUserFieldWithEmbedContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveMeWithViewContext(fields: [SparseUserFieldWithViewContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_retrieve_me_with_view_context(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseUserFieldWithViewContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithEditContext(userId: UserId, fields: [SparseUserFieldWithEditContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterSequenceTypeSparseUserFieldWithEditContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithEmbedContext(userId: UserId, fields: [SparseUserFieldWithEmbedContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterSequenceTypeSparseUserFieldWithEmbedContext.lower(fields),$0
    )
})
}
    
open func filterRetrieveWithViewContext(userId: UserId, fields: [SparseUserFieldWithViewContext]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterSequenceTypeSparseUserFieldWithViewContext.lower(fields),$0
    )
})
}
    
open func listWithEditContext(params: UserListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_list_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserListParams.lower(params),$0
    )
})
}
    
open func listWithEmbedContext(params: UserListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_list_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserListParams.lower(params),$0
    )
})
}
    
open func listWithViewContext(params: UserListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_list_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserListParams.lower(params),$0
    )
})
}
    
open func retrieveMeWithEditContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_me_with_edit_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func retrieveMeWithEmbedContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_me_with_embed_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func retrieveMeWithViewContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_me_with_view_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func retrieveWithEditContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveWithEmbedContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveWithViewContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func update(userId: UserId, params: UserUpdateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_update(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeUserUpdateParams.lower(params),$0
    )
})
}
    
open func updateMe(params: UserUpdateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_update_me(self.uniffiClonePointer(),
        FfiConverterTypeUserUpdateParams.lower(params),$0
    )
})
}
    

}

public struct FfiConverterTypeUsersRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UsersRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UsersRequestBuilder {
        return UsersRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UsersRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UsersRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UsersRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUsersRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> UsersRequestBuilder {
    return try FfiConverterTypeUsersRequestBuilder.lift(pointer)
}

public func FfiConverterTypeUsersRequestBuilder_lower(_ value: UsersRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUsersRequestBuilder.lower(value)
}




public protocol UsersRequestExecutorProtocol : AnyObject {
    
    func create(params: UserCreateParams) async throws  -> UserWithEditContext
    
    func delete(userId: UserId, params: UserDeleteParams) async throws  -> UserDeleteResponse
    
    func deleteMe(params: UserDeleteParams) async throws  -> UserDeleteResponse
    
    func filterListWithEditContext(params: UserListParams, fields: [SparseUserFieldWithEditContext]) async throws  -> [SparseUserWithEditContext]
    
    func filterListWithEmbedContext(params: UserListParams, fields: [SparseUserFieldWithEmbedContext]) async throws  -> [SparseUserWithEmbedContext]
    
    func filterListWithViewContext(params: UserListParams, fields: [SparseUserFieldWithViewContext]) async throws  -> [SparseUserWithViewContext]
    
    func filterRetrieveMeWithEditContext(fields: [SparseUserFieldWithEditContext]) async throws  -> SparseUserWithEditContext
    
    func filterRetrieveMeWithEmbedContext(fields: [SparseUserFieldWithEmbedContext]) async throws  -> SparseUserWithEmbedContext
    
    func filterRetrieveMeWithViewContext(fields: [SparseUserFieldWithViewContext]) async throws  -> SparseUserWithViewContext
    
    func filterRetrieveWithEditContext(userId: UserId, fields: [SparseUserFieldWithEditContext]) async throws  -> SparseUserWithEditContext
    
    func filterRetrieveWithEmbedContext(userId: UserId, fields: [SparseUserFieldWithEmbedContext]) async throws  -> SparseUserWithEmbedContext
    
    func filterRetrieveWithViewContext(userId: UserId, fields: [SparseUserFieldWithViewContext]) async throws  -> SparseUserWithViewContext
    
    func listWithEditContext(params: UserListParams) async throws  -> [UserWithEditContext]
    
    func listWithEmbedContext(params: UserListParams) async throws  -> [UserWithEmbedContext]
    
    func listWithViewContext(params: UserListParams) async throws  -> [UserWithViewContext]
    
    func retrieveMeWithEditContext() async throws  -> UserWithEditContext
    
    func retrieveMeWithEmbedContext() async throws  -> UserWithEmbedContext
    
    func retrieveMeWithViewContext() async throws  -> UserWithViewContext
    
    func retrieveWithEditContext(userId: UserId) async throws  -> UserWithEditContext
    
    func retrieveWithEmbedContext(userId: UserId) async throws  -> UserWithEmbedContext
    
    func retrieveWithViewContext(userId: UserId) async throws  -> UserWithViewContext
    
    func update(userId: UserId, params: UserUpdateParams) async throws  -> UserWithEditContext
    
    func updateMe(params: UserUpdateParams) async throws  -> UserWithEditContext
    
}

open class UsersRequestExecutor:
    UsersRequestExecutorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_usersrequestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_usersrequestexecutor(pointer, $0) }
    }

    

    
open func create(params: UserCreateParams)async throws  -> UserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_create(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserCreateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func delete(userId: UserId, params: UserDeleteParams)async throws  -> UserDeleteResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeUserDeleteParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserDeleteResponse.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func deleteMe(params: UserDeleteParams)async throws  -> UserDeleteResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_delete_me(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserDeleteParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserDeleteResponse.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterListWithEditContext(params: UserListParams, fields: [SparseUserFieldWithEditContext])async throws  -> [SparseUserWithEditContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_list_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserListParams.lower(params),FfiConverterSequenceTypeSparseUserFieldWithEditContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparseUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterListWithEmbedContext(params: UserListParams, fields: [SparseUserFieldWithEmbedContext])async throws  -> [SparseUserWithEmbedContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_list_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserListParams.lower(params),FfiConverterSequenceTypeSparseUserFieldWithEmbedContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparseUserWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterListWithViewContext(params: UserListParams, fields: [SparseUserFieldWithViewContext])async throws  -> [SparseUserWithViewContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_list_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserListParams.lower(params),FfiConverterSequenceTypeSparseUserFieldWithViewContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparseUserWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveMeWithEditContext(fields: [SparseUserFieldWithEditContext])async throws  -> SparseUserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_retrieve_me_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseUserFieldWithEditContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveMeWithEmbedContext(fields: [SparseUserFieldWithEmbedContext])async throws  -> SparseUserWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_retrieve_me_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseUserFieldWithEmbedContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseUserWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveMeWithViewContext(fields: [SparseUserFieldWithViewContext])async throws  -> SparseUserWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_retrieve_me_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseUserFieldWithViewContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseUserWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithEditContext(userId: UserId, fields: [SparseUserFieldWithEditContext])async throws  -> SparseUserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterSequenceTypeSparseUserFieldWithEditContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithEmbedContext(userId: UserId, fields: [SparseUserFieldWithEmbedContext])async throws  -> SparseUserWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterSequenceTypeSparseUserFieldWithEmbedContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseUserWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveWithViewContext(userId: UserId, fields: [SparseUserFieldWithViewContext])async throws  -> SparseUserWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterSequenceTypeSparseUserFieldWithViewContext.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseUserWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEditContext(params: UserListParams)async throws  -> [UserWithEditContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_list_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEmbedContext(params: UserListParams)async throws  -> [UserWithEmbedContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_list_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUserWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithViewContext(params: UserListParams)async throws  -> [UserWithViewContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_list_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUserWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveMeWithEditContext()async throws  -> UserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_me_with_edit_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveMeWithEmbedContext()async throws  -> UserWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_me_with_embed_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveMeWithViewContext()async throws  -> UserWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_me_with_view_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEditContext(userId: UserId)async throws  -> UserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEmbedContext(userId: UserId)async throws  -> UserWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithViewContext(userId: UserId)async throws  -> UserWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func update(userId: UserId, params: UserUpdateParams)async throws  -> UserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_update(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeUserUpdateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func updateMe(params: UserUpdateParams)async throws  -> UserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_update_me(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserUpdateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    

}

public struct FfiConverterTypeUsersRequestExecutor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UsersRequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UsersRequestExecutor {
        return UsersRequestExecutor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UsersRequestExecutor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UsersRequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UsersRequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUsersRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> UsersRequestExecutor {
    return try FfiConverterTypeUsersRequestExecutor.lift(pointer)
}

public func FfiConverterTypeUsersRequestExecutor_lower(_ value: UsersRequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUsersRequestExecutor.lower(value)
}




public protocol WpApiDetailsProtocol : AnyObject {
    
    func findApplicationPasswordsAuthenticationUrl()  -> String?
    
}

open class WpApiDetails:
    WpApiDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_wpapidetails(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_wpapidetails(pointer, $0) }
    }

    

    
open func findApplicationPasswordsAuthenticationUrl() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpapidetails_find_application_passwords_authentication_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeWpApiDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WpApiDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WpApiDetails {
        return WpApiDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WpApiDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WpApiDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWpApiDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> WpApiDetails {
    return try FfiConverterTypeWpApiDetails.lift(pointer)
}

public func FfiConverterTypeWpApiDetails_lower(_ value: WpApiDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWpApiDetails.lower(value)
}




public protocol WpNetworkHeaderMapProtocol : AnyObject {
    
    func toMap()  -> [String: [String]]
    
}

open class WpNetworkHeaderMap:
    WpNetworkHeaderMapProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_wpnetworkheadermap(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_wpnetworkheadermap(pointer, $0) }
    }

    
public static func fromMap(hashMap: [String: String])throws  -> WpNetworkHeaderMap {
    return try  FfiConverterTypeWpNetworkHeaderMap.lift(try rustCallWithError(FfiConverterTypeWpNetworkHeaderMapError.lift) {
    uniffi_wp_api_fn_constructor_wpnetworkheadermap_from_map(
        FfiConverterDictionaryStringString.lower(hashMap),$0
    )
})
}
    
public static func fromMultiMap(hashMap: [String: [String]])throws  -> WpNetworkHeaderMap {
    return try  FfiConverterTypeWpNetworkHeaderMap.lift(try rustCallWithError(FfiConverterTypeWpNetworkHeaderMapError.lift) {
    uniffi_wp_api_fn_constructor_wpnetworkheadermap_from_multi_map(
        FfiConverterDictionaryStringSequenceString.lower(hashMap),$0
    )
})
}
    

    
open func toMap() -> [String: [String]] {
    return try!  FfiConverterDictionaryStringSequenceString.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkheadermap_to_map(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeWpNetworkHeaderMap: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WpNetworkHeaderMap

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkHeaderMap {
        return WpNetworkHeaderMap(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WpNetworkHeaderMap) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpNetworkHeaderMap {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WpNetworkHeaderMap, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWpNetworkHeaderMap_lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkHeaderMap {
    return try FfiConverterTypeWpNetworkHeaderMap.lift(pointer)
}

public func FfiConverterTypeWpNetworkHeaderMap_lower(_ value: WpNetworkHeaderMap) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWpNetworkHeaderMap.lower(value)
}




public protocol WpNetworkRequestProtocol : AnyObject {
    
    func body()  -> WpNetworkRequestBody?
    
    func bodyAsString()  -> String?
    
    func headerMap()  -> WpNetworkHeaderMap
    
    func method()  -> RequestMethod
    
    func url()  -> WpEndpointUrl
    
}

open class WpNetworkRequest:
    WpNetworkRequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_wpnetworkrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_wpnetworkrequest(pointer, $0) }
    }

    

    
open func body() -> WpNetworkRequestBody? {
    return try!  FfiConverterOptionTypeWpNetworkRequestBody.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequest_body(self.uniffiClonePointer(),$0
    )
})
}
    
open func bodyAsString() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequest_body_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func headerMap() -> WpNetworkHeaderMap {
    return try!  FfiConverterTypeWpNetworkHeaderMap.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequest_header_map(self.uniffiClonePointer(),$0
    )
})
}
    
open func method() -> RequestMethod {
    return try!  FfiConverterTypeRequestMethod.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequest_method(self.uniffiClonePointer(),$0
    )
})
}
    
open func url() -> WpEndpointUrl {
    return try!  FfiConverterTypeWpEndpointUrl.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequest_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeWpNetworkRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WpNetworkRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkRequest {
        return WpNetworkRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WpNetworkRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpNetworkRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WpNetworkRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWpNetworkRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkRequest {
    return try FfiConverterTypeWpNetworkRequest.lift(pointer)
}

public func FfiConverterTypeWpNetworkRequest_lower(_ value: WpNetworkRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWpNetworkRequest.lower(value)
}




public protocol WpNetworkRequestBodyProtocol : AnyObject {
    
    func contents()  -> Data
    
}

open class WpNetworkRequestBody:
    WpNetworkRequestBodyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_wpnetworkrequestbody(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_wpnetworkrequestbody(pointer, $0) }
    }

    

    
open func contents() -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequestbody_contents(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeWpNetworkRequestBody: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WpNetworkRequestBody

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkRequestBody {
        return WpNetworkRequestBody(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WpNetworkRequestBody) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpNetworkRequestBody {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WpNetworkRequestBody, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWpNetworkRequestBody_lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkRequestBody {
    return try FfiConverterTypeWpNetworkRequestBody.lift(pointer)
}

public func FfiConverterTypeWpNetworkRequestBody_lower(_ value: WpNetworkRequestBody) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWpNetworkRequestBody.lower(value)
}




public protocol WpSiteHealthTestsRequestBuilderProtocol : AnyObject {
    
    func authorizationHeader()  -> WpNetworkRequest
    
    func backgroundUpdates()  -> WpNetworkRequest
    
    func directorySizes()  -> WpNetworkRequest
    
    func dotorgCommunication()  -> WpNetworkRequest
    
    func filterAuthorizationHeader(fields: [SparseWpSiteHealthTestField])  -> WpNetworkRequest
    
    func filterBackgroundUpdates(fields: [SparseWpSiteHealthTestField])  -> WpNetworkRequest
    
    func filterDirectorySizes(fields: [SparseWpSiteHealthDirectorySizesField])  -> WpNetworkRequest
    
    func filterDotorgCommunication(fields: [SparseWpSiteHealthTestField])  -> WpNetworkRequest
    
    func filterHttpsStatus(fields: [SparseWpSiteHealthTestField])  -> WpNetworkRequest
    
    func filterLoopbackRequests(fields: [SparseWpSiteHealthTestField])  -> WpNetworkRequest
    
    func filterPageCache(fields: [SparseWpSiteHealthTestField])  -> WpNetworkRequest
    
    func httpsStatus()  -> WpNetworkRequest
    
    func loopbackRequests()  -> WpNetworkRequest
    
    func pageCache()  -> WpNetworkRequest
    
}

open class WpSiteHealthTestsRequestBuilder:
    WpSiteHealthTestsRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_wpsitehealthtestsrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_wpsitehealthtestsrequestbuilder(pointer, $0) }
    }

    

    
open func authorizationHeader() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_authorization_header(self.uniffiClonePointer(),$0
    )
})
}
    
open func backgroundUpdates() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_background_updates(self.uniffiClonePointer(),$0
    )
})
}
    
open func directorySizes() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_directory_sizes(self.uniffiClonePointer(),$0
    )
})
}
    
open func dotorgCommunication() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_dotorg_communication(self.uniffiClonePointer(),$0
    )
})
}
    
open func filterAuthorizationHeader(fields: [SparseWpSiteHealthTestField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_filter_authorization_header(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields),$0
    )
})
}
    
open func filterBackgroundUpdates(fields: [SparseWpSiteHealthTestField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_filter_background_updates(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields),$0
    )
})
}
    
open func filterDirectorySizes(fields: [SparseWpSiteHealthDirectorySizesField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_filter_directory_sizes(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseWpSiteHealthDirectorySizesField.lower(fields),$0
    )
})
}
    
open func filterDotorgCommunication(fields: [SparseWpSiteHealthTestField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_filter_dotorg_communication(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields),$0
    )
})
}
    
open func filterHttpsStatus(fields: [SparseWpSiteHealthTestField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_filter_https_status(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields),$0
    )
})
}
    
open func filterLoopbackRequests(fields: [SparseWpSiteHealthTestField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_filter_loopback_requests(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields),$0
    )
})
}
    
open func filterPageCache(fields: [SparseWpSiteHealthTestField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_filter_page_cache(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields),$0
    )
})
}
    
open func httpsStatus() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_https_status(self.uniffiClonePointer(),$0
    )
})
}
    
open func loopbackRequests() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_loopback_requests(self.uniffiClonePointer(),$0
    )
})
}
    
open func pageCache() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpsitehealthtestsrequestbuilder_page_cache(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeWpSiteHealthTestsRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WpSiteHealthTestsRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WpSiteHealthTestsRequestBuilder {
        return WpSiteHealthTestsRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WpSiteHealthTestsRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpSiteHealthTestsRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WpSiteHealthTestsRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWpSiteHealthTestsRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> WpSiteHealthTestsRequestBuilder {
    return try FfiConverterTypeWpSiteHealthTestsRequestBuilder.lift(pointer)
}

public func FfiConverterTypeWpSiteHealthTestsRequestBuilder_lower(_ value: WpSiteHealthTestsRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWpSiteHealthTestsRequestBuilder.lower(value)
}




public protocol WpSiteHealthTestsRequestExecutorProtocol : AnyObject {
    
    func authorizationHeader() async throws  -> WpSiteHealthTest
    
    func backgroundUpdates() async throws  -> WpSiteHealthTest
    
    func directorySizes() async throws  -> WpSiteHealthDirectorySizes
    
    func dotorgCommunication() async throws  -> WpSiteHealthTest
    
    func filterAuthorizationHeader(fields: [SparseWpSiteHealthTestField]) async throws  -> SparseWpSiteHealthTest
    
    func filterBackgroundUpdates(fields: [SparseWpSiteHealthTestField]) async throws  -> SparseWpSiteHealthTest
    
    func filterDirectorySizes(fields: [SparseWpSiteHealthDirectorySizesField]) async throws  -> SparseWpSiteHealthDirectorySizes
    
    func filterDotorgCommunication(fields: [SparseWpSiteHealthTestField]) async throws  -> SparseWpSiteHealthTest
    
    func filterHttpsStatus(fields: [SparseWpSiteHealthTestField]) async throws  -> SparseWpSiteHealthTest
    
    func filterLoopbackRequests(fields: [SparseWpSiteHealthTestField]) async throws  -> SparseWpSiteHealthTest
    
    func filterPageCache(fields: [SparseWpSiteHealthTestField]) async throws  -> SparseWpSiteHealthTest
    
    func httpsStatus() async throws  -> WpSiteHealthTest
    
    func loopbackRequests() async throws  -> WpSiteHealthTest
    
    func pageCache() async throws  -> WpSiteHealthTest
    
}

open class WpSiteHealthTestsRequestExecutor:
    WpSiteHealthTestsRequestExecutorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_wpsitehealthtestsrequestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_wpsitehealthtestsrequestexecutor(pointer, $0) }
    }

    

    
open func authorizationHeader()async throws  -> WpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_authorization_header(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func backgroundUpdates()async throws  -> WpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_background_updates(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func directorySizes()async throws  -> WpSiteHealthDirectorySizes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_directory_sizes(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWpSiteHealthDirectorySizes.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func dotorgCommunication()async throws  -> WpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_dotorg_communication(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterAuthorizationHeader(fields: [SparseWpSiteHealthTestField])async throws  -> SparseWpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_filter_authorization_header(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterBackgroundUpdates(fields: [SparseWpSiteHealthTestField])async throws  -> SparseWpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_filter_background_updates(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterDirectorySizes(fields: [SparseWpSiteHealthDirectorySizesField])async throws  -> SparseWpSiteHealthDirectorySizes {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_filter_directory_sizes(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseWpSiteHealthDirectorySizesField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseWpSiteHealthDirectorySizes.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterDotorgCommunication(fields: [SparseWpSiteHealthTestField])async throws  -> SparseWpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_filter_dotorg_communication(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterHttpsStatus(fields: [SparseWpSiteHealthTestField])async throws  -> SparseWpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_filter_https_status(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterLoopbackRequests(fields: [SparseWpSiteHealthTestField])async throws  -> SparseWpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_filter_loopback_requests(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterPageCache(fields: [SparseWpSiteHealthTestField])async throws  -> SparseWpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_filter_page_cache(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeSparseWpSiteHealthTestField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func httpsStatus()async throws  -> WpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_https_status(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func loopbackRequests()async throws  -> WpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_loopback_requests(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func pageCache()async throws  -> WpSiteHealthTest {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_wpsitehealthtestsrequestexecutor_page_cache(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWpSiteHealthTest.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    

}

public struct FfiConverterTypeWpSiteHealthTestsRequestExecutor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WpSiteHealthTestsRequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WpSiteHealthTestsRequestExecutor {
        return WpSiteHealthTestsRequestExecutor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WpSiteHealthTestsRequestExecutor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpSiteHealthTestsRequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WpSiteHealthTestsRequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWpSiteHealthTestsRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> WpSiteHealthTestsRequestExecutor {
    return try FfiConverterTypeWpSiteHealthTestsRequestExecutor.lift(pointer)
}

public func FfiConverterTypeWpSiteHealthTestsRequestExecutor_lower(_ value: WpSiteHealthTestsRequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWpSiteHealthTestsRequestExecutor.lower(value)
}


public struct ApplicationPasswordAppId {
    public let appId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(appId: String) {
        self.appId = appId
    }
}



extension ApplicationPasswordAppId: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordAppId, rhs: ApplicationPasswordAppId) -> Bool {
        if lhs.appId != rhs.appId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(appId)
    }
}


public struct FfiConverterTypeApplicationPasswordAppId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordAppId {
        return
            try ApplicationPasswordAppId(
                appId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordAppId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.appId, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordAppId_lift(_ buf: RustBuffer) throws -> ApplicationPasswordAppId {
    return try FfiConverterTypeApplicationPasswordAppId.lift(buf)
}

public func FfiConverterTypeApplicationPasswordAppId_lower(_ value: ApplicationPasswordAppId) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordAppId.lower(value)
}


public struct ApplicationPasswordCreateParams {
    /**
     * A UUID provided by the application to uniquely identify it.
     * It is recommended to use an UUID v5 with the URL or DNS namespace.
     */
    public let appId: String?
    /**
     * The name of the application password.
     */
    public let name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A UUID provided by the application to uniquely identify it.
         * It is recommended to use an UUID v5 with the URL or DNS namespace.
         */appId: String?, 
        /**
         * The name of the application password.
         */name: String) {
        self.appId = appId
        self.name = name
    }
}



extension ApplicationPasswordCreateParams: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordCreateParams, rhs: ApplicationPasswordCreateParams) -> Bool {
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(appId)
        hasher.combine(name)
    }
}


public struct FfiConverterTypeApplicationPasswordCreateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordCreateParams {
        return
            try ApplicationPasswordCreateParams(
                appId: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordCreateParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.appId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordCreateParams_lift(_ buf: RustBuffer) throws -> ApplicationPasswordCreateParams {
    return try FfiConverterTypeApplicationPasswordCreateParams.lift(buf)
}

public func FfiConverterTypeApplicationPasswordCreateParams_lower(_ value: ApplicationPasswordCreateParams) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordCreateParams.lower(value)
}


public struct ApplicationPasswordDeleteAllResponse {
    public let deleted: Bool
    public let count: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deleted: Bool, count: Int32) {
        self.deleted = deleted
        self.count = count
    }
}



extension ApplicationPasswordDeleteAllResponse: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordDeleteAllResponse, rhs: ApplicationPasswordDeleteAllResponse) -> Bool {
        if lhs.deleted != rhs.deleted {
            return false
        }
        if lhs.count != rhs.count {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deleted)
        hasher.combine(count)
    }
}


public struct FfiConverterTypeApplicationPasswordDeleteAllResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordDeleteAllResponse {
        return
            try ApplicationPasswordDeleteAllResponse(
                deleted: FfiConverterBool.read(from: &buf), 
                count: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordDeleteAllResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.deleted, into: &buf)
        FfiConverterInt32.write(value.count, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordDeleteAllResponse_lift(_ buf: RustBuffer) throws -> ApplicationPasswordDeleteAllResponse {
    return try FfiConverterTypeApplicationPasswordDeleteAllResponse.lift(buf)
}

public func FfiConverterTypeApplicationPasswordDeleteAllResponse_lower(_ value: ApplicationPasswordDeleteAllResponse) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordDeleteAllResponse.lower(value)
}


public struct ApplicationPasswordDeleteResponse {
    public let deleted: Bool
    public let previous: ApplicationPasswordWithEditContext

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deleted: Bool, previous: ApplicationPasswordWithEditContext) {
        self.deleted = deleted
        self.previous = previous
    }
}



extension ApplicationPasswordDeleteResponse: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordDeleteResponse, rhs: ApplicationPasswordDeleteResponse) -> Bool {
        if lhs.deleted != rhs.deleted {
            return false
        }
        if lhs.previous != rhs.previous {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deleted)
        hasher.combine(previous)
    }
}


public struct FfiConverterTypeApplicationPasswordDeleteResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordDeleteResponse {
        return
            try ApplicationPasswordDeleteResponse(
                deleted: FfiConverterBool.read(from: &buf), 
                previous: FfiConverterTypeApplicationPasswordWithEditContext.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordDeleteResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.deleted, into: &buf)
        FfiConverterTypeApplicationPasswordWithEditContext.write(value.previous, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordDeleteResponse_lift(_ buf: RustBuffer) throws -> ApplicationPasswordDeleteResponse {
    return try FfiConverterTypeApplicationPasswordDeleteResponse.lift(buf)
}

public func FfiConverterTypeApplicationPasswordDeleteResponse_lower(_ value: ApplicationPasswordDeleteResponse) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordDeleteResponse.lower(value)
}


public struct ApplicationPasswordUpdateParams {
    /**
     * A UUID provided by the application to uniquely identify it.
     * It is recommended to use an UUID v5 with the URL or DNS namespace.
     */
    public let appId: String?
    /**
     * The name of the application password.
     */
    public let name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A UUID provided by the application to uniquely identify it.
         * It is recommended to use an UUID v5 with the URL or DNS namespace.
         */appId: String?, 
        /**
         * The name of the application password.
         */name: String) {
        self.appId = appId
        self.name = name
    }
}



extension ApplicationPasswordUpdateParams: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordUpdateParams, rhs: ApplicationPasswordUpdateParams) -> Bool {
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(appId)
        hasher.combine(name)
    }
}


public struct FfiConverterTypeApplicationPasswordUpdateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordUpdateParams {
        return
            try ApplicationPasswordUpdateParams(
                appId: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordUpdateParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.appId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordUpdateParams_lift(_ buf: RustBuffer) throws -> ApplicationPasswordUpdateParams {
    return try FfiConverterTypeApplicationPasswordUpdateParams.lift(buf)
}

public func FfiConverterTypeApplicationPasswordUpdateParams_lower(_ value: ApplicationPasswordUpdateParams) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordUpdateParams.lower(value)
}


public struct ApplicationPasswordUuid {
    public let uuid: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: String) {
        self.uuid = uuid
    }
}



extension ApplicationPasswordUuid: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordUuid, rhs: ApplicationPasswordUuid) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
    }
}


public struct FfiConverterTypeApplicationPasswordUuid: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordUuid {
        return
            try ApplicationPasswordUuid(
                uuid: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordUuid, into buf: inout [UInt8]) {
        FfiConverterString.write(value.uuid, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordUuid_lift(_ buf: RustBuffer) throws -> ApplicationPasswordUuid {
    return try FfiConverterTypeApplicationPasswordUuid.lift(buf)
}

public func FfiConverterTypeApplicationPasswordUuid_lower(_ value: ApplicationPasswordUuid) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordUuid.lower(value)
}


public struct ApplicationPasswordWithEditContext {
    public let uuid: ApplicationPasswordUuid
    public let appId: ApplicationPasswordAppId
    public let name: String
    public let created: String
    public let lastUsed: String?
    public let lastIp: IpAddress?
    public let password: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid, appId: ApplicationPasswordAppId, name: String, created: String, lastUsed: String?, lastIp: IpAddress?, password: String?) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
        self.created = created
        self.lastUsed = lastUsed
        self.lastIp = lastIp
        self.password = password
    }
}



extension ApplicationPasswordWithEditContext: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordWithEditContext, rhs: ApplicationPasswordWithEditContext) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        if lhs.lastUsed != rhs.lastUsed {
            return false
        }
        if lhs.lastIp != rhs.lastIp {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
        hasher.combine(created)
        hasher.combine(lastUsed)
        hasher.combine(lastIp)
        hasher.combine(password)
    }
}


public struct FfiConverterTypeApplicationPasswordWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordWithEditContext {
        return
            try ApplicationPasswordWithEditContext(
                uuid: FfiConverterTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                created: FfiConverterString.read(from: &buf), 
                lastUsed: FfiConverterOptionString.read(from: &buf), 
                lastIp: FfiConverterOptionTypeIpAddress.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordWithEditContext, into buf: inout [UInt8]) {
        FfiConverterTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.created, into: &buf)
        FfiConverterOptionString.write(value.lastUsed, into: &buf)
        FfiConverterOptionTypeIpAddress.write(value.lastIp, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordWithEditContext_lift(_ buf: RustBuffer) throws -> ApplicationPasswordWithEditContext {
    return try FfiConverterTypeApplicationPasswordWithEditContext.lift(buf)
}

public func FfiConverterTypeApplicationPasswordWithEditContext_lower(_ value: ApplicationPasswordWithEditContext) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordWithEditContext.lower(value)
}


public struct ApplicationPasswordWithEmbedContext {
    public let uuid: ApplicationPasswordUuid
    public let appId: ApplicationPasswordAppId
    public let name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid, appId: ApplicationPasswordAppId, name: String) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
    }
}



extension ApplicationPasswordWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordWithEmbedContext, rhs: ApplicationPasswordWithEmbedContext) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
    }
}


public struct FfiConverterTypeApplicationPasswordWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordWithEmbedContext {
        return
            try ApplicationPasswordWithEmbedContext(
                uuid: FfiConverterTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordWithEmbedContext_lift(_ buf: RustBuffer) throws -> ApplicationPasswordWithEmbedContext {
    return try FfiConverterTypeApplicationPasswordWithEmbedContext.lift(buf)
}

public func FfiConverterTypeApplicationPasswordWithEmbedContext_lower(_ value: ApplicationPasswordWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordWithEmbedContext.lower(value)
}


public struct ApplicationPasswordWithViewContext {
    public let uuid: ApplicationPasswordUuid
    public let appId: ApplicationPasswordAppId
    public let name: String
    public let created: String
    public let lastUsed: String?
    public let lastIp: IpAddress?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid, appId: ApplicationPasswordAppId, name: String, created: String, lastUsed: String?, lastIp: IpAddress?) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
        self.created = created
        self.lastUsed = lastUsed
        self.lastIp = lastIp
    }
}



extension ApplicationPasswordWithViewContext: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordWithViewContext, rhs: ApplicationPasswordWithViewContext) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        if lhs.lastUsed != rhs.lastUsed {
            return false
        }
        if lhs.lastIp != rhs.lastIp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
        hasher.combine(created)
        hasher.combine(lastUsed)
        hasher.combine(lastIp)
    }
}


public struct FfiConverterTypeApplicationPasswordWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordWithViewContext {
        return
            try ApplicationPasswordWithViewContext(
                uuid: FfiConverterTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                created: FfiConverterString.read(from: &buf), 
                lastUsed: FfiConverterOptionString.read(from: &buf), 
                lastIp: FfiConverterOptionTypeIpAddress.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordWithViewContext, into buf: inout [UInt8]) {
        FfiConverterTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.created, into: &buf)
        FfiConverterOptionString.write(value.lastUsed, into: &buf)
        FfiConverterOptionTypeIpAddress.write(value.lastIp, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordWithViewContext_lift(_ buf: RustBuffer) throws -> ApplicationPasswordWithViewContext {
    return try FfiConverterTypeApplicationPasswordWithViewContext.lift(buf)
}

public func FfiConverterTypeApplicationPasswordWithViewContext_lower(_ value: ApplicationPasswordWithViewContext) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordWithViewContext.lower(value)
}


public struct IpAddress {
    public let value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: String) {
        self.value = value
    }
}



extension IpAddress: Equatable, Hashable {
    public static func ==(lhs: IpAddress, rhs: IpAddress) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeIpAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IpAddress {
        return
            try IpAddress(
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: IpAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeIpAddress_lift(_ buf: RustBuffer) throws -> IpAddress {
    return try FfiConverterTypeIpAddress.lift(buf)
}

public func FfiConverterTypeIpAddress_lower(_ value: IpAddress) -> RustBuffer {
    return FfiConverterTypeIpAddress.lower(value)
}


public struct PluginCreateParams {
    /**
     * WordPress.org plugin directory slug.
     */
    public let slug: PluginWpOrgDirectorySlug
    /**
     * The plugin activation status.
     */
    public let status: PluginStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * WordPress.org plugin directory slug.
         */slug: PluginWpOrgDirectorySlug, 
        /**
         * The plugin activation status.
         */status: PluginStatus) {
        self.slug = slug
        self.status = status
    }
}



extension PluginCreateParams: Equatable, Hashable {
    public static func ==(lhs: PluginCreateParams, rhs: PluginCreateParams) -> Bool {
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(slug)
        hasher.combine(status)
    }
}


public struct FfiConverterTypePluginCreateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginCreateParams {
        return
            try PluginCreateParams(
                slug: FfiConverterTypePluginWpOrgDirectorySlug.read(from: &buf), 
                status: FfiConverterTypePluginStatus.read(from: &buf)
        )
    }

    public static func write(_ value: PluginCreateParams, into buf: inout [UInt8]) {
        FfiConverterTypePluginWpOrgDirectorySlug.write(value.slug, into: &buf)
        FfiConverterTypePluginStatus.write(value.status, into: &buf)
    }
}


public func FfiConverterTypePluginCreateParams_lift(_ buf: RustBuffer) throws -> PluginCreateParams {
    return try FfiConverterTypePluginCreateParams.lift(buf)
}

public func FfiConverterTypePluginCreateParams_lower(_ value: PluginCreateParams) -> RustBuffer {
    return FfiConverterTypePluginCreateParams.lower(value)
}


public struct PluginDeleteResponse {
    public let deleted: Bool
    public let previous: PluginWithEditContext

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deleted: Bool, previous: PluginWithEditContext) {
        self.deleted = deleted
        self.previous = previous
    }
}



extension PluginDeleteResponse: Equatable, Hashable {
    public static func ==(lhs: PluginDeleteResponse, rhs: PluginDeleteResponse) -> Bool {
        if lhs.deleted != rhs.deleted {
            return false
        }
        if lhs.previous != rhs.previous {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deleted)
        hasher.combine(previous)
    }
}


public struct FfiConverterTypePluginDeleteResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginDeleteResponse {
        return
            try PluginDeleteResponse(
                deleted: FfiConverterBool.read(from: &buf), 
                previous: FfiConverterTypePluginWithEditContext.read(from: &buf)
        )
    }

    public static func write(_ value: PluginDeleteResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.deleted, into: &buf)
        FfiConverterTypePluginWithEditContext.write(value.previous, into: &buf)
    }
}


public func FfiConverterTypePluginDeleteResponse_lift(_ buf: RustBuffer) throws -> PluginDeleteResponse {
    return try FfiConverterTypePluginDeleteResponse.lift(buf)
}

public func FfiConverterTypePluginDeleteResponse_lower(_ value: PluginDeleteResponse) -> RustBuffer {
    return FfiConverterTypePluginDeleteResponse.lower(value)
}


public struct PluginDescription {
    public let raw: String
    public let rendered: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(raw: String, rendered: String) {
        self.raw = raw
        self.rendered = rendered
    }
}



extension PluginDescription: Equatable, Hashable {
    public static func ==(lhs: PluginDescription, rhs: PluginDescription) -> Bool {
        if lhs.raw != rhs.raw {
            return false
        }
        if lhs.rendered != rhs.rendered {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(raw)
        hasher.combine(rendered)
    }
}


public struct FfiConverterTypePluginDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginDescription {
        return
            try PluginDescription(
                raw: FfiConverterString.read(from: &buf), 
                rendered: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginDescription, into buf: inout [UInt8]) {
        FfiConverterString.write(value.raw, into: &buf)
        FfiConverterString.write(value.rendered, into: &buf)
    }
}


public func FfiConverterTypePluginDescription_lift(_ buf: RustBuffer) throws -> PluginDescription {
    return try FfiConverterTypePluginDescription.lift(buf)
}

public func FfiConverterTypePluginDescription_lower(_ value: PluginDescription) -> RustBuffer {
    return FfiConverterTypePluginDescription.lower(value)
}


public struct PluginListParams {
    /**
     * Limit results to those matching a string.
     */
    public let search: String?
    /**
     * Limits results to plugins with the given status.
     */
    public let status: PluginStatus?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Limit results to those matching a string.
         */search: String? = nil, 
        /**
         * Limits results to plugins with the given status.
         */status: PluginStatus? = nil) {
        self.search = search
        self.status = status
    }
}



extension PluginListParams: Equatable, Hashable {
    public static func ==(lhs: PluginListParams, rhs: PluginListParams) -> Bool {
        if lhs.search != rhs.search {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(search)
        hasher.combine(status)
    }
}


public struct FfiConverterTypePluginListParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginListParams {
        return
            try PluginListParams(
                search: FfiConverterOptionString.read(from: &buf), 
                status: FfiConverterOptionTypePluginStatus.read(from: &buf)
        )
    }

    public static func write(_ value: PluginListParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.search, into: &buf)
        FfiConverterOptionTypePluginStatus.write(value.status, into: &buf)
    }
}


public func FfiConverterTypePluginListParams_lift(_ buf: RustBuffer) throws -> PluginListParams {
    return try FfiConverterTypePluginListParams.lift(buf)
}

public func FfiConverterTypePluginListParams_lower(_ value: PluginListParams) -> RustBuffer {
    return FfiConverterTypePluginListParams.lower(value)
}


public struct PluginSlug {
    public let slug: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(slug: String) {
        self.slug = slug
    }
}



extension PluginSlug: Equatable, Hashable {
    public static func ==(lhs: PluginSlug, rhs: PluginSlug) -> Bool {
        if lhs.slug != rhs.slug {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(slug)
    }
}


public struct FfiConverterTypePluginSlug: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginSlug {
        return
            try PluginSlug(
                slug: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginSlug, into buf: inout [UInt8]) {
        FfiConverterString.write(value.slug, into: &buf)
    }
}


public func FfiConverterTypePluginSlug_lift(_ buf: RustBuffer) throws -> PluginSlug {
    return try FfiConverterTypePluginSlug.lift(buf)
}

public func FfiConverterTypePluginSlug_lower(_ value: PluginSlug) -> RustBuffer {
    return FfiConverterTypePluginSlug.lower(value)
}


public struct PluginUpdateParams {
    /**
     * The plugin activation status.
     */
    public let status: PluginStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The plugin activation status.
         */status: PluginStatus) {
        self.status = status
    }
}



extension PluginUpdateParams: Equatable, Hashable {
    public static func ==(lhs: PluginUpdateParams, rhs: PluginUpdateParams) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
    }
}


public struct FfiConverterTypePluginUpdateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginUpdateParams {
        return
            try PluginUpdateParams(
                status: FfiConverterTypePluginStatus.read(from: &buf)
        )
    }

    public static func write(_ value: PluginUpdateParams, into buf: inout [UInt8]) {
        FfiConverterTypePluginStatus.write(value.status, into: &buf)
    }
}


public func FfiConverterTypePluginUpdateParams_lift(_ buf: RustBuffer) throws -> PluginUpdateParams {
    return try FfiConverterTypePluginUpdateParams.lift(buf)
}

public func FfiConverterTypePluginUpdateParams_lower(_ value: PluginUpdateParams) -> RustBuffer {
    return FfiConverterTypePluginUpdateParams.lower(value)
}


public struct PluginWithEditContext {
    public let plugin: PluginSlug
    public let status: PluginStatus
    public let name: String
    public let pluginUri: String
    public let author: String
    public let authorUri: String
    public let description: PluginDescription
    public let version: String
    public let networkOnly: Bool
    public let requiresWp: String
    public let requiresPhp: String
    public let textdomain: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug, status: PluginStatus, name: String, pluginUri: String, author: String, authorUri: String, description: PluginDescription, version: String, networkOnly: Bool, requiresWp: String, requiresPhp: String, textdomain: String) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.pluginUri = pluginUri
        self.author = author
        self.authorUri = authorUri
        self.description = description
        self.version = version
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
        self.textdomain = textdomain
    }
}



extension PluginWithEditContext: Equatable, Hashable {
    public static func ==(lhs: PluginWithEditContext, rhs: PluginWithEditContext) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pluginUri != rhs.pluginUri {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.authorUri != rhs.authorUri {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        if lhs.textdomain != rhs.textdomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(pluginUri)
        hasher.combine(author)
        hasher.combine(authorUri)
        hasher.combine(description)
        hasher.combine(version)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
        hasher.combine(textdomain)
    }
}


public struct FfiConverterTypePluginWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginWithEditContext {
        return
            try PluginWithEditContext(
                plugin: FfiConverterTypePluginSlug.read(from: &buf), 
                status: FfiConverterTypePluginStatus.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                pluginUri: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                authorUri: FfiConverterString.read(from: &buf), 
                description: FfiConverterTypePluginDescription.read(from: &buf), 
                version: FfiConverterString.read(from: &buf), 
                networkOnly: FfiConverterBool.read(from: &buf), 
                requiresWp: FfiConverterString.read(from: &buf), 
                requiresPhp: FfiConverterString.read(from: &buf), 
                textdomain: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginWithEditContext, into buf: inout [UInt8]) {
        FfiConverterTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterTypePluginStatus.write(value.status, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.pluginUri, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterString.write(value.authorUri, into: &buf)
        FfiConverterTypePluginDescription.write(value.description, into: &buf)
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterBool.write(value.networkOnly, into: &buf)
        FfiConverterString.write(value.requiresWp, into: &buf)
        FfiConverterString.write(value.requiresPhp, into: &buf)
        FfiConverterString.write(value.textdomain, into: &buf)
    }
}


public func FfiConverterTypePluginWithEditContext_lift(_ buf: RustBuffer) throws -> PluginWithEditContext {
    return try FfiConverterTypePluginWithEditContext.lift(buf)
}

public func FfiConverterTypePluginWithEditContext_lower(_ value: PluginWithEditContext) -> RustBuffer {
    return FfiConverterTypePluginWithEditContext.lower(value)
}


public struct PluginWithEmbedContext {
    public let plugin: PluginSlug
    public let status: PluginStatus
    public let name: String
    public let networkOnly: Bool
    public let requiresWp: String
    public let requiresPhp: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug, status: PluginStatus, name: String, networkOnly: Bool, requiresWp: String, requiresPhp: String) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
    }
}



extension PluginWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: PluginWithEmbedContext, rhs: PluginWithEmbedContext) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
    }
}


public struct FfiConverterTypePluginWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginWithEmbedContext {
        return
            try PluginWithEmbedContext(
                plugin: FfiConverterTypePluginSlug.read(from: &buf), 
                status: FfiConverterTypePluginStatus.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                networkOnly: FfiConverterBool.read(from: &buf), 
                requiresWp: FfiConverterString.read(from: &buf), 
                requiresPhp: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterTypePluginStatus.write(value.status, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterBool.write(value.networkOnly, into: &buf)
        FfiConverterString.write(value.requiresWp, into: &buf)
        FfiConverterString.write(value.requiresPhp, into: &buf)
    }
}


public func FfiConverterTypePluginWithEmbedContext_lift(_ buf: RustBuffer) throws -> PluginWithEmbedContext {
    return try FfiConverterTypePluginWithEmbedContext.lift(buf)
}

public func FfiConverterTypePluginWithEmbedContext_lower(_ value: PluginWithEmbedContext) -> RustBuffer {
    return FfiConverterTypePluginWithEmbedContext.lower(value)
}


public struct PluginWithViewContext {
    public let plugin: PluginSlug
    public let status: PluginStatus
    public let name: String
    public let pluginUri: String
    public let author: String
    public let authorUri: String
    public let description: PluginDescription
    public let version: String
    public let networkOnly: Bool
    public let requiresWp: String
    public let requiresPhp: String
    public let textdomain: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug, status: PluginStatus, name: String, pluginUri: String, author: String, authorUri: String, description: PluginDescription, version: String, networkOnly: Bool, requiresWp: String, requiresPhp: String, textdomain: String) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.pluginUri = pluginUri
        self.author = author
        self.authorUri = authorUri
        self.description = description
        self.version = version
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
        self.textdomain = textdomain
    }
}



extension PluginWithViewContext: Equatable, Hashable {
    public static func ==(lhs: PluginWithViewContext, rhs: PluginWithViewContext) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pluginUri != rhs.pluginUri {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.authorUri != rhs.authorUri {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        if lhs.textdomain != rhs.textdomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(pluginUri)
        hasher.combine(author)
        hasher.combine(authorUri)
        hasher.combine(description)
        hasher.combine(version)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
        hasher.combine(textdomain)
    }
}


public struct FfiConverterTypePluginWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginWithViewContext {
        return
            try PluginWithViewContext(
                plugin: FfiConverterTypePluginSlug.read(from: &buf), 
                status: FfiConverterTypePluginStatus.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                pluginUri: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                authorUri: FfiConverterString.read(from: &buf), 
                description: FfiConverterTypePluginDescription.read(from: &buf), 
                version: FfiConverterString.read(from: &buf), 
                networkOnly: FfiConverterBool.read(from: &buf), 
                requiresWp: FfiConverterString.read(from: &buf), 
                requiresPhp: FfiConverterString.read(from: &buf), 
                textdomain: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginWithViewContext, into buf: inout [UInt8]) {
        FfiConverterTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterTypePluginStatus.write(value.status, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.pluginUri, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterString.write(value.authorUri, into: &buf)
        FfiConverterTypePluginDescription.write(value.description, into: &buf)
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterBool.write(value.networkOnly, into: &buf)
        FfiConverterString.write(value.requiresWp, into: &buf)
        FfiConverterString.write(value.requiresPhp, into: &buf)
        FfiConverterString.write(value.textdomain, into: &buf)
    }
}


public func FfiConverterTypePluginWithViewContext_lift(_ buf: RustBuffer) throws -> PluginWithViewContext {
    return try FfiConverterTypePluginWithViewContext.lift(buf)
}

public func FfiConverterTypePluginWithViewContext_lower(_ value: PluginWithViewContext) -> RustBuffer {
    return FfiConverterTypePluginWithViewContext.lower(value)
}


public struct PluginWpOrgDirectorySlug {
    public let slug: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(slug: String) {
        self.slug = slug
    }
}



extension PluginWpOrgDirectorySlug: Equatable, Hashable {
    public static func ==(lhs: PluginWpOrgDirectorySlug, rhs: PluginWpOrgDirectorySlug) -> Bool {
        if lhs.slug != rhs.slug {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(slug)
    }
}


public struct FfiConverterTypePluginWpOrgDirectorySlug: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginWpOrgDirectorySlug {
        return
            try PluginWpOrgDirectorySlug(
                slug: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginWpOrgDirectorySlug, into buf: inout [UInt8]) {
        FfiConverterString.write(value.slug, into: &buf)
    }
}


public func FfiConverterTypePluginWpOrgDirectorySlug_lift(_ buf: RustBuffer) throws -> PluginWpOrgDirectorySlug {
    return try FfiConverterTypePluginWpOrgDirectorySlug.lift(buf)
}

public func FfiConverterTypePluginWpOrgDirectorySlug_lower(_ value: PluginWpOrgDirectorySlug) -> RustBuffer {
    return FfiConverterTypePluginWpOrgDirectorySlug.lower(value)
}


public struct PostTypeDetailsWithEditContext {
    public let capabilities: [PostTypeCapabilities: String]
    public let description: String
    public let hierarchical: Bool
    public let viewable: Bool
    public let labels: PostTypeLabels
    public let name: String
    public let slug: String
    public let supports: [PostTypeSupports: Bool]
    public let hasArchive: Bool
    public let taxonomies: [String]
    public let restBase: String
    public let restNamespace: String
    public let visibility: PostTypeVisibility
    public let icon: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(capabilities: [PostTypeCapabilities: String], description: String, hierarchical: Bool, viewable: Bool, labels: PostTypeLabels, name: String, slug: String, supports: [PostTypeSupports: Bool], hasArchive: Bool, taxonomies: [String], restBase: String, restNamespace: String, visibility: PostTypeVisibility, icon: String?) {
        self.capabilities = capabilities
        self.description = description
        self.hierarchical = hierarchical
        self.viewable = viewable
        self.labels = labels
        self.name = name
        self.slug = slug
        self.supports = supports
        self.hasArchive = hasArchive
        self.taxonomies = taxonomies
        self.restBase = restBase
        self.restNamespace = restNamespace
        self.visibility = visibility
        self.icon = icon
    }
}



extension PostTypeDetailsWithEditContext: Equatable, Hashable {
    public static func ==(lhs: PostTypeDetailsWithEditContext, rhs: PostTypeDetailsWithEditContext) -> Bool {
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.hierarchical != rhs.hierarchical {
            return false
        }
        if lhs.viewable != rhs.viewable {
            return false
        }
        if lhs.labels != rhs.labels {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.supports != rhs.supports {
            return false
        }
        if lhs.hasArchive != rhs.hasArchive {
            return false
        }
        if lhs.taxonomies != rhs.taxonomies {
            return false
        }
        if lhs.restBase != rhs.restBase {
            return false
        }
        if lhs.restNamespace != rhs.restNamespace {
            return false
        }
        if lhs.visibility != rhs.visibility {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(capabilities)
        hasher.combine(description)
        hasher.combine(hierarchical)
        hasher.combine(viewable)
        hasher.combine(labels)
        hasher.combine(name)
        hasher.combine(slug)
        hasher.combine(supports)
        hasher.combine(hasArchive)
        hasher.combine(taxonomies)
        hasher.combine(restBase)
        hasher.combine(restNamespace)
        hasher.combine(visibility)
        hasher.combine(icon)
    }
}


public struct FfiConverterTypePostTypeDetailsWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypeDetailsWithEditContext {
        return
            try PostTypeDetailsWithEditContext(
                capabilities: FfiConverterDictionaryTypePostTypeCapabilitiesString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                hierarchical: FfiConverterBool.read(from: &buf), 
                viewable: FfiConverterBool.read(from: &buf), 
                labels: FfiConverterTypePostTypeLabels.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                slug: FfiConverterString.read(from: &buf), 
                supports: FfiConverterDictionaryTypePostTypeSupportsBool.read(from: &buf), 
                hasArchive: FfiConverterBool.read(from: &buf), 
                taxonomies: FfiConverterSequenceString.read(from: &buf), 
                restBase: FfiConverterString.read(from: &buf), 
                restNamespace: FfiConverterString.read(from: &buf), 
                visibility: FfiConverterTypePostTypeVisibility.read(from: &buf), 
                icon: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PostTypeDetailsWithEditContext, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypePostTypeCapabilitiesString.write(value.capabilities, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterBool.write(value.hierarchical, into: &buf)
        FfiConverterBool.write(value.viewable, into: &buf)
        FfiConverterTypePostTypeLabels.write(value.labels, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.slug, into: &buf)
        FfiConverterDictionaryTypePostTypeSupportsBool.write(value.supports, into: &buf)
        FfiConverterBool.write(value.hasArchive, into: &buf)
        FfiConverterSequenceString.write(value.taxonomies, into: &buf)
        FfiConverterString.write(value.restBase, into: &buf)
        FfiConverterString.write(value.restNamespace, into: &buf)
        FfiConverterTypePostTypeVisibility.write(value.visibility, into: &buf)
        FfiConverterOptionString.write(value.icon, into: &buf)
    }
}


public func FfiConverterTypePostTypeDetailsWithEditContext_lift(_ buf: RustBuffer) throws -> PostTypeDetailsWithEditContext {
    return try FfiConverterTypePostTypeDetailsWithEditContext.lift(buf)
}

public func FfiConverterTypePostTypeDetailsWithEditContext_lower(_ value: PostTypeDetailsWithEditContext) -> RustBuffer {
    return FfiConverterTypePostTypeDetailsWithEditContext.lower(value)
}


public struct PostTypeDetailsWithEmbedContext {
    public let name: String
    public let slug: String
    public let restBase: String
    public let restNamespace: String
    public let icon: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, slug: String, restBase: String, restNamespace: String, icon: String?) {
        self.name = name
        self.slug = slug
        self.restBase = restBase
        self.restNamespace = restNamespace
        self.icon = icon
    }
}



extension PostTypeDetailsWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: PostTypeDetailsWithEmbedContext, rhs: PostTypeDetailsWithEmbedContext) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.restBase != rhs.restBase {
            return false
        }
        if lhs.restNamespace != rhs.restNamespace {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(slug)
        hasher.combine(restBase)
        hasher.combine(restNamespace)
        hasher.combine(icon)
    }
}


public struct FfiConverterTypePostTypeDetailsWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypeDetailsWithEmbedContext {
        return
            try PostTypeDetailsWithEmbedContext(
                name: FfiConverterString.read(from: &buf), 
                slug: FfiConverterString.read(from: &buf), 
                restBase: FfiConverterString.read(from: &buf), 
                restNamespace: FfiConverterString.read(from: &buf), 
                icon: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PostTypeDetailsWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.slug, into: &buf)
        FfiConverterString.write(value.restBase, into: &buf)
        FfiConverterString.write(value.restNamespace, into: &buf)
        FfiConverterOptionString.write(value.icon, into: &buf)
    }
}


public func FfiConverterTypePostTypeDetailsWithEmbedContext_lift(_ buf: RustBuffer) throws -> PostTypeDetailsWithEmbedContext {
    return try FfiConverterTypePostTypeDetailsWithEmbedContext.lift(buf)
}

public func FfiConverterTypePostTypeDetailsWithEmbedContext_lower(_ value: PostTypeDetailsWithEmbedContext) -> RustBuffer {
    return FfiConverterTypePostTypeDetailsWithEmbedContext.lower(value)
}


public struct PostTypeDetailsWithViewContext {
    public let description: String
    public let hierarchical: Bool
    public let name: String
    public let slug: String
    public let hasArchive: Bool
    public let taxonomies: [String]
    public let restBase: String
    public let restNamespace: String
    public let icon: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(description: String, hierarchical: Bool, name: String, slug: String, hasArchive: Bool, taxonomies: [String], restBase: String, restNamespace: String, icon: String?) {
        self.description = description
        self.hierarchical = hierarchical
        self.name = name
        self.slug = slug
        self.hasArchive = hasArchive
        self.taxonomies = taxonomies
        self.restBase = restBase
        self.restNamespace = restNamespace
        self.icon = icon
    }
}



extension PostTypeDetailsWithViewContext: Equatable, Hashable {
    public static func ==(lhs: PostTypeDetailsWithViewContext, rhs: PostTypeDetailsWithViewContext) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.hierarchical != rhs.hierarchical {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.hasArchive != rhs.hasArchive {
            return false
        }
        if lhs.taxonomies != rhs.taxonomies {
            return false
        }
        if lhs.restBase != rhs.restBase {
            return false
        }
        if lhs.restNamespace != rhs.restNamespace {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(hierarchical)
        hasher.combine(name)
        hasher.combine(slug)
        hasher.combine(hasArchive)
        hasher.combine(taxonomies)
        hasher.combine(restBase)
        hasher.combine(restNamespace)
        hasher.combine(icon)
    }
}


public struct FfiConverterTypePostTypeDetailsWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypeDetailsWithViewContext {
        return
            try PostTypeDetailsWithViewContext(
                description: FfiConverterString.read(from: &buf), 
                hierarchical: FfiConverterBool.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                slug: FfiConverterString.read(from: &buf), 
                hasArchive: FfiConverterBool.read(from: &buf), 
                taxonomies: FfiConverterSequenceString.read(from: &buf), 
                restBase: FfiConverterString.read(from: &buf), 
                restNamespace: FfiConverterString.read(from: &buf), 
                icon: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PostTypeDetailsWithViewContext, into buf: inout [UInt8]) {
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterBool.write(value.hierarchical, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.slug, into: &buf)
        FfiConverterBool.write(value.hasArchive, into: &buf)
        FfiConverterSequenceString.write(value.taxonomies, into: &buf)
        FfiConverterString.write(value.restBase, into: &buf)
        FfiConverterString.write(value.restNamespace, into: &buf)
        FfiConverterOptionString.write(value.icon, into: &buf)
    }
}


public func FfiConverterTypePostTypeDetailsWithViewContext_lift(_ buf: RustBuffer) throws -> PostTypeDetailsWithViewContext {
    return try FfiConverterTypePostTypeDetailsWithViewContext.lift(buf)
}

public func FfiConverterTypePostTypeDetailsWithViewContext_lower(_ value: PostTypeDetailsWithViewContext) -> RustBuffer {
    return FfiConverterTypePostTypeDetailsWithViewContext.lower(value)
}


public struct PostTypeLabels {
    public let name: String
    public let singularName: String
    public let addNew: String
    public let addNewItem: String
    public let editItem: String
    public let newItem: String
    public let viewItem: String
    public let viewItems: String
    public let searchItems: String
    public let notFound: String
    public let notFoundInTrash: String
    public let parentItemColon: String?
    public let allItems: String
    public let archives: String
    public let attributes: String
    public let insertIntoItem: String
    public let uploadedToThisItem: String
    public let featuredImage: String
    public let setFeaturedImage: String
    public let removeFeaturedImage: String
    public let useFeaturedImage: String
    public let filterItemsList: String
    public let filterByDate: String
    public let itemsListNavigation: String
    public let itemsList: String
    public let itemPublished: String
    public let itemPublishedPrivately: String
    public let itemRevertedToDraft: String
    public let itemTrashed: String
    public let itemScheduled: String
    public let itemUpdated: String
    public let itemLink: String
    public let itemLinkDescription: String
    public let menuName: String
    public let nameAdminBar: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, singularName: String, addNew: String, addNewItem: String, editItem: String, newItem: String, viewItem: String, viewItems: String, searchItems: String, notFound: String, notFoundInTrash: String, parentItemColon: String?, allItems: String, archives: String, attributes: String, insertIntoItem: String, uploadedToThisItem: String, featuredImage: String, setFeaturedImage: String, removeFeaturedImage: String, useFeaturedImage: String, filterItemsList: String, filterByDate: String, itemsListNavigation: String, itemsList: String, itemPublished: String, itemPublishedPrivately: String, itemRevertedToDraft: String, itemTrashed: String, itemScheduled: String, itemUpdated: String, itemLink: String, itemLinkDescription: String, menuName: String, nameAdminBar: String) {
        self.name = name
        self.singularName = singularName
        self.addNew = addNew
        self.addNewItem = addNewItem
        self.editItem = editItem
        self.newItem = newItem
        self.viewItem = viewItem
        self.viewItems = viewItems
        self.searchItems = searchItems
        self.notFound = notFound
        self.notFoundInTrash = notFoundInTrash
        self.parentItemColon = parentItemColon
        self.allItems = allItems
        self.archives = archives
        self.attributes = attributes
        self.insertIntoItem = insertIntoItem
        self.uploadedToThisItem = uploadedToThisItem
        self.featuredImage = featuredImage
        self.setFeaturedImage = setFeaturedImage
        self.removeFeaturedImage = removeFeaturedImage
        self.useFeaturedImage = useFeaturedImage
        self.filterItemsList = filterItemsList
        self.filterByDate = filterByDate
        self.itemsListNavigation = itemsListNavigation
        self.itemsList = itemsList
        self.itemPublished = itemPublished
        self.itemPublishedPrivately = itemPublishedPrivately
        self.itemRevertedToDraft = itemRevertedToDraft
        self.itemTrashed = itemTrashed
        self.itemScheduled = itemScheduled
        self.itemUpdated = itemUpdated
        self.itemLink = itemLink
        self.itemLinkDescription = itemLinkDescription
        self.menuName = menuName
        self.nameAdminBar = nameAdminBar
    }
}



extension PostTypeLabels: Equatable, Hashable {
    public static func ==(lhs: PostTypeLabels, rhs: PostTypeLabels) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.singularName != rhs.singularName {
            return false
        }
        if lhs.addNew != rhs.addNew {
            return false
        }
        if lhs.addNewItem != rhs.addNewItem {
            return false
        }
        if lhs.editItem != rhs.editItem {
            return false
        }
        if lhs.newItem != rhs.newItem {
            return false
        }
        if lhs.viewItem != rhs.viewItem {
            return false
        }
        if lhs.viewItems != rhs.viewItems {
            return false
        }
        if lhs.searchItems != rhs.searchItems {
            return false
        }
        if lhs.notFound != rhs.notFound {
            return false
        }
        if lhs.notFoundInTrash != rhs.notFoundInTrash {
            return false
        }
        if lhs.parentItemColon != rhs.parentItemColon {
            return false
        }
        if lhs.allItems != rhs.allItems {
            return false
        }
        if lhs.archives != rhs.archives {
            return false
        }
        if lhs.attributes != rhs.attributes {
            return false
        }
        if lhs.insertIntoItem != rhs.insertIntoItem {
            return false
        }
        if lhs.uploadedToThisItem != rhs.uploadedToThisItem {
            return false
        }
        if lhs.featuredImage != rhs.featuredImage {
            return false
        }
        if lhs.setFeaturedImage != rhs.setFeaturedImage {
            return false
        }
        if lhs.removeFeaturedImage != rhs.removeFeaturedImage {
            return false
        }
        if lhs.useFeaturedImage != rhs.useFeaturedImage {
            return false
        }
        if lhs.filterItemsList != rhs.filterItemsList {
            return false
        }
        if lhs.filterByDate != rhs.filterByDate {
            return false
        }
        if lhs.itemsListNavigation != rhs.itemsListNavigation {
            return false
        }
        if lhs.itemsList != rhs.itemsList {
            return false
        }
        if lhs.itemPublished != rhs.itemPublished {
            return false
        }
        if lhs.itemPublishedPrivately != rhs.itemPublishedPrivately {
            return false
        }
        if lhs.itemRevertedToDraft != rhs.itemRevertedToDraft {
            return false
        }
        if lhs.itemTrashed != rhs.itemTrashed {
            return false
        }
        if lhs.itemScheduled != rhs.itemScheduled {
            return false
        }
        if lhs.itemUpdated != rhs.itemUpdated {
            return false
        }
        if lhs.itemLink != rhs.itemLink {
            return false
        }
        if lhs.itemLinkDescription != rhs.itemLinkDescription {
            return false
        }
        if lhs.menuName != rhs.menuName {
            return false
        }
        if lhs.nameAdminBar != rhs.nameAdminBar {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(singularName)
        hasher.combine(addNew)
        hasher.combine(addNewItem)
        hasher.combine(editItem)
        hasher.combine(newItem)
        hasher.combine(viewItem)
        hasher.combine(viewItems)
        hasher.combine(searchItems)
        hasher.combine(notFound)
        hasher.combine(notFoundInTrash)
        hasher.combine(parentItemColon)
        hasher.combine(allItems)
        hasher.combine(archives)
        hasher.combine(attributes)
        hasher.combine(insertIntoItem)
        hasher.combine(uploadedToThisItem)
        hasher.combine(featuredImage)
        hasher.combine(setFeaturedImage)
        hasher.combine(removeFeaturedImage)
        hasher.combine(useFeaturedImage)
        hasher.combine(filterItemsList)
        hasher.combine(filterByDate)
        hasher.combine(itemsListNavigation)
        hasher.combine(itemsList)
        hasher.combine(itemPublished)
        hasher.combine(itemPublishedPrivately)
        hasher.combine(itemRevertedToDraft)
        hasher.combine(itemTrashed)
        hasher.combine(itemScheduled)
        hasher.combine(itemUpdated)
        hasher.combine(itemLink)
        hasher.combine(itemLinkDescription)
        hasher.combine(menuName)
        hasher.combine(nameAdminBar)
    }
}


public struct FfiConverterTypePostTypeLabels: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypeLabels {
        return
            try PostTypeLabels(
                name: FfiConverterString.read(from: &buf), 
                singularName: FfiConverterString.read(from: &buf), 
                addNew: FfiConverterString.read(from: &buf), 
                addNewItem: FfiConverterString.read(from: &buf), 
                editItem: FfiConverterString.read(from: &buf), 
                newItem: FfiConverterString.read(from: &buf), 
                viewItem: FfiConverterString.read(from: &buf), 
                viewItems: FfiConverterString.read(from: &buf), 
                searchItems: FfiConverterString.read(from: &buf), 
                notFound: FfiConverterString.read(from: &buf), 
                notFoundInTrash: FfiConverterString.read(from: &buf), 
                parentItemColon: FfiConverterOptionString.read(from: &buf), 
                allItems: FfiConverterString.read(from: &buf), 
                archives: FfiConverterString.read(from: &buf), 
                attributes: FfiConverterString.read(from: &buf), 
                insertIntoItem: FfiConverterString.read(from: &buf), 
                uploadedToThisItem: FfiConverterString.read(from: &buf), 
                featuredImage: FfiConverterString.read(from: &buf), 
                setFeaturedImage: FfiConverterString.read(from: &buf), 
                removeFeaturedImage: FfiConverterString.read(from: &buf), 
                useFeaturedImage: FfiConverterString.read(from: &buf), 
                filterItemsList: FfiConverterString.read(from: &buf), 
                filterByDate: FfiConverterString.read(from: &buf), 
                itemsListNavigation: FfiConverterString.read(from: &buf), 
                itemsList: FfiConverterString.read(from: &buf), 
                itemPublished: FfiConverterString.read(from: &buf), 
                itemPublishedPrivately: FfiConverterString.read(from: &buf), 
                itemRevertedToDraft: FfiConverterString.read(from: &buf), 
                itemTrashed: FfiConverterString.read(from: &buf), 
                itemScheduled: FfiConverterString.read(from: &buf), 
                itemUpdated: FfiConverterString.read(from: &buf), 
                itemLink: FfiConverterString.read(from: &buf), 
                itemLinkDescription: FfiConverterString.read(from: &buf), 
                menuName: FfiConverterString.read(from: &buf), 
                nameAdminBar: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PostTypeLabels, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.singularName, into: &buf)
        FfiConverterString.write(value.addNew, into: &buf)
        FfiConverterString.write(value.addNewItem, into: &buf)
        FfiConverterString.write(value.editItem, into: &buf)
        FfiConverterString.write(value.newItem, into: &buf)
        FfiConverterString.write(value.viewItem, into: &buf)
        FfiConverterString.write(value.viewItems, into: &buf)
        FfiConverterString.write(value.searchItems, into: &buf)
        FfiConverterString.write(value.notFound, into: &buf)
        FfiConverterString.write(value.notFoundInTrash, into: &buf)
        FfiConverterOptionString.write(value.parentItemColon, into: &buf)
        FfiConverterString.write(value.allItems, into: &buf)
        FfiConverterString.write(value.archives, into: &buf)
        FfiConverterString.write(value.attributes, into: &buf)
        FfiConverterString.write(value.insertIntoItem, into: &buf)
        FfiConverterString.write(value.uploadedToThisItem, into: &buf)
        FfiConverterString.write(value.featuredImage, into: &buf)
        FfiConverterString.write(value.setFeaturedImage, into: &buf)
        FfiConverterString.write(value.removeFeaturedImage, into: &buf)
        FfiConverterString.write(value.useFeaturedImage, into: &buf)
        FfiConverterString.write(value.filterItemsList, into: &buf)
        FfiConverterString.write(value.filterByDate, into: &buf)
        FfiConverterString.write(value.itemsListNavigation, into: &buf)
        FfiConverterString.write(value.itemsList, into: &buf)
        FfiConverterString.write(value.itemPublished, into: &buf)
        FfiConverterString.write(value.itemPublishedPrivately, into: &buf)
        FfiConverterString.write(value.itemRevertedToDraft, into: &buf)
        FfiConverterString.write(value.itemTrashed, into: &buf)
        FfiConverterString.write(value.itemScheduled, into: &buf)
        FfiConverterString.write(value.itemUpdated, into: &buf)
        FfiConverterString.write(value.itemLink, into: &buf)
        FfiConverterString.write(value.itemLinkDescription, into: &buf)
        FfiConverterString.write(value.menuName, into: &buf)
        FfiConverterString.write(value.nameAdminBar, into: &buf)
    }
}


public func FfiConverterTypePostTypeLabels_lift(_ buf: RustBuffer) throws -> PostTypeLabels {
    return try FfiConverterTypePostTypeLabels.lift(buf)
}

public func FfiConverterTypePostTypeLabels_lower(_ value: PostTypeLabels) -> RustBuffer {
    return FfiConverterTypePostTypeLabels.lower(value)
}


public struct PostTypeVisibility {
    public let showInNavMenus: Bool
    public let showUi: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(showInNavMenus: Bool, showUi: Bool) {
        self.showInNavMenus = showInNavMenus
        self.showUi = showUi
    }
}



extension PostTypeVisibility: Equatable, Hashable {
    public static func ==(lhs: PostTypeVisibility, rhs: PostTypeVisibility) -> Bool {
        if lhs.showInNavMenus != rhs.showInNavMenus {
            return false
        }
        if lhs.showUi != rhs.showUi {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(showInNavMenus)
        hasher.combine(showUi)
    }
}


public struct FfiConverterTypePostTypeVisibility: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypeVisibility {
        return
            try PostTypeVisibility(
                showInNavMenus: FfiConverterBool.read(from: &buf), 
                showUi: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: PostTypeVisibility, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.showInNavMenus, into: &buf)
        FfiConverterBool.write(value.showUi, into: &buf)
    }
}


public func FfiConverterTypePostTypeVisibility_lift(_ buf: RustBuffer) throws -> PostTypeVisibility {
    return try FfiConverterTypePostTypeVisibility.lift(buf)
}

public func FfiConverterTypePostTypeVisibility_lower(_ value: PostTypeVisibility) -> RustBuffer {
    return FfiConverterTypePostTypeVisibility.lower(value)
}


public struct PostTypesResponseWithEditContext {
    public let postTypes: [PostType: PostTypeDetailsWithEditContext]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(postTypes: [PostType: PostTypeDetailsWithEditContext]) {
        self.postTypes = postTypes
    }
}



extension PostTypesResponseWithEditContext: Equatable, Hashable {
    public static func ==(lhs: PostTypesResponseWithEditContext, rhs: PostTypesResponseWithEditContext) -> Bool {
        if lhs.postTypes != rhs.postTypes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(postTypes)
    }
}


public struct FfiConverterTypePostTypesResponseWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypesResponseWithEditContext {
        return
            try PostTypesResponseWithEditContext(
                postTypes: FfiConverterDictionaryTypePostTypeTypePostTypeDetailsWithEditContext.read(from: &buf)
        )
    }

    public static func write(_ value: PostTypesResponseWithEditContext, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypePostTypeTypePostTypeDetailsWithEditContext.write(value.postTypes, into: &buf)
    }
}


public func FfiConverterTypePostTypesResponseWithEditContext_lift(_ buf: RustBuffer) throws -> PostTypesResponseWithEditContext {
    return try FfiConverterTypePostTypesResponseWithEditContext.lift(buf)
}

public func FfiConverterTypePostTypesResponseWithEditContext_lower(_ value: PostTypesResponseWithEditContext) -> RustBuffer {
    return FfiConverterTypePostTypesResponseWithEditContext.lower(value)
}


public struct PostTypesResponseWithEmbedContext {
    public let postTypes: [PostType: PostTypeDetailsWithEmbedContext]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(postTypes: [PostType: PostTypeDetailsWithEmbedContext]) {
        self.postTypes = postTypes
    }
}



extension PostTypesResponseWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: PostTypesResponseWithEmbedContext, rhs: PostTypesResponseWithEmbedContext) -> Bool {
        if lhs.postTypes != rhs.postTypes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(postTypes)
    }
}


public struct FfiConverterTypePostTypesResponseWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypesResponseWithEmbedContext {
        return
            try PostTypesResponseWithEmbedContext(
                postTypes: FfiConverterDictionaryTypePostTypeTypePostTypeDetailsWithEmbedContext.read(from: &buf)
        )
    }

    public static func write(_ value: PostTypesResponseWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypePostTypeTypePostTypeDetailsWithEmbedContext.write(value.postTypes, into: &buf)
    }
}


public func FfiConverterTypePostTypesResponseWithEmbedContext_lift(_ buf: RustBuffer) throws -> PostTypesResponseWithEmbedContext {
    return try FfiConverterTypePostTypesResponseWithEmbedContext.lift(buf)
}

public func FfiConverterTypePostTypesResponseWithEmbedContext_lower(_ value: PostTypesResponseWithEmbedContext) -> RustBuffer {
    return FfiConverterTypePostTypesResponseWithEmbedContext.lower(value)
}


public struct PostTypesResponseWithViewContext {
    public let postTypes: [PostType: PostTypeDetailsWithViewContext]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(postTypes: [PostType: PostTypeDetailsWithViewContext]) {
        self.postTypes = postTypes
    }
}



extension PostTypesResponseWithViewContext: Equatable, Hashable {
    public static func ==(lhs: PostTypesResponseWithViewContext, rhs: PostTypesResponseWithViewContext) -> Bool {
        if lhs.postTypes != rhs.postTypes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(postTypes)
    }
}


public struct FfiConverterTypePostTypesResponseWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypesResponseWithViewContext {
        return
            try PostTypesResponseWithViewContext(
                postTypes: FfiConverterDictionaryTypePostTypeTypePostTypeDetailsWithViewContext.read(from: &buf)
        )
    }

    public static func write(_ value: PostTypesResponseWithViewContext, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypePostTypeTypePostTypeDetailsWithViewContext.write(value.postTypes, into: &buf)
    }
}


public func FfiConverterTypePostTypesResponseWithViewContext_lift(_ buf: RustBuffer) throws -> PostTypesResponseWithViewContext {
    return try FfiConverterTypePostTypesResponseWithViewContext.lift(buf)
}

public func FfiConverterTypePostTypesResponseWithViewContext_lower(_ value: PostTypesResponseWithViewContext) -> RustBuffer {
    return FfiConverterTypePostTypesResponseWithViewContext.lower(value)
}


public struct SiteSettingsUpdateParams {
    public let title: String?
    public let description: String?
    public let url: String?
    public let email: String?
    public let timezone: String?
    public let dateFormat: String?
    public let timeFormat: String?
    public let startOfWeek: UInt64?
    public let language: String?
    public let useSmilies: Bool?
    public let defaultCategory: UInt64?
    public let defaultPostFormat: String?
    public let postsPerPage: UInt64?
    public let showOnFront: String?
    public let pageOnFront: UInt64?
    public let pageForPosts: UInt64?
    public let defaultPingStatus: SiteSettingsPingStatus?
    public let defaultCommentStatus: SiteSettingsCommentStatus?
    public let siteLogo: UInt64?
    public let siteIcon: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String? = nil, description: String? = nil, url: String? = nil, email: String? = nil, timezone: String? = nil, dateFormat: String? = nil, timeFormat: String? = nil, startOfWeek: UInt64? = nil, language: String? = nil, useSmilies: Bool? = nil, defaultCategory: UInt64? = nil, defaultPostFormat: String? = nil, postsPerPage: UInt64? = nil, showOnFront: String? = nil, pageOnFront: UInt64? = nil, pageForPosts: UInt64? = nil, defaultPingStatus: SiteSettingsPingStatus? = nil, defaultCommentStatus: SiteSettingsCommentStatus? = nil, siteLogo: UInt64? = nil, siteIcon: UInt64? = nil) {
        self.title = title
        self.description = description
        self.url = url
        self.email = email
        self.timezone = timezone
        self.dateFormat = dateFormat
        self.timeFormat = timeFormat
        self.startOfWeek = startOfWeek
        self.language = language
        self.useSmilies = useSmilies
        self.defaultCategory = defaultCategory
        self.defaultPostFormat = defaultPostFormat
        self.postsPerPage = postsPerPage
        self.showOnFront = showOnFront
        self.pageOnFront = pageOnFront
        self.pageForPosts = pageForPosts
        self.defaultPingStatus = defaultPingStatus
        self.defaultCommentStatus = defaultCommentStatus
        self.siteLogo = siteLogo
        self.siteIcon = siteIcon
    }
}



extension SiteSettingsUpdateParams: Equatable, Hashable {
    public static func ==(lhs: SiteSettingsUpdateParams, rhs: SiteSettingsUpdateParams) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.timezone != rhs.timezone {
            return false
        }
        if lhs.dateFormat != rhs.dateFormat {
            return false
        }
        if lhs.timeFormat != rhs.timeFormat {
            return false
        }
        if lhs.startOfWeek != rhs.startOfWeek {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        if lhs.useSmilies != rhs.useSmilies {
            return false
        }
        if lhs.defaultCategory != rhs.defaultCategory {
            return false
        }
        if lhs.defaultPostFormat != rhs.defaultPostFormat {
            return false
        }
        if lhs.postsPerPage != rhs.postsPerPage {
            return false
        }
        if lhs.showOnFront != rhs.showOnFront {
            return false
        }
        if lhs.pageOnFront != rhs.pageOnFront {
            return false
        }
        if lhs.pageForPosts != rhs.pageForPosts {
            return false
        }
        if lhs.defaultPingStatus != rhs.defaultPingStatus {
            return false
        }
        if lhs.defaultCommentStatus != rhs.defaultCommentStatus {
            return false
        }
        if lhs.siteLogo != rhs.siteLogo {
            return false
        }
        if lhs.siteIcon != rhs.siteIcon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(email)
        hasher.combine(timezone)
        hasher.combine(dateFormat)
        hasher.combine(timeFormat)
        hasher.combine(startOfWeek)
        hasher.combine(language)
        hasher.combine(useSmilies)
        hasher.combine(defaultCategory)
        hasher.combine(defaultPostFormat)
        hasher.combine(postsPerPage)
        hasher.combine(showOnFront)
        hasher.combine(pageOnFront)
        hasher.combine(pageForPosts)
        hasher.combine(defaultPingStatus)
        hasher.combine(defaultCommentStatus)
        hasher.combine(siteLogo)
        hasher.combine(siteIcon)
    }
}


public struct FfiConverterTypeSiteSettingsUpdateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SiteSettingsUpdateParams {
        return
            try SiteSettingsUpdateParams(
                title: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                timezone: FfiConverterOptionString.read(from: &buf), 
                dateFormat: FfiConverterOptionString.read(from: &buf), 
                timeFormat: FfiConverterOptionString.read(from: &buf), 
                startOfWeek: FfiConverterOptionUInt64.read(from: &buf), 
                language: FfiConverterOptionString.read(from: &buf), 
                useSmilies: FfiConverterOptionBool.read(from: &buf), 
                defaultCategory: FfiConverterOptionUInt64.read(from: &buf), 
                defaultPostFormat: FfiConverterOptionString.read(from: &buf), 
                postsPerPage: FfiConverterOptionUInt64.read(from: &buf), 
                showOnFront: FfiConverterOptionString.read(from: &buf), 
                pageOnFront: FfiConverterOptionUInt64.read(from: &buf), 
                pageForPosts: FfiConverterOptionUInt64.read(from: &buf), 
                defaultPingStatus: FfiConverterOptionTypeSiteSettingsPingStatus.read(from: &buf), 
                defaultCommentStatus: FfiConverterOptionTypeSiteSettingsCommentStatus.read(from: &buf), 
                siteLogo: FfiConverterOptionUInt64.read(from: &buf), 
                siteIcon: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SiteSettingsUpdateParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.timezone, into: &buf)
        FfiConverterOptionString.write(value.dateFormat, into: &buf)
        FfiConverterOptionString.write(value.timeFormat, into: &buf)
        FfiConverterOptionUInt64.write(value.startOfWeek, into: &buf)
        FfiConverterOptionString.write(value.language, into: &buf)
        FfiConverterOptionBool.write(value.useSmilies, into: &buf)
        FfiConverterOptionUInt64.write(value.defaultCategory, into: &buf)
        FfiConverterOptionString.write(value.defaultPostFormat, into: &buf)
        FfiConverterOptionUInt64.write(value.postsPerPage, into: &buf)
        FfiConverterOptionString.write(value.showOnFront, into: &buf)
        FfiConverterOptionUInt64.write(value.pageOnFront, into: &buf)
        FfiConverterOptionUInt64.write(value.pageForPosts, into: &buf)
        FfiConverterOptionTypeSiteSettingsPingStatus.write(value.defaultPingStatus, into: &buf)
        FfiConverterOptionTypeSiteSettingsCommentStatus.write(value.defaultCommentStatus, into: &buf)
        FfiConverterOptionUInt64.write(value.siteLogo, into: &buf)
        FfiConverterOptionUInt64.write(value.siteIcon, into: &buf)
    }
}


public func FfiConverterTypeSiteSettingsUpdateParams_lift(_ buf: RustBuffer) throws -> SiteSettingsUpdateParams {
    return try FfiConverterTypeSiteSettingsUpdateParams.lift(buf)
}

public func FfiConverterTypeSiteSettingsUpdateParams_lower(_ value: SiteSettingsUpdateParams) -> RustBuffer {
    return FfiConverterTypeSiteSettingsUpdateParams.lower(value)
}


public struct SiteSettingsWithEditContext {
    public let title: String
    public let description: String
    public let url: String
    public let email: String
    public let timezone: String
    public let dateFormat: String
    public let timeFormat: String
    public let startOfWeek: UInt64
    public let language: String
    public let useSmilies: Bool
    public let defaultCategory: UInt64
    public let defaultPostFormat: String
    public let postsPerPage: UInt64
    public let showOnFront: String
    public let pageOnFront: UInt64
    public let pageForPosts: UInt64
    public let defaultPingStatus: SiteSettingsPingStatus
    public let defaultCommentStatus: SiteSettingsCommentStatus
    public let siteLogo: UInt64?
    public let siteIcon: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String, description: String, url: String, email: String, timezone: String, dateFormat: String, timeFormat: String, startOfWeek: UInt64, language: String, useSmilies: Bool, defaultCategory: UInt64, defaultPostFormat: String, postsPerPage: UInt64, showOnFront: String, pageOnFront: UInt64, pageForPosts: UInt64, defaultPingStatus: SiteSettingsPingStatus, defaultCommentStatus: SiteSettingsCommentStatus, siteLogo: UInt64?, siteIcon: UInt64) {
        self.title = title
        self.description = description
        self.url = url
        self.email = email
        self.timezone = timezone
        self.dateFormat = dateFormat
        self.timeFormat = timeFormat
        self.startOfWeek = startOfWeek
        self.language = language
        self.useSmilies = useSmilies
        self.defaultCategory = defaultCategory
        self.defaultPostFormat = defaultPostFormat
        self.postsPerPage = postsPerPage
        self.showOnFront = showOnFront
        self.pageOnFront = pageOnFront
        self.pageForPosts = pageForPosts
        self.defaultPingStatus = defaultPingStatus
        self.defaultCommentStatus = defaultCommentStatus
        self.siteLogo = siteLogo
        self.siteIcon = siteIcon
    }
}



extension SiteSettingsWithEditContext: Equatable, Hashable {
    public static func ==(lhs: SiteSettingsWithEditContext, rhs: SiteSettingsWithEditContext) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.timezone != rhs.timezone {
            return false
        }
        if lhs.dateFormat != rhs.dateFormat {
            return false
        }
        if lhs.timeFormat != rhs.timeFormat {
            return false
        }
        if lhs.startOfWeek != rhs.startOfWeek {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        if lhs.useSmilies != rhs.useSmilies {
            return false
        }
        if lhs.defaultCategory != rhs.defaultCategory {
            return false
        }
        if lhs.defaultPostFormat != rhs.defaultPostFormat {
            return false
        }
        if lhs.postsPerPage != rhs.postsPerPage {
            return false
        }
        if lhs.showOnFront != rhs.showOnFront {
            return false
        }
        if lhs.pageOnFront != rhs.pageOnFront {
            return false
        }
        if lhs.pageForPosts != rhs.pageForPosts {
            return false
        }
        if lhs.defaultPingStatus != rhs.defaultPingStatus {
            return false
        }
        if lhs.defaultCommentStatus != rhs.defaultCommentStatus {
            return false
        }
        if lhs.siteLogo != rhs.siteLogo {
            return false
        }
        if lhs.siteIcon != rhs.siteIcon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(email)
        hasher.combine(timezone)
        hasher.combine(dateFormat)
        hasher.combine(timeFormat)
        hasher.combine(startOfWeek)
        hasher.combine(language)
        hasher.combine(useSmilies)
        hasher.combine(defaultCategory)
        hasher.combine(defaultPostFormat)
        hasher.combine(postsPerPage)
        hasher.combine(showOnFront)
        hasher.combine(pageOnFront)
        hasher.combine(pageForPosts)
        hasher.combine(defaultPingStatus)
        hasher.combine(defaultCommentStatus)
        hasher.combine(siteLogo)
        hasher.combine(siteIcon)
    }
}


public struct FfiConverterTypeSiteSettingsWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SiteSettingsWithEditContext {
        return
            try SiteSettingsWithEditContext(
                title: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                timezone: FfiConverterString.read(from: &buf), 
                dateFormat: FfiConverterString.read(from: &buf), 
                timeFormat: FfiConverterString.read(from: &buf), 
                startOfWeek: FfiConverterUInt64.read(from: &buf), 
                language: FfiConverterString.read(from: &buf), 
                useSmilies: FfiConverterBool.read(from: &buf), 
                defaultCategory: FfiConverterUInt64.read(from: &buf), 
                defaultPostFormat: FfiConverterString.read(from: &buf), 
                postsPerPage: FfiConverterUInt64.read(from: &buf), 
                showOnFront: FfiConverterString.read(from: &buf), 
                pageOnFront: FfiConverterUInt64.read(from: &buf), 
                pageForPosts: FfiConverterUInt64.read(from: &buf), 
                defaultPingStatus: FfiConverterTypeSiteSettingsPingStatus.read(from: &buf), 
                defaultCommentStatus: FfiConverterTypeSiteSettingsCommentStatus.read(from: &buf), 
                siteLogo: FfiConverterOptionUInt64.read(from: &buf), 
                siteIcon: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SiteSettingsWithEditContext, into buf: inout [UInt8]) {
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterString.write(value.timezone, into: &buf)
        FfiConverterString.write(value.dateFormat, into: &buf)
        FfiConverterString.write(value.timeFormat, into: &buf)
        FfiConverterUInt64.write(value.startOfWeek, into: &buf)
        FfiConverterString.write(value.language, into: &buf)
        FfiConverterBool.write(value.useSmilies, into: &buf)
        FfiConverterUInt64.write(value.defaultCategory, into: &buf)
        FfiConverterString.write(value.defaultPostFormat, into: &buf)
        FfiConverterUInt64.write(value.postsPerPage, into: &buf)
        FfiConverterString.write(value.showOnFront, into: &buf)
        FfiConverterUInt64.write(value.pageOnFront, into: &buf)
        FfiConverterUInt64.write(value.pageForPosts, into: &buf)
        FfiConverterTypeSiteSettingsPingStatus.write(value.defaultPingStatus, into: &buf)
        FfiConverterTypeSiteSettingsCommentStatus.write(value.defaultCommentStatus, into: &buf)
        FfiConverterOptionUInt64.write(value.siteLogo, into: &buf)
        FfiConverterUInt64.write(value.siteIcon, into: &buf)
    }
}


public func FfiConverterTypeSiteSettingsWithEditContext_lift(_ buf: RustBuffer) throws -> SiteSettingsWithEditContext {
    return try FfiConverterTypeSiteSettingsWithEditContext.lift(buf)
}

public func FfiConverterTypeSiteSettingsWithEditContext_lower(_ value: SiteSettingsWithEditContext) -> RustBuffer {
    return FfiConverterTypeSiteSettingsWithEditContext.lower(value)
}


public struct SiteSettingsWithEmbedContext {
    public let title: String
    public let description: String
    public let url: String
    public let email: String
    public let timezone: String
    public let dateFormat: String
    public let timeFormat: String
    public let startOfWeek: UInt64
    public let language: String
    public let useSmilies: Bool
    public let defaultCategory: UInt64
    public let defaultPostFormat: String
    public let postsPerPage: UInt64
    public let showOnFront: String
    public let pageOnFront: UInt64
    public let pageForPosts: UInt64
    public let defaultPingStatus: SiteSettingsPingStatus
    public let defaultCommentStatus: SiteSettingsCommentStatus
    public let siteLogo: UInt64?
    public let siteIcon: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String, description: String, url: String, email: String, timezone: String, dateFormat: String, timeFormat: String, startOfWeek: UInt64, language: String, useSmilies: Bool, defaultCategory: UInt64, defaultPostFormat: String, postsPerPage: UInt64, showOnFront: String, pageOnFront: UInt64, pageForPosts: UInt64, defaultPingStatus: SiteSettingsPingStatus, defaultCommentStatus: SiteSettingsCommentStatus, siteLogo: UInt64?, siteIcon: UInt64) {
        self.title = title
        self.description = description
        self.url = url
        self.email = email
        self.timezone = timezone
        self.dateFormat = dateFormat
        self.timeFormat = timeFormat
        self.startOfWeek = startOfWeek
        self.language = language
        self.useSmilies = useSmilies
        self.defaultCategory = defaultCategory
        self.defaultPostFormat = defaultPostFormat
        self.postsPerPage = postsPerPage
        self.showOnFront = showOnFront
        self.pageOnFront = pageOnFront
        self.pageForPosts = pageForPosts
        self.defaultPingStatus = defaultPingStatus
        self.defaultCommentStatus = defaultCommentStatus
        self.siteLogo = siteLogo
        self.siteIcon = siteIcon
    }
}



extension SiteSettingsWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: SiteSettingsWithEmbedContext, rhs: SiteSettingsWithEmbedContext) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.timezone != rhs.timezone {
            return false
        }
        if lhs.dateFormat != rhs.dateFormat {
            return false
        }
        if lhs.timeFormat != rhs.timeFormat {
            return false
        }
        if lhs.startOfWeek != rhs.startOfWeek {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        if lhs.useSmilies != rhs.useSmilies {
            return false
        }
        if lhs.defaultCategory != rhs.defaultCategory {
            return false
        }
        if lhs.defaultPostFormat != rhs.defaultPostFormat {
            return false
        }
        if lhs.postsPerPage != rhs.postsPerPage {
            return false
        }
        if lhs.showOnFront != rhs.showOnFront {
            return false
        }
        if lhs.pageOnFront != rhs.pageOnFront {
            return false
        }
        if lhs.pageForPosts != rhs.pageForPosts {
            return false
        }
        if lhs.defaultPingStatus != rhs.defaultPingStatus {
            return false
        }
        if lhs.defaultCommentStatus != rhs.defaultCommentStatus {
            return false
        }
        if lhs.siteLogo != rhs.siteLogo {
            return false
        }
        if lhs.siteIcon != rhs.siteIcon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(email)
        hasher.combine(timezone)
        hasher.combine(dateFormat)
        hasher.combine(timeFormat)
        hasher.combine(startOfWeek)
        hasher.combine(language)
        hasher.combine(useSmilies)
        hasher.combine(defaultCategory)
        hasher.combine(defaultPostFormat)
        hasher.combine(postsPerPage)
        hasher.combine(showOnFront)
        hasher.combine(pageOnFront)
        hasher.combine(pageForPosts)
        hasher.combine(defaultPingStatus)
        hasher.combine(defaultCommentStatus)
        hasher.combine(siteLogo)
        hasher.combine(siteIcon)
    }
}


public struct FfiConverterTypeSiteSettingsWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SiteSettingsWithEmbedContext {
        return
            try SiteSettingsWithEmbedContext(
                title: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                timezone: FfiConverterString.read(from: &buf), 
                dateFormat: FfiConverterString.read(from: &buf), 
                timeFormat: FfiConverterString.read(from: &buf), 
                startOfWeek: FfiConverterUInt64.read(from: &buf), 
                language: FfiConverterString.read(from: &buf), 
                useSmilies: FfiConverterBool.read(from: &buf), 
                defaultCategory: FfiConverterUInt64.read(from: &buf), 
                defaultPostFormat: FfiConverterString.read(from: &buf), 
                postsPerPage: FfiConverterUInt64.read(from: &buf), 
                showOnFront: FfiConverterString.read(from: &buf), 
                pageOnFront: FfiConverterUInt64.read(from: &buf), 
                pageForPosts: FfiConverterUInt64.read(from: &buf), 
                defaultPingStatus: FfiConverterTypeSiteSettingsPingStatus.read(from: &buf), 
                defaultCommentStatus: FfiConverterTypeSiteSettingsCommentStatus.read(from: &buf), 
                siteLogo: FfiConverterOptionUInt64.read(from: &buf), 
                siteIcon: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SiteSettingsWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterString.write(value.timezone, into: &buf)
        FfiConverterString.write(value.dateFormat, into: &buf)
        FfiConverterString.write(value.timeFormat, into: &buf)
        FfiConverterUInt64.write(value.startOfWeek, into: &buf)
        FfiConverterString.write(value.language, into: &buf)
        FfiConverterBool.write(value.useSmilies, into: &buf)
        FfiConverterUInt64.write(value.defaultCategory, into: &buf)
        FfiConverterString.write(value.defaultPostFormat, into: &buf)
        FfiConverterUInt64.write(value.postsPerPage, into: &buf)
        FfiConverterString.write(value.showOnFront, into: &buf)
        FfiConverterUInt64.write(value.pageOnFront, into: &buf)
        FfiConverterUInt64.write(value.pageForPosts, into: &buf)
        FfiConverterTypeSiteSettingsPingStatus.write(value.defaultPingStatus, into: &buf)
        FfiConverterTypeSiteSettingsCommentStatus.write(value.defaultCommentStatus, into: &buf)
        FfiConverterOptionUInt64.write(value.siteLogo, into: &buf)
        FfiConverterUInt64.write(value.siteIcon, into: &buf)
    }
}


public func FfiConverterTypeSiteSettingsWithEmbedContext_lift(_ buf: RustBuffer) throws -> SiteSettingsWithEmbedContext {
    return try FfiConverterTypeSiteSettingsWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSiteSettingsWithEmbedContext_lower(_ value: SiteSettingsWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSiteSettingsWithEmbedContext.lower(value)
}


public struct SiteSettingsWithViewContext {
    public let title: String
    public let description: String
    public let url: String
    public let email: String
    public let timezone: String
    public let dateFormat: String
    public let timeFormat: String
    public let startOfWeek: UInt64
    public let language: String
    public let useSmilies: Bool
    public let defaultCategory: UInt64
    public let defaultPostFormat: String
    public let postsPerPage: UInt64
    public let showOnFront: String
    public let pageOnFront: UInt64
    public let pageForPosts: UInt64
    public let defaultPingStatus: SiteSettingsPingStatus
    public let defaultCommentStatus: SiteSettingsCommentStatus
    public let siteLogo: UInt64?
    public let siteIcon: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String, description: String, url: String, email: String, timezone: String, dateFormat: String, timeFormat: String, startOfWeek: UInt64, language: String, useSmilies: Bool, defaultCategory: UInt64, defaultPostFormat: String, postsPerPage: UInt64, showOnFront: String, pageOnFront: UInt64, pageForPosts: UInt64, defaultPingStatus: SiteSettingsPingStatus, defaultCommentStatus: SiteSettingsCommentStatus, siteLogo: UInt64?, siteIcon: UInt64) {
        self.title = title
        self.description = description
        self.url = url
        self.email = email
        self.timezone = timezone
        self.dateFormat = dateFormat
        self.timeFormat = timeFormat
        self.startOfWeek = startOfWeek
        self.language = language
        self.useSmilies = useSmilies
        self.defaultCategory = defaultCategory
        self.defaultPostFormat = defaultPostFormat
        self.postsPerPage = postsPerPage
        self.showOnFront = showOnFront
        self.pageOnFront = pageOnFront
        self.pageForPosts = pageForPosts
        self.defaultPingStatus = defaultPingStatus
        self.defaultCommentStatus = defaultCommentStatus
        self.siteLogo = siteLogo
        self.siteIcon = siteIcon
    }
}



extension SiteSettingsWithViewContext: Equatable, Hashable {
    public static func ==(lhs: SiteSettingsWithViewContext, rhs: SiteSettingsWithViewContext) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.timezone != rhs.timezone {
            return false
        }
        if lhs.dateFormat != rhs.dateFormat {
            return false
        }
        if lhs.timeFormat != rhs.timeFormat {
            return false
        }
        if lhs.startOfWeek != rhs.startOfWeek {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        if lhs.useSmilies != rhs.useSmilies {
            return false
        }
        if lhs.defaultCategory != rhs.defaultCategory {
            return false
        }
        if lhs.defaultPostFormat != rhs.defaultPostFormat {
            return false
        }
        if lhs.postsPerPage != rhs.postsPerPage {
            return false
        }
        if lhs.showOnFront != rhs.showOnFront {
            return false
        }
        if lhs.pageOnFront != rhs.pageOnFront {
            return false
        }
        if lhs.pageForPosts != rhs.pageForPosts {
            return false
        }
        if lhs.defaultPingStatus != rhs.defaultPingStatus {
            return false
        }
        if lhs.defaultCommentStatus != rhs.defaultCommentStatus {
            return false
        }
        if lhs.siteLogo != rhs.siteLogo {
            return false
        }
        if lhs.siteIcon != rhs.siteIcon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(email)
        hasher.combine(timezone)
        hasher.combine(dateFormat)
        hasher.combine(timeFormat)
        hasher.combine(startOfWeek)
        hasher.combine(language)
        hasher.combine(useSmilies)
        hasher.combine(defaultCategory)
        hasher.combine(defaultPostFormat)
        hasher.combine(postsPerPage)
        hasher.combine(showOnFront)
        hasher.combine(pageOnFront)
        hasher.combine(pageForPosts)
        hasher.combine(defaultPingStatus)
        hasher.combine(defaultCommentStatus)
        hasher.combine(siteLogo)
        hasher.combine(siteIcon)
    }
}


public struct FfiConverterTypeSiteSettingsWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SiteSettingsWithViewContext {
        return
            try SiteSettingsWithViewContext(
                title: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                timezone: FfiConverterString.read(from: &buf), 
                dateFormat: FfiConverterString.read(from: &buf), 
                timeFormat: FfiConverterString.read(from: &buf), 
                startOfWeek: FfiConverterUInt64.read(from: &buf), 
                language: FfiConverterString.read(from: &buf), 
                useSmilies: FfiConverterBool.read(from: &buf), 
                defaultCategory: FfiConverterUInt64.read(from: &buf), 
                defaultPostFormat: FfiConverterString.read(from: &buf), 
                postsPerPage: FfiConverterUInt64.read(from: &buf), 
                showOnFront: FfiConverterString.read(from: &buf), 
                pageOnFront: FfiConverterUInt64.read(from: &buf), 
                pageForPosts: FfiConverterUInt64.read(from: &buf), 
                defaultPingStatus: FfiConverterTypeSiteSettingsPingStatus.read(from: &buf), 
                defaultCommentStatus: FfiConverterTypeSiteSettingsCommentStatus.read(from: &buf), 
                siteLogo: FfiConverterOptionUInt64.read(from: &buf), 
                siteIcon: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SiteSettingsWithViewContext, into buf: inout [UInt8]) {
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterString.write(value.timezone, into: &buf)
        FfiConverterString.write(value.dateFormat, into: &buf)
        FfiConverterString.write(value.timeFormat, into: &buf)
        FfiConverterUInt64.write(value.startOfWeek, into: &buf)
        FfiConverterString.write(value.language, into: &buf)
        FfiConverterBool.write(value.useSmilies, into: &buf)
        FfiConverterUInt64.write(value.defaultCategory, into: &buf)
        FfiConverterString.write(value.defaultPostFormat, into: &buf)
        FfiConverterUInt64.write(value.postsPerPage, into: &buf)
        FfiConverterString.write(value.showOnFront, into: &buf)
        FfiConverterUInt64.write(value.pageOnFront, into: &buf)
        FfiConverterUInt64.write(value.pageForPosts, into: &buf)
        FfiConverterTypeSiteSettingsPingStatus.write(value.defaultPingStatus, into: &buf)
        FfiConverterTypeSiteSettingsCommentStatus.write(value.defaultCommentStatus, into: &buf)
        FfiConverterOptionUInt64.write(value.siteLogo, into: &buf)
        FfiConverterUInt64.write(value.siteIcon, into: &buf)
    }
}


public func FfiConverterTypeSiteSettingsWithViewContext_lift(_ buf: RustBuffer) throws -> SiteSettingsWithViewContext {
    return try FfiConverterTypeSiteSettingsWithViewContext.lift(buf)
}

public func FfiConverterTypeSiteSettingsWithViewContext_lower(_ value: SiteSettingsWithViewContext) -> RustBuffer {
    return FfiConverterTypeSiteSettingsWithViewContext.lower(value)
}


public struct SparseApplicationPassword {
    public let uuid: ApplicationPasswordUuid?
    public let appId: ApplicationPasswordAppId?
    public let name: String?
    public let created: String?
    public let lastUsed: String?
    public let lastIp: IpAddress?
    public let password: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid?, appId: ApplicationPasswordAppId?, name: String?, created: String?, lastUsed: String?, lastIp: IpAddress?, password: String?) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
        self.created = created
        self.lastUsed = lastUsed
        self.lastIp = lastIp
        self.password = password
    }
}



extension SparseApplicationPassword: Equatable, Hashable {
    public static func ==(lhs: SparseApplicationPassword, rhs: SparseApplicationPassword) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        if lhs.lastUsed != rhs.lastUsed {
            return false
        }
        if lhs.lastIp != rhs.lastIp {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
        hasher.combine(created)
        hasher.combine(lastUsed)
        hasher.combine(lastIp)
        hasher.combine(password)
    }
}


public struct FfiConverterTypeSparseApplicationPassword: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseApplicationPassword {
        return
            try SparseApplicationPassword(
                uuid: FfiConverterOptionTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterOptionTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                created: FfiConverterOptionString.read(from: &buf), 
                lastUsed: FfiConverterOptionString.read(from: &buf), 
                lastIp: FfiConverterOptionTypeIpAddress.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparseApplicationPassword, into buf: inout [UInt8]) {
        FfiConverterOptionTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterOptionTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.created, into: &buf)
        FfiConverterOptionString.write(value.lastUsed, into: &buf)
        FfiConverterOptionTypeIpAddress.write(value.lastIp, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
    }
}


public func FfiConverterTypeSparseApplicationPassword_lift(_ buf: RustBuffer) throws -> SparseApplicationPassword {
    return try FfiConverterTypeSparseApplicationPassword.lift(buf)
}

public func FfiConverterTypeSparseApplicationPassword_lower(_ value: SparseApplicationPassword) -> RustBuffer {
    return FfiConverterTypeSparseApplicationPassword.lower(value)
}


public struct SparseApplicationPasswordWithEditContext {
    public let uuid: ApplicationPasswordUuid?
    public let appId: ApplicationPasswordAppId?
    public let name: String?
    public let created: String?
    public let lastUsed: String?
    public let lastIp: IpAddress?
    public let password: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid?, appId: ApplicationPasswordAppId?, name: String?, created: String?, lastUsed: String?, lastIp: IpAddress?, password: String?) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
        self.created = created
        self.lastUsed = lastUsed
        self.lastIp = lastIp
        self.password = password
    }
}



extension SparseApplicationPasswordWithEditContext: Equatable, Hashable {
    public static func ==(lhs: SparseApplicationPasswordWithEditContext, rhs: SparseApplicationPasswordWithEditContext) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        if lhs.lastUsed != rhs.lastUsed {
            return false
        }
        if lhs.lastIp != rhs.lastIp {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
        hasher.combine(created)
        hasher.combine(lastUsed)
        hasher.combine(lastIp)
        hasher.combine(password)
    }
}


public struct FfiConverterTypeSparseApplicationPasswordWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseApplicationPasswordWithEditContext {
        return
            try SparseApplicationPasswordWithEditContext(
                uuid: FfiConverterOptionTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterOptionTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                created: FfiConverterOptionString.read(from: &buf), 
                lastUsed: FfiConverterOptionString.read(from: &buf), 
                lastIp: FfiConverterOptionTypeIpAddress.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparseApplicationPasswordWithEditContext, into buf: inout [UInt8]) {
        FfiConverterOptionTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterOptionTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.created, into: &buf)
        FfiConverterOptionString.write(value.lastUsed, into: &buf)
        FfiConverterOptionTypeIpAddress.write(value.lastIp, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
    }
}


public func FfiConverterTypeSparseApplicationPasswordWithEditContext_lift(_ buf: RustBuffer) throws -> SparseApplicationPasswordWithEditContext {
    return try FfiConverterTypeSparseApplicationPasswordWithEditContext.lift(buf)
}

public func FfiConverterTypeSparseApplicationPasswordWithEditContext_lower(_ value: SparseApplicationPasswordWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparseApplicationPasswordWithEditContext.lower(value)
}


public struct SparseApplicationPasswordWithEmbedContext {
    public let uuid: ApplicationPasswordUuid?
    public let appId: ApplicationPasswordAppId?
    public let name: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid?, appId: ApplicationPasswordAppId?, name: String?) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
    }
}



extension SparseApplicationPasswordWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: SparseApplicationPasswordWithEmbedContext, rhs: SparseApplicationPasswordWithEmbedContext) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
    }
}


public struct FfiConverterTypeSparseApplicationPasswordWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseApplicationPasswordWithEmbedContext {
        return
            try SparseApplicationPasswordWithEmbedContext(
                uuid: FfiConverterOptionTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterOptionTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparseApplicationPasswordWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterOptionTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterOptionTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeSparseApplicationPasswordWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparseApplicationPasswordWithEmbedContext {
    return try FfiConverterTypeSparseApplicationPasswordWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparseApplicationPasswordWithEmbedContext_lower(_ value: SparseApplicationPasswordWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparseApplicationPasswordWithEmbedContext.lower(value)
}


public struct SparseApplicationPasswordWithViewContext {
    public let uuid: ApplicationPasswordUuid?
    public let appId: ApplicationPasswordAppId?
    public let name: String?
    public let created: String?
    public let lastUsed: String?
    public let lastIp: IpAddress?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid?, appId: ApplicationPasswordAppId?, name: String?, created: String?, lastUsed: String?, lastIp: IpAddress?) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
        self.created = created
        self.lastUsed = lastUsed
        self.lastIp = lastIp
    }
}



extension SparseApplicationPasswordWithViewContext: Equatable, Hashable {
    public static func ==(lhs: SparseApplicationPasswordWithViewContext, rhs: SparseApplicationPasswordWithViewContext) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        if lhs.lastUsed != rhs.lastUsed {
            return false
        }
        if lhs.lastIp != rhs.lastIp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
        hasher.combine(created)
        hasher.combine(lastUsed)
        hasher.combine(lastIp)
    }
}


public struct FfiConverterTypeSparseApplicationPasswordWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseApplicationPasswordWithViewContext {
        return
            try SparseApplicationPasswordWithViewContext(
                uuid: FfiConverterOptionTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterOptionTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                created: FfiConverterOptionString.read(from: &buf), 
                lastUsed: FfiConverterOptionString.read(from: &buf), 
                lastIp: FfiConverterOptionTypeIpAddress.read(from: &buf)
        )
    }

    public static func write(_ value: SparseApplicationPasswordWithViewContext, into buf: inout [UInt8]) {
        FfiConverterOptionTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterOptionTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.created, into: &buf)
        FfiConverterOptionString.write(value.lastUsed, into: &buf)
        FfiConverterOptionTypeIpAddress.write(value.lastIp, into: &buf)
    }
}


public func FfiConverterTypeSparseApplicationPasswordWithViewContext_lift(_ buf: RustBuffer) throws -> SparseApplicationPasswordWithViewContext {
    return try FfiConverterTypeSparseApplicationPasswordWithViewContext.lift(buf)
}

public func FfiConverterTypeSparseApplicationPasswordWithViewContext_lower(_ value: SparseApplicationPasswordWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparseApplicationPasswordWithViewContext.lower(value)
}


public struct SparsePlugin {
    public let plugin: PluginSlug?
    public let status: PluginStatus?
    public let name: String?
    public let pluginUri: String?
    public let author: String?
    public let authorUri: String?
    public let description: PluginDescription?
    public let version: String?
    public let networkOnly: Bool?
    public let requiresWp: String?
    public let requiresPhp: String?
    public let textdomain: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug?, status: PluginStatus?, name: String?, pluginUri: String?, author: String?, authorUri: String?, description: PluginDescription?, version: String?, networkOnly: Bool?, requiresWp: String?, requiresPhp: String?, textdomain: String?) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.pluginUri = pluginUri
        self.author = author
        self.authorUri = authorUri
        self.description = description
        self.version = version
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
        self.textdomain = textdomain
    }
}



extension SparsePlugin: Equatable, Hashable {
    public static func ==(lhs: SparsePlugin, rhs: SparsePlugin) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pluginUri != rhs.pluginUri {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.authorUri != rhs.authorUri {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        if lhs.textdomain != rhs.textdomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(pluginUri)
        hasher.combine(author)
        hasher.combine(authorUri)
        hasher.combine(description)
        hasher.combine(version)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
        hasher.combine(textdomain)
    }
}


public struct FfiConverterTypeSparsePlugin: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePlugin {
        return
            try SparsePlugin(
                plugin: FfiConverterOptionTypePluginSlug.read(from: &buf), 
                status: FfiConverterOptionTypePluginStatus.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                pluginUri: FfiConverterOptionString.read(from: &buf), 
                author: FfiConverterOptionString.read(from: &buf), 
                authorUri: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionTypePluginDescription.read(from: &buf), 
                version: FfiConverterOptionString.read(from: &buf), 
                networkOnly: FfiConverterOptionBool.read(from: &buf), 
                requiresWp: FfiConverterOptionString.read(from: &buf), 
                requiresPhp: FfiConverterOptionString.read(from: &buf), 
                textdomain: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePlugin, into buf: inout [UInt8]) {
        FfiConverterOptionTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterOptionTypePluginStatus.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.pluginUri, into: &buf)
        FfiConverterOptionString.write(value.author, into: &buf)
        FfiConverterOptionString.write(value.authorUri, into: &buf)
        FfiConverterOptionTypePluginDescription.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.version, into: &buf)
        FfiConverterOptionBool.write(value.networkOnly, into: &buf)
        FfiConverterOptionString.write(value.requiresWp, into: &buf)
        FfiConverterOptionString.write(value.requiresPhp, into: &buf)
        FfiConverterOptionString.write(value.textdomain, into: &buf)
    }
}


public func FfiConverterTypeSparsePlugin_lift(_ buf: RustBuffer) throws -> SparsePlugin {
    return try FfiConverterTypeSparsePlugin.lift(buf)
}

public func FfiConverterTypeSparsePlugin_lower(_ value: SparsePlugin) -> RustBuffer {
    return FfiConverterTypeSparsePlugin.lower(value)
}


public struct SparsePluginWithEditContext {
    public let plugin: PluginSlug?
    public let status: PluginStatus?
    public let name: String?
    public let pluginUri: String?
    public let author: String?
    public let authorUri: String?
    public let description: PluginDescription?
    public let version: String?
    public let networkOnly: Bool?
    public let requiresWp: String?
    public let requiresPhp: String?
    public let textdomain: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug?, status: PluginStatus?, name: String?, pluginUri: String?, author: String?, authorUri: String?, description: PluginDescription?, version: String?, networkOnly: Bool?, requiresWp: String?, requiresPhp: String?, textdomain: String?) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.pluginUri = pluginUri
        self.author = author
        self.authorUri = authorUri
        self.description = description
        self.version = version
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
        self.textdomain = textdomain
    }
}



extension SparsePluginWithEditContext: Equatable, Hashable {
    public static func ==(lhs: SparsePluginWithEditContext, rhs: SparsePluginWithEditContext) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pluginUri != rhs.pluginUri {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.authorUri != rhs.authorUri {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        if lhs.textdomain != rhs.textdomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(pluginUri)
        hasher.combine(author)
        hasher.combine(authorUri)
        hasher.combine(description)
        hasher.combine(version)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
        hasher.combine(textdomain)
    }
}


public struct FfiConverterTypeSparsePluginWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePluginWithEditContext {
        return
            try SparsePluginWithEditContext(
                plugin: FfiConverterOptionTypePluginSlug.read(from: &buf), 
                status: FfiConverterOptionTypePluginStatus.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                pluginUri: FfiConverterOptionString.read(from: &buf), 
                author: FfiConverterOptionString.read(from: &buf), 
                authorUri: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionTypePluginDescription.read(from: &buf), 
                version: FfiConverterOptionString.read(from: &buf), 
                networkOnly: FfiConverterOptionBool.read(from: &buf), 
                requiresWp: FfiConverterOptionString.read(from: &buf), 
                requiresPhp: FfiConverterOptionString.read(from: &buf), 
                textdomain: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePluginWithEditContext, into buf: inout [UInt8]) {
        FfiConverterOptionTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterOptionTypePluginStatus.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.pluginUri, into: &buf)
        FfiConverterOptionString.write(value.author, into: &buf)
        FfiConverterOptionString.write(value.authorUri, into: &buf)
        FfiConverterOptionTypePluginDescription.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.version, into: &buf)
        FfiConverterOptionBool.write(value.networkOnly, into: &buf)
        FfiConverterOptionString.write(value.requiresWp, into: &buf)
        FfiConverterOptionString.write(value.requiresPhp, into: &buf)
        FfiConverterOptionString.write(value.textdomain, into: &buf)
    }
}


public func FfiConverterTypeSparsePluginWithEditContext_lift(_ buf: RustBuffer) throws -> SparsePluginWithEditContext {
    return try FfiConverterTypeSparsePluginWithEditContext.lift(buf)
}

public func FfiConverterTypeSparsePluginWithEditContext_lower(_ value: SparsePluginWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparsePluginWithEditContext.lower(value)
}


public struct SparsePluginWithEmbedContext {
    public let plugin: PluginSlug?
    public let status: PluginStatus?
    public let name: String?
    public let networkOnly: Bool?
    public let requiresWp: String?
    public let requiresPhp: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug?, status: PluginStatus?, name: String?, networkOnly: Bool?, requiresWp: String?, requiresPhp: String?) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
    }
}



extension SparsePluginWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: SparsePluginWithEmbedContext, rhs: SparsePluginWithEmbedContext) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
    }
}


public struct FfiConverterTypeSparsePluginWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePluginWithEmbedContext {
        return
            try SparsePluginWithEmbedContext(
                plugin: FfiConverterOptionTypePluginSlug.read(from: &buf), 
                status: FfiConverterOptionTypePluginStatus.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                networkOnly: FfiConverterOptionBool.read(from: &buf), 
                requiresWp: FfiConverterOptionString.read(from: &buf), 
                requiresPhp: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePluginWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterOptionTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterOptionTypePluginStatus.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionBool.write(value.networkOnly, into: &buf)
        FfiConverterOptionString.write(value.requiresWp, into: &buf)
        FfiConverterOptionString.write(value.requiresPhp, into: &buf)
    }
}


public func FfiConverterTypeSparsePluginWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparsePluginWithEmbedContext {
    return try FfiConverterTypeSparsePluginWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparsePluginWithEmbedContext_lower(_ value: SparsePluginWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparsePluginWithEmbedContext.lower(value)
}


public struct SparsePluginWithViewContext {
    public let plugin: PluginSlug?
    public let status: PluginStatus?
    public let name: String?
    public let pluginUri: String?
    public let author: String?
    public let authorUri: String?
    public let description: PluginDescription?
    public let version: String?
    public let networkOnly: Bool?
    public let requiresWp: String?
    public let requiresPhp: String?
    public let textdomain: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug?, status: PluginStatus?, name: String?, pluginUri: String?, author: String?, authorUri: String?, description: PluginDescription?, version: String?, networkOnly: Bool?, requiresWp: String?, requiresPhp: String?, textdomain: String?) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.pluginUri = pluginUri
        self.author = author
        self.authorUri = authorUri
        self.description = description
        self.version = version
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
        self.textdomain = textdomain
    }
}



extension SparsePluginWithViewContext: Equatable, Hashable {
    public static func ==(lhs: SparsePluginWithViewContext, rhs: SparsePluginWithViewContext) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pluginUri != rhs.pluginUri {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.authorUri != rhs.authorUri {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        if lhs.textdomain != rhs.textdomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(pluginUri)
        hasher.combine(author)
        hasher.combine(authorUri)
        hasher.combine(description)
        hasher.combine(version)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
        hasher.combine(textdomain)
    }
}


public struct FfiConverterTypeSparsePluginWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePluginWithViewContext {
        return
            try SparsePluginWithViewContext(
                plugin: FfiConverterOptionTypePluginSlug.read(from: &buf), 
                status: FfiConverterOptionTypePluginStatus.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                pluginUri: FfiConverterOptionString.read(from: &buf), 
                author: FfiConverterOptionString.read(from: &buf), 
                authorUri: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionTypePluginDescription.read(from: &buf), 
                version: FfiConverterOptionString.read(from: &buf), 
                networkOnly: FfiConverterOptionBool.read(from: &buf), 
                requiresWp: FfiConverterOptionString.read(from: &buf), 
                requiresPhp: FfiConverterOptionString.read(from: &buf), 
                textdomain: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePluginWithViewContext, into buf: inout [UInt8]) {
        FfiConverterOptionTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterOptionTypePluginStatus.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.pluginUri, into: &buf)
        FfiConverterOptionString.write(value.author, into: &buf)
        FfiConverterOptionString.write(value.authorUri, into: &buf)
        FfiConverterOptionTypePluginDescription.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.version, into: &buf)
        FfiConverterOptionBool.write(value.networkOnly, into: &buf)
        FfiConverterOptionString.write(value.requiresWp, into: &buf)
        FfiConverterOptionString.write(value.requiresPhp, into: &buf)
        FfiConverterOptionString.write(value.textdomain, into: &buf)
    }
}


public func FfiConverterTypeSparsePluginWithViewContext_lift(_ buf: RustBuffer) throws -> SparsePluginWithViewContext {
    return try FfiConverterTypeSparsePluginWithViewContext.lift(buf)
}

public func FfiConverterTypeSparsePluginWithViewContext_lower(_ value: SparsePluginWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparsePluginWithViewContext.lower(value)
}


public struct SparsePostTypeDetails {
    public let capabilities: [PostTypeCapabilities: String]?
    public let description: String?
    public let hierarchical: Bool?
    public let viewable: Bool?
    public let labels: PostTypeLabels?
    public let name: String?
    public let slug: String?
    public let supports: [PostTypeSupports: Bool]?
    public let hasArchive: Bool?
    public let taxonomies: [String]?
    public let restBase: String?
    public let restNamespace: String?
    public let visibility: PostTypeVisibility?
    public let icon: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(capabilities: [PostTypeCapabilities: String]?, description: String?, hierarchical: Bool?, viewable: Bool?, labels: PostTypeLabels?, name: String?, slug: String?, supports: [PostTypeSupports: Bool]?, hasArchive: Bool?, taxonomies: [String]?, restBase: String?, restNamespace: String?, visibility: PostTypeVisibility?, icon: String?) {
        self.capabilities = capabilities
        self.description = description
        self.hierarchical = hierarchical
        self.viewable = viewable
        self.labels = labels
        self.name = name
        self.slug = slug
        self.supports = supports
        self.hasArchive = hasArchive
        self.taxonomies = taxonomies
        self.restBase = restBase
        self.restNamespace = restNamespace
        self.visibility = visibility
        self.icon = icon
    }
}



extension SparsePostTypeDetails: Equatable, Hashable {
    public static func ==(lhs: SparsePostTypeDetails, rhs: SparsePostTypeDetails) -> Bool {
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.hierarchical != rhs.hierarchical {
            return false
        }
        if lhs.viewable != rhs.viewable {
            return false
        }
        if lhs.labels != rhs.labels {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.supports != rhs.supports {
            return false
        }
        if lhs.hasArchive != rhs.hasArchive {
            return false
        }
        if lhs.taxonomies != rhs.taxonomies {
            return false
        }
        if lhs.restBase != rhs.restBase {
            return false
        }
        if lhs.restNamespace != rhs.restNamespace {
            return false
        }
        if lhs.visibility != rhs.visibility {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(capabilities)
        hasher.combine(description)
        hasher.combine(hierarchical)
        hasher.combine(viewable)
        hasher.combine(labels)
        hasher.combine(name)
        hasher.combine(slug)
        hasher.combine(supports)
        hasher.combine(hasArchive)
        hasher.combine(taxonomies)
        hasher.combine(restBase)
        hasher.combine(restNamespace)
        hasher.combine(visibility)
        hasher.combine(icon)
    }
}


public struct FfiConverterTypeSparsePostTypeDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypeDetails {
        return
            try SparsePostTypeDetails(
                capabilities: FfiConverterOptionDictionaryTypePostTypeCapabilitiesString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                hierarchical: FfiConverterOptionBool.read(from: &buf), 
                viewable: FfiConverterOptionBool.read(from: &buf), 
                labels: FfiConverterOptionTypePostTypeLabels.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                supports: FfiConverterOptionDictionaryTypePostTypeSupportsBool.read(from: &buf), 
                hasArchive: FfiConverterOptionBool.read(from: &buf), 
                taxonomies: FfiConverterOptionSequenceString.read(from: &buf), 
                restBase: FfiConverterOptionString.read(from: &buf), 
                restNamespace: FfiConverterOptionString.read(from: &buf), 
                visibility: FfiConverterOptionTypePostTypeVisibility.read(from: &buf), 
                icon: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePostTypeDetails, into buf: inout [UInt8]) {
        FfiConverterOptionDictionaryTypePostTypeCapabilitiesString.write(value.capabilities, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionBool.write(value.hierarchical, into: &buf)
        FfiConverterOptionBool.write(value.viewable, into: &buf)
        FfiConverterOptionTypePostTypeLabels.write(value.labels, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterOptionDictionaryTypePostTypeSupportsBool.write(value.supports, into: &buf)
        FfiConverterOptionBool.write(value.hasArchive, into: &buf)
        FfiConverterOptionSequenceString.write(value.taxonomies, into: &buf)
        FfiConverterOptionString.write(value.restBase, into: &buf)
        FfiConverterOptionString.write(value.restNamespace, into: &buf)
        FfiConverterOptionTypePostTypeVisibility.write(value.visibility, into: &buf)
        FfiConverterOptionString.write(value.icon, into: &buf)
    }
}


public func FfiConverterTypeSparsePostTypeDetails_lift(_ buf: RustBuffer) throws -> SparsePostTypeDetails {
    return try FfiConverterTypeSparsePostTypeDetails.lift(buf)
}

public func FfiConverterTypeSparsePostTypeDetails_lower(_ value: SparsePostTypeDetails) -> RustBuffer {
    return FfiConverterTypeSparsePostTypeDetails.lower(value)
}


public struct SparsePostTypeDetailsWithEditContext {
    public let capabilities: [PostTypeCapabilities: String]?
    public let description: String?
    public let hierarchical: Bool?
    public let viewable: Bool?
    public let labels: PostTypeLabels?
    public let name: String?
    public let slug: String?
    public let supports: [PostTypeSupports: Bool]?
    public let hasArchive: Bool?
    public let taxonomies: [String]?
    public let restBase: String?
    public let restNamespace: String?
    public let visibility: PostTypeVisibility?
    public let icon: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(capabilities: [PostTypeCapabilities: String]?, description: String?, hierarchical: Bool?, viewable: Bool?, labels: PostTypeLabels?, name: String?, slug: String?, supports: [PostTypeSupports: Bool]?, hasArchive: Bool?, taxonomies: [String]?, restBase: String?, restNamespace: String?, visibility: PostTypeVisibility?, icon: String?) {
        self.capabilities = capabilities
        self.description = description
        self.hierarchical = hierarchical
        self.viewable = viewable
        self.labels = labels
        self.name = name
        self.slug = slug
        self.supports = supports
        self.hasArchive = hasArchive
        self.taxonomies = taxonomies
        self.restBase = restBase
        self.restNamespace = restNamespace
        self.visibility = visibility
        self.icon = icon
    }
}



extension SparsePostTypeDetailsWithEditContext: Equatable, Hashable {
    public static func ==(lhs: SparsePostTypeDetailsWithEditContext, rhs: SparsePostTypeDetailsWithEditContext) -> Bool {
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.hierarchical != rhs.hierarchical {
            return false
        }
        if lhs.viewable != rhs.viewable {
            return false
        }
        if lhs.labels != rhs.labels {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.supports != rhs.supports {
            return false
        }
        if lhs.hasArchive != rhs.hasArchive {
            return false
        }
        if lhs.taxonomies != rhs.taxonomies {
            return false
        }
        if lhs.restBase != rhs.restBase {
            return false
        }
        if lhs.restNamespace != rhs.restNamespace {
            return false
        }
        if lhs.visibility != rhs.visibility {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(capabilities)
        hasher.combine(description)
        hasher.combine(hierarchical)
        hasher.combine(viewable)
        hasher.combine(labels)
        hasher.combine(name)
        hasher.combine(slug)
        hasher.combine(supports)
        hasher.combine(hasArchive)
        hasher.combine(taxonomies)
        hasher.combine(restBase)
        hasher.combine(restNamespace)
        hasher.combine(visibility)
        hasher.combine(icon)
    }
}


public struct FfiConverterTypeSparsePostTypeDetailsWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypeDetailsWithEditContext {
        return
            try SparsePostTypeDetailsWithEditContext(
                capabilities: FfiConverterOptionDictionaryTypePostTypeCapabilitiesString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                hierarchical: FfiConverterOptionBool.read(from: &buf), 
                viewable: FfiConverterOptionBool.read(from: &buf), 
                labels: FfiConverterOptionTypePostTypeLabels.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                supports: FfiConverterOptionDictionaryTypePostTypeSupportsBool.read(from: &buf), 
                hasArchive: FfiConverterOptionBool.read(from: &buf), 
                taxonomies: FfiConverterOptionSequenceString.read(from: &buf), 
                restBase: FfiConverterOptionString.read(from: &buf), 
                restNamespace: FfiConverterOptionString.read(from: &buf), 
                visibility: FfiConverterOptionTypePostTypeVisibility.read(from: &buf), 
                icon: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePostTypeDetailsWithEditContext, into buf: inout [UInt8]) {
        FfiConverterOptionDictionaryTypePostTypeCapabilitiesString.write(value.capabilities, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionBool.write(value.hierarchical, into: &buf)
        FfiConverterOptionBool.write(value.viewable, into: &buf)
        FfiConverterOptionTypePostTypeLabels.write(value.labels, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterOptionDictionaryTypePostTypeSupportsBool.write(value.supports, into: &buf)
        FfiConverterOptionBool.write(value.hasArchive, into: &buf)
        FfiConverterOptionSequenceString.write(value.taxonomies, into: &buf)
        FfiConverterOptionString.write(value.restBase, into: &buf)
        FfiConverterOptionString.write(value.restNamespace, into: &buf)
        FfiConverterOptionTypePostTypeVisibility.write(value.visibility, into: &buf)
        FfiConverterOptionString.write(value.icon, into: &buf)
    }
}


public func FfiConverterTypeSparsePostTypeDetailsWithEditContext_lift(_ buf: RustBuffer) throws -> SparsePostTypeDetailsWithEditContext {
    return try FfiConverterTypeSparsePostTypeDetailsWithEditContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypeDetailsWithEditContext_lower(_ value: SparsePostTypeDetailsWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypeDetailsWithEditContext.lower(value)
}


public struct SparsePostTypeDetailsWithEmbedContext {
    public let name: String?
    public let slug: String?
    public let restBase: String?
    public let restNamespace: String?
    public let icon: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, slug: String?, restBase: String?, restNamespace: String?, icon: String?) {
        self.name = name
        self.slug = slug
        self.restBase = restBase
        self.restNamespace = restNamespace
        self.icon = icon
    }
}



extension SparsePostTypeDetailsWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: SparsePostTypeDetailsWithEmbedContext, rhs: SparsePostTypeDetailsWithEmbedContext) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.restBase != rhs.restBase {
            return false
        }
        if lhs.restNamespace != rhs.restNamespace {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(slug)
        hasher.combine(restBase)
        hasher.combine(restNamespace)
        hasher.combine(icon)
    }
}


public struct FfiConverterTypeSparsePostTypeDetailsWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypeDetailsWithEmbedContext {
        return
            try SparsePostTypeDetailsWithEmbedContext(
                name: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                restBase: FfiConverterOptionString.read(from: &buf), 
                restNamespace: FfiConverterOptionString.read(from: &buf), 
                icon: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePostTypeDetailsWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterOptionString.write(value.restBase, into: &buf)
        FfiConverterOptionString.write(value.restNamespace, into: &buf)
        FfiConverterOptionString.write(value.icon, into: &buf)
    }
}


public func FfiConverterTypeSparsePostTypeDetailsWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparsePostTypeDetailsWithEmbedContext {
    return try FfiConverterTypeSparsePostTypeDetailsWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypeDetailsWithEmbedContext_lower(_ value: SparsePostTypeDetailsWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypeDetailsWithEmbedContext.lower(value)
}


public struct SparsePostTypeDetailsWithViewContext {
    public let description: String?
    public let hierarchical: Bool?
    public let name: String?
    public let slug: String?
    public let hasArchive: Bool?
    public let taxonomies: [String]?
    public let restBase: String?
    public let restNamespace: String?
    public let icon: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(description: String?, hierarchical: Bool?, name: String?, slug: String?, hasArchive: Bool?, taxonomies: [String]?, restBase: String?, restNamespace: String?, icon: String?) {
        self.description = description
        self.hierarchical = hierarchical
        self.name = name
        self.slug = slug
        self.hasArchive = hasArchive
        self.taxonomies = taxonomies
        self.restBase = restBase
        self.restNamespace = restNamespace
        self.icon = icon
    }
}



extension SparsePostTypeDetailsWithViewContext: Equatable, Hashable {
    public static func ==(lhs: SparsePostTypeDetailsWithViewContext, rhs: SparsePostTypeDetailsWithViewContext) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.hierarchical != rhs.hierarchical {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.hasArchive != rhs.hasArchive {
            return false
        }
        if lhs.taxonomies != rhs.taxonomies {
            return false
        }
        if lhs.restBase != rhs.restBase {
            return false
        }
        if lhs.restNamespace != rhs.restNamespace {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(hierarchical)
        hasher.combine(name)
        hasher.combine(slug)
        hasher.combine(hasArchive)
        hasher.combine(taxonomies)
        hasher.combine(restBase)
        hasher.combine(restNamespace)
        hasher.combine(icon)
    }
}


public struct FfiConverterTypeSparsePostTypeDetailsWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypeDetailsWithViewContext {
        return
            try SparsePostTypeDetailsWithViewContext(
                description: FfiConverterOptionString.read(from: &buf), 
                hierarchical: FfiConverterOptionBool.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                hasArchive: FfiConverterOptionBool.read(from: &buf), 
                taxonomies: FfiConverterOptionSequenceString.read(from: &buf), 
                restBase: FfiConverterOptionString.read(from: &buf), 
                restNamespace: FfiConverterOptionString.read(from: &buf), 
                icon: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePostTypeDetailsWithViewContext, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionBool.write(value.hierarchical, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterOptionBool.write(value.hasArchive, into: &buf)
        FfiConverterOptionSequenceString.write(value.taxonomies, into: &buf)
        FfiConverterOptionString.write(value.restBase, into: &buf)
        FfiConverterOptionString.write(value.restNamespace, into: &buf)
        FfiConverterOptionString.write(value.icon, into: &buf)
    }
}


public func FfiConverterTypeSparsePostTypeDetailsWithViewContext_lift(_ buf: RustBuffer) throws -> SparsePostTypeDetailsWithViewContext {
    return try FfiConverterTypeSparsePostTypeDetailsWithViewContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypeDetailsWithViewContext_lower(_ value: SparsePostTypeDetailsWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypeDetailsWithViewContext.lower(value)
}


public struct SparsePostTypesResponse {
    public let postTypes: [PostType: SparsePostTypeDetails]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(postTypes: [PostType: SparsePostTypeDetails]?) {
        self.postTypes = postTypes
    }
}



extension SparsePostTypesResponse: Equatable, Hashable {
    public static func ==(lhs: SparsePostTypesResponse, rhs: SparsePostTypesResponse) -> Bool {
        if lhs.postTypes != rhs.postTypes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(postTypes)
    }
}


public struct FfiConverterTypeSparsePostTypesResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypesResponse {
        return
            try SparsePostTypesResponse(
                postTypes: FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetails.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePostTypesResponse, into buf: inout [UInt8]) {
        FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetails.write(value.postTypes, into: &buf)
    }
}


public func FfiConverterTypeSparsePostTypesResponse_lift(_ buf: RustBuffer) throws -> SparsePostTypesResponse {
    return try FfiConverterTypeSparsePostTypesResponse.lift(buf)
}

public func FfiConverterTypeSparsePostTypesResponse_lower(_ value: SparsePostTypesResponse) -> RustBuffer {
    return FfiConverterTypeSparsePostTypesResponse.lower(value)
}


public struct SparsePostTypesResponseWithEditContext {
    public let postTypes: [PostType: SparsePostTypeDetailsWithEditContext]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(postTypes: [PostType: SparsePostTypeDetailsWithEditContext]?) {
        self.postTypes = postTypes
    }
}



extension SparsePostTypesResponseWithEditContext: Equatable, Hashable {
    public static func ==(lhs: SparsePostTypesResponseWithEditContext, rhs: SparsePostTypesResponseWithEditContext) -> Bool {
        if lhs.postTypes != rhs.postTypes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(postTypes)
    }
}


public struct FfiConverterTypeSparsePostTypesResponseWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypesResponseWithEditContext {
        return
            try SparsePostTypesResponseWithEditContext(
                postTypes: FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEditContext.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePostTypesResponseWithEditContext, into buf: inout [UInt8]) {
        FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEditContext.write(value.postTypes, into: &buf)
    }
}


public func FfiConverterTypeSparsePostTypesResponseWithEditContext_lift(_ buf: RustBuffer) throws -> SparsePostTypesResponseWithEditContext {
    return try FfiConverterTypeSparsePostTypesResponseWithEditContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypesResponseWithEditContext_lower(_ value: SparsePostTypesResponseWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypesResponseWithEditContext.lower(value)
}


public struct SparsePostTypesResponseWithEmbedContext {
    public let postTypes: [PostType: SparsePostTypeDetailsWithEmbedContext]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(postTypes: [PostType: SparsePostTypeDetailsWithEmbedContext]?) {
        self.postTypes = postTypes
    }
}



extension SparsePostTypesResponseWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: SparsePostTypesResponseWithEmbedContext, rhs: SparsePostTypesResponseWithEmbedContext) -> Bool {
        if lhs.postTypes != rhs.postTypes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(postTypes)
    }
}


public struct FfiConverterTypeSparsePostTypesResponseWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypesResponseWithEmbedContext {
        return
            try SparsePostTypesResponseWithEmbedContext(
                postTypes: FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEmbedContext.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePostTypesResponseWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEmbedContext.write(value.postTypes, into: &buf)
    }
}


public func FfiConverterTypeSparsePostTypesResponseWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparsePostTypesResponseWithEmbedContext {
    return try FfiConverterTypeSparsePostTypesResponseWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypesResponseWithEmbedContext_lower(_ value: SparsePostTypesResponseWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypesResponseWithEmbedContext.lower(value)
}


public struct SparsePostTypesResponseWithViewContext {
    public let postTypes: [PostType: SparsePostTypeDetailsWithViewContext]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(postTypes: [PostType: SparsePostTypeDetailsWithViewContext]?) {
        self.postTypes = postTypes
    }
}



extension SparsePostTypesResponseWithViewContext: Equatable, Hashable {
    public static func ==(lhs: SparsePostTypesResponseWithViewContext, rhs: SparsePostTypesResponseWithViewContext) -> Bool {
        if lhs.postTypes != rhs.postTypes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(postTypes)
    }
}


public struct FfiConverterTypeSparsePostTypesResponseWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypesResponseWithViewContext {
        return
            try SparsePostTypesResponseWithViewContext(
                postTypes: FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetailsWithViewContext.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePostTypesResponseWithViewContext, into buf: inout [UInt8]) {
        FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetailsWithViewContext.write(value.postTypes, into: &buf)
    }
}


public func FfiConverterTypeSparsePostTypesResponseWithViewContext_lift(_ buf: RustBuffer) throws -> SparsePostTypesResponseWithViewContext {
    return try FfiConverterTypeSparsePostTypesResponseWithViewContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypesResponseWithViewContext_lower(_ value: SparsePostTypesResponseWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypesResponseWithViewContext.lower(value)
}


public struct SparseSiteSettings {
    public let title: String?
    public let description: String?
    public let url: String?
    public let email: String?
    public let timezone: String?
    public let dateFormat: String?
    public let timeFormat: String?
    public let startOfWeek: UInt64?
    public let language: String?
    public let useSmilies: Bool?
    public let defaultCategory: UInt64?
    public let defaultPostFormat: String?
    public let postsPerPage: UInt64?
    public let showOnFront: String?
    public let pageOnFront: UInt64?
    public let pageForPosts: UInt64?
    public let defaultPingStatus: SiteSettingsPingStatus?
    public let defaultCommentStatus: SiteSettingsCommentStatus?
    public let siteLogo: UInt64?
    public let siteIcon: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String?, description: String?, url: String?, email: String?, timezone: String?, dateFormat: String?, timeFormat: String?, startOfWeek: UInt64?, language: String?, useSmilies: Bool?, defaultCategory: UInt64?, defaultPostFormat: String?, postsPerPage: UInt64?, showOnFront: String?, pageOnFront: UInt64?, pageForPosts: UInt64?, defaultPingStatus: SiteSettingsPingStatus?, defaultCommentStatus: SiteSettingsCommentStatus?, siteLogo: UInt64?, siteIcon: UInt64?) {
        self.title = title
        self.description = description
        self.url = url
        self.email = email
        self.timezone = timezone
        self.dateFormat = dateFormat
        self.timeFormat = timeFormat
        self.startOfWeek = startOfWeek
        self.language = language
        self.useSmilies = useSmilies
        self.defaultCategory = defaultCategory
        self.defaultPostFormat = defaultPostFormat
        self.postsPerPage = postsPerPage
        self.showOnFront = showOnFront
        self.pageOnFront = pageOnFront
        self.pageForPosts = pageForPosts
        self.defaultPingStatus = defaultPingStatus
        self.defaultCommentStatus = defaultCommentStatus
        self.siteLogo = siteLogo
        self.siteIcon = siteIcon
    }
}



extension SparseSiteSettings: Equatable, Hashable {
    public static func ==(lhs: SparseSiteSettings, rhs: SparseSiteSettings) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.timezone != rhs.timezone {
            return false
        }
        if lhs.dateFormat != rhs.dateFormat {
            return false
        }
        if lhs.timeFormat != rhs.timeFormat {
            return false
        }
        if lhs.startOfWeek != rhs.startOfWeek {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        if lhs.useSmilies != rhs.useSmilies {
            return false
        }
        if lhs.defaultCategory != rhs.defaultCategory {
            return false
        }
        if lhs.defaultPostFormat != rhs.defaultPostFormat {
            return false
        }
        if lhs.postsPerPage != rhs.postsPerPage {
            return false
        }
        if lhs.showOnFront != rhs.showOnFront {
            return false
        }
        if lhs.pageOnFront != rhs.pageOnFront {
            return false
        }
        if lhs.pageForPosts != rhs.pageForPosts {
            return false
        }
        if lhs.defaultPingStatus != rhs.defaultPingStatus {
            return false
        }
        if lhs.defaultCommentStatus != rhs.defaultCommentStatus {
            return false
        }
        if lhs.siteLogo != rhs.siteLogo {
            return false
        }
        if lhs.siteIcon != rhs.siteIcon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(email)
        hasher.combine(timezone)
        hasher.combine(dateFormat)
        hasher.combine(timeFormat)
        hasher.combine(startOfWeek)
        hasher.combine(language)
        hasher.combine(useSmilies)
        hasher.combine(defaultCategory)
        hasher.combine(defaultPostFormat)
        hasher.combine(postsPerPage)
        hasher.combine(showOnFront)
        hasher.combine(pageOnFront)
        hasher.combine(pageForPosts)
        hasher.combine(defaultPingStatus)
        hasher.combine(defaultCommentStatus)
        hasher.combine(siteLogo)
        hasher.combine(siteIcon)
    }
}


public struct FfiConverterTypeSparseSiteSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseSiteSettings {
        return
            try SparseSiteSettings(
                title: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                timezone: FfiConverterOptionString.read(from: &buf), 
                dateFormat: FfiConverterOptionString.read(from: &buf), 
                timeFormat: FfiConverterOptionString.read(from: &buf), 
                startOfWeek: FfiConverterOptionUInt64.read(from: &buf), 
                language: FfiConverterOptionString.read(from: &buf), 
                useSmilies: FfiConverterOptionBool.read(from: &buf), 
                defaultCategory: FfiConverterOptionUInt64.read(from: &buf), 
                defaultPostFormat: FfiConverterOptionString.read(from: &buf), 
                postsPerPage: FfiConverterOptionUInt64.read(from: &buf), 
                showOnFront: FfiConverterOptionString.read(from: &buf), 
                pageOnFront: FfiConverterOptionUInt64.read(from: &buf), 
                pageForPosts: FfiConverterOptionUInt64.read(from: &buf), 
                defaultPingStatus: FfiConverterOptionTypeSiteSettingsPingStatus.read(from: &buf), 
                defaultCommentStatus: FfiConverterOptionTypeSiteSettingsCommentStatus.read(from: &buf), 
                siteLogo: FfiConverterOptionUInt64.read(from: &buf), 
                siteIcon: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SparseSiteSettings, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.timezone, into: &buf)
        FfiConverterOptionString.write(value.dateFormat, into: &buf)
        FfiConverterOptionString.write(value.timeFormat, into: &buf)
        FfiConverterOptionUInt64.write(value.startOfWeek, into: &buf)
        FfiConverterOptionString.write(value.language, into: &buf)
        FfiConverterOptionBool.write(value.useSmilies, into: &buf)
        FfiConverterOptionUInt64.write(value.defaultCategory, into: &buf)
        FfiConverterOptionString.write(value.defaultPostFormat, into: &buf)
        FfiConverterOptionUInt64.write(value.postsPerPage, into: &buf)
        FfiConverterOptionString.write(value.showOnFront, into: &buf)
        FfiConverterOptionUInt64.write(value.pageOnFront, into: &buf)
        FfiConverterOptionUInt64.write(value.pageForPosts, into: &buf)
        FfiConverterOptionTypeSiteSettingsPingStatus.write(value.defaultPingStatus, into: &buf)
        FfiConverterOptionTypeSiteSettingsCommentStatus.write(value.defaultCommentStatus, into: &buf)
        FfiConverterOptionUInt64.write(value.siteLogo, into: &buf)
        FfiConverterOptionUInt64.write(value.siteIcon, into: &buf)
    }
}


public func FfiConverterTypeSparseSiteSettings_lift(_ buf: RustBuffer) throws -> SparseSiteSettings {
    return try FfiConverterTypeSparseSiteSettings.lift(buf)
}

public func FfiConverterTypeSparseSiteSettings_lower(_ value: SparseSiteSettings) -> RustBuffer {
    return FfiConverterTypeSparseSiteSettings.lower(value)
}


public struct SparseSiteSettingsWithEditContext {
    public let title: String?
    public let description: String?
    public let url: String?
    public let email: String?
    public let timezone: String?
    public let dateFormat: String?
    public let timeFormat: String?
    public let startOfWeek: UInt64?
    public let language: String?
    public let useSmilies: Bool?
    public let defaultCategory: UInt64?
    public let defaultPostFormat: String?
    public let postsPerPage: UInt64?
    public let showOnFront: String?
    public let pageOnFront: UInt64?
    public let pageForPosts: UInt64?
    public let defaultPingStatus: SiteSettingsPingStatus?
    public let defaultCommentStatus: SiteSettingsCommentStatus?
    public let siteLogo: UInt64?
    public let siteIcon: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String?, description: String?, url: String?, email: String?, timezone: String?, dateFormat: String?, timeFormat: String?, startOfWeek: UInt64?, language: String?, useSmilies: Bool?, defaultCategory: UInt64?, defaultPostFormat: String?, postsPerPage: UInt64?, showOnFront: String?, pageOnFront: UInt64?, pageForPosts: UInt64?, defaultPingStatus: SiteSettingsPingStatus?, defaultCommentStatus: SiteSettingsCommentStatus?, siteLogo: UInt64?, siteIcon: UInt64?) {
        self.title = title
        self.description = description
        self.url = url
        self.email = email
        self.timezone = timezone
        self.dateFormat = dateFormat
        self.timeFormat = timeFormat
        self.startOfWeek = startOfWeek
        self.language = language
        self.useSmilies = useSmilies
        self.defaultCategory = defaultCategory
        self.defaultPostFormat = defaultPostFormat
        self.postsPerPage = postsPerPage
        self.showOnFront = showOnFront
        self.pageOnFront = pageOnFront
        self.pageForPosts = pageForPosts
        self.defaultPingStatus = defaultPingStatus
        self.defaultCommentStatus = defaultCommentStatus
        self.siteLogo = siteLogo
        self.siteIcon = siteIcon
    }
}



extension SparseSiteSettingsWithEditContext: Equatable, Hashable {
    public static func ==(lhs: SparseSiteSettingsWithEditContext, rhs: SparseSiteSettingsWithEditContext) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.timezone != rhs.timezone {
            return false
        }
        if lhs.dateFormat != rhs.dateFormat {
            return false
        }
        if lhs.timeFormat != rhs.timeFormat {
            return false
        }
        if lhs.startOfWeek != rhs.startOfWeek {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        if lhs.useSmilies != rhs.useSmilies {
            return false
        }
        if lhs.defaultCategory != rhs.defaultCategory {
            return false
        }
        if lhs.defaultPostFormat != rhs.defaultPostFormat {
            return false
        }
        if lhs.postsPerPage != rhs.postsPerPage {
            return false
        }
        if lhs.showOnFront != rhs.showOnFront {
            return false
        }
        if lhs.pageOnFront != rhs.pageOnFront {
            return false
        }
        if lhs.pageForPosts != rhs.pageForPosts {
            return false
        }
        if lhs.defaultPingStatus != rhs.defaultPingStatus {
            return false
        }
        if lhs.defaultCommentStatus != rhs.defaultCommentStatus {
            return false
        }
        if lhs.siteLogo != rhs.siteLogo {
            return false
        }
        if lhs.siteIcon != rhs.siteIcon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(email)
        hasher.combine(timezone)
        hasher.combine(dateFormat)
        hasher.combine(timeFormat)
        hasher.combine(startOfWeek)
        hasher.combine(language)
        hasher.combine(useSmilies)
        hasher.combine(defaultCategory)
        hasher.combine(defaultPostFormat)
        hasher.combine(postsPerPage)
        hasher.combine(showOnFront)
        hasher.combine(pageOnFront)
        hasher.combine(pageForPosts)
        hasher.combine(defaultPingStatus)
        hasher.combine(defaultCommentStatus)
        hasher.combine(siteLogo)
        hasher.combine(siteIcon)
    }
}


public struct FfiConverterTypeSparseSiteSettingsWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseSiteSettingsWithEditContext {
        return
            try SparseSiteSettingsWithEditContext(
                title: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                timezone: FfiConverterOptionString.read(from: &buf), 
                dateFormat: FfiConverterOptionString.read(from: &buf), 
                timeFormat: FfiConverterOptionString.read(from: &buf), 
                startOfWeek: FfiConverterOptionUInt64.read(from: &buf), 
                language: FfiConverterOptionString.read(from: &buf), 
                useSmilies: FfiConverterOptionBool.read(from: &buf), 
                defaultCategory: FfiConverterOptionUInt64.read(from: &buf), 
                defaultPostFormat: FfiConverterOptionString.read(from: &buf), 
                postsPerPage: FfiConverterOptionUInt64.read(from: &buf), 
                showOnFront: FfiConverterOptionString.read(from: &buf), 
                pageOnFront: FfiConverterOptionUInt64.read(from: &buf), 
                pageForPosts: FfiConverterOptionUInt64.read(from: &buf), 
                defaultPingStatus: FfiConverterOptionTypeSiteSettingsPingStatus.read(from: &buf), 
                defaultCommentStatus: FfiConverterOptionTypeSiteSettingsCommentStatus.read(from: &buf), 
                siteLogo: FfiConverterOptionUInt64.read(from: &buf), 
                siteIcon: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SparseSiteSettingsWithEditContext, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.timezone, into: &buf)
        FfiConverterOptionString.write(value.dateFormat, into: &buf)
        FfiConverterOptionString.write(value.timeFormat, into: &buf)
        FfiConverterOptionUInt64.write(value.startOfWeek, into: &buf)
        FfiConverterOptionString.write(value.language, into: &buf)
        FfiConverterOptionBool.write(value.useSmilies, into: &buf)
        FfiConverterOptionUInt64.write(value.defaultCategory, into: &buf)
        FfiConverterOptionString.write(value.defaultPostFormat, into: &buf)
        FfiConverterOptionUInt64.write(value.postsPerPage, into: &buf)
        FfiConverterOptionString.write(value.showOnFront, into: &buf)
        FfiConverterOptionUInt64.write(value.pageOnFront, into: &buf)
        FfiConverterOptionUInt64.write(value.pageForPosts, into: &buf)
        FfiConverterOptionTypeSiteSettingsPingStatus.write(value.defaultPingStatus, into: &buf)
        FfiConverterOptionTypeSiteSettingsCommentStatus.write(value.defaultCommentStatus, into: &buf)
        FfiConverterOptionUInt64.write(value.siteLogo, into: &buf)
        FfiConverterOptionUInt64.write(value.siteIcon, into: &buf)
    }
}


public func FfiConverterTypeSparseSiteSettingsWithEditContext_lift(_ buf: RustBuffer) throws -> SparseSiteSettingsWithEditContext {
    return try FfiConverterTypeSparseSiteSettingsWithEditContext.lift(buf)
}

public func FfiConverterTypeSparseSiteSettingsWithEditContext_lower(_ value: SparseSiteSettingsWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparseSiteSettingsWithEditContext.lower(value)
}


public struct SparseSiteSettingsWithEmbedContext {
    public let title: String?
    public let description: String?
    public let url: String?
    public let email: String?
    public let timezone: String?
    public let dateFormat: String?
    public let timeFormat: String?
    public let startOfWeek: UInt64?
    public let language: String?
    public let useSmilies: Bool?
    public let defaultCategory: UInt64?
    public let defaultPostFormat: String?
    public let postsPerPage: UInt64?
    public let showOnFront: String?
    public let pageOnFront: UInt64?
    public let pageForPosts: UInt64?
    public let defaultPingStatus: SiteSettingsPingStatus?
    public let defaultCommentStatus: SiteSettingsCommentStatus?
    public let siteLogo: UInt64?
    public let siteIcon: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String?, description: String?, url: String?, email: String?, timezone: String?, dateFormat: String?, timeFormat: String?, startOfWeek: UInt64?, language: String?, useSmilies: Bool?, defaultCategory: UInt64?, defaultPostFormat: String?, postsPerPage: UInt64?, showOnFront: String?, pageOnFront: UInt64?, pageForPosts: UInt64?, defaultPingStatus: SiteSettingsPingStatus?, defaultCommentStatus: SiteSettingsCommentStatus?, siteLogo: UInt64?, siteIcon: UInt64?) {
        self.title = title
        self.description = description
        self.url = url
        self.email = email
        self.timezone = timezone
        self.dateFormat = dateFormat
        self.timeFormat = timeFormat
        self.startOfWeek = startOfWeek
        self.language = language
        self.useSmilies = useSmilies
        self.defaultCategory = defaultCategory
        self.defaultPostFormat = defaultPostFormat
        self.postsPerPage = postsPerPage
        self.showOnFront = showOnFront
        self.pageOnFront = pageOnFront
        self.pageForPosts = pageForPosts
        self.defaultPingStatus = defaultPingStatus
        self.defaultCommentStatus = defaultCommentStatus
        self.siteLogo = siteLogo
        self.siteIcon = siteIcon
    }
}



extension SparseSiteSettingsWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: SparseSiteSettingsWithEmbedContext, rhs: SparseSiteSettingsWithEmbedContext) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.timezone != rhs.timezone {
            return false
        }
        if lhs.dateFormat != rhs.dateFormat {
            return false
        }
        if lhs.timeFormat != rhs.timeFormat {
            return false
        }
        if lhs.startOfWeek != rhs.startOfWeek {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        if lhs.useSmilies != rhs.useSmilies {
            return false
        }
        if lhs.defaultCategory != rhs.defaultCategory {
            return false
        }
        if lhs.defaultPostFormat != rhs.defaultPostFormat {
            return false
        }
        if lhs.postsPerPage != rhs.postsPerPage {
            return false
        }
        if lhs.showOnFront != rhs.showOnFront {
            return false
        }
        if lhs.pageOnFront != rhs.pageOnFront {
            return false
        }
        if lhs.pageForPosts != rhs.pageForPosts {
            return false
        }
        if lhs.defaultPingStatus != rhs.defaultPingStatus {
            return false
        }
        if lhs.defaultCommentStatus != rhs.defaultCommentStatus {
            return false
        }
        if lhs.siteLogo != rhs.siteLogo {
            return false
        }
        if lhs.siteIcon != rhs.siteIcon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(email)
        hasher.combine(timezone)
        hasher.combine(dateFormat)
        hasher.combine(timeFormat)
        hasher.combine(startOfWeek)
        hasher.combine(language)
        hasher.combine(useSmilies)
        hasher.combine(defaultCategory)
        hasher.combine(defaultPostFormat)
        hasher.combine(postsPerPage)
        hasher.combine(showOnFront)
        hasher.combine(pageOnFront)
        hasher.combine(pageForPosts)
        hasher.combine(defaultPingStatus)
        hasher.combine(defaultCommentStatus)
        hasher.combine(siteLogo)
        hasher.combine(siteIcon)
    }
}


public struct FfiConverterTypeSparseSiteSettingsWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseSiteSettingsWithEmbedContext {
        return
            try SparseSiteSettingsWithEmbedContext(
                title: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                timezone: FfiConverterOptionString.read(from: &buf), 
                dateFormat: FfiConverterOptionString.read(from: &buf), 
                timeFormat: FfiConverterOptionString.read(from: &buf), 
                startOfWeek: FfiConverterOptionUInt64.read(from: &buf), 
                language: FfiConverterOptionString.read(from: &buf), 
                useSmilies: FfiConverterOptionBool.read(from: &buf), 
                defaultCategory: FfiConverterOptionUInt64.read(from: &buf), 
                defaultPostFormat: FfiConverterOptionString.read(from: &buf), 
                postsPerPage: FfiConverterOptionUInt64.read(from: &buf), 
                showOnFront: FfiConverterOptionString.read(from: &buf), 
                pageOnFront: FfiConverterOptionUInt64.read(from: &buf), 
                pageForPosts: FfiConverterOptionUInt64.read(from: &buf), 
                defaultPingStatus: FfiConverterOptionTypeSiteSettingsPingStatus.read(from: &buf), 
                defaultCommentStatus: FfiConverterOptionTypeSiteSettingsCommentStatus.read(from: &buf), 
                siteLogo: FfiConverterOptionUInt64.read(from: &buf), 
                siteIcon: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SparseSiteSettingsWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.timezone, into: &buf)
        FfiConverterOptionString.write(value.dateFormat, into: &buf)
        FfiConverterOptionString.write(value.timeFormat, into: &buf)
        FfiConverterOptionUInt64.write(value.startOfWeek, into: &buf)
        FfiConverterOptionString.write(value.language, into: &buf)
        FfiConverterOptionBool.write(value.useSmilies, into: &buf)
        FfiConverterOptionUInt64.write(value.defaultCategory, into: &buf)
        FfiConverterOptionString.write(value.defaultPostFormat, into: &buf)
        FfiConverterOptionUInt64.write(value.postsPerPage, into: &buf)
        FfiConverterOptionString.write(value.showOnFront, into: &buf)
        FfiConverterOptionUInt64.write(value.pageOnFront, into: &buf)
        FfiConverterOptionUInt64.write(value.pageForPosts, into: &buf)
        FfiConverterOptionTypeSiteSettingsPingStatus.write(value.defaultPingStatus, into: &buf)
        FfiConverterOptionTypeSiteSettingsCommentStatus.write(value.defaultCommentStatus, into: &buf)
        FfiConverterOptionUInt64.write(value.siteLogo, into: &buf)
        FfiConverterOptionUInt64.write(value.siteIcon, into: &buf)
    }
}


public func FfiConverterTypeSparseSiteSettingsWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparseSiteSettingsWithEmbedContext {
    return try FfiConverterTypeSparseSiteSettingsWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparseSiteSettingsWithEmbedContext_lower(_ value: SparseSiteSettingsWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparseSiteSettingsWithEmbedContext.lower(value)
}


public struct SparseSiteSettingsWithViewContext {
    public let title: String?
    public let description: String?
    public let url: String?
    public let email: String?
    public let timezone: String?
    public let dateFormat: String?
    public let timeFormat: String?
    public let startOfWeek: UInt64?
    public let language: String?
    public let useSmilies: Bool?
    public let defaultCategory: UInt64?
    public let defaultPostFormat: String?
    public let postsPerPage: UInt64?
    public let showOnFront: String?
    public let pageOnFront: UInt64?
    public let pageForPosts: UInt64?
    public let defaultPingStatus: SiteSettingsPingStatus?
    public let defaultCommentStatus: SiteSettingsCommentStatus?
    public let siteLogo: UInt64?
    public let siteIcon: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String?, description: String?, url: String?, email: String?, timezone: String?, dateFormat: String?, timeFormat: String?, startOfWeek: UInt64?, language: String?, useSmilies: Bool?, defaultCategory: UInt64?, defaultPostFormat: String?, postsPerPage: UInt64?, showOnFront: String?, pageOnFront: UInt64?, pageForPosts: UInt64?, defaultPingStatus: SiteSettingsPingStatus?, defaultCommentStatus: SiteSettingsCommentStatus?, siteLogo: UInt64?, siteIcon: UInt64?) {
        self.title = title
        self.description = description
        self.url = url
        self.email = email
        self.timezone = timezone
        self.dateFormat = dateFormat
        self.timeFormat = timeFormat
        self.startOfWeek = startOfWeek
        self.language = language
        self.useSmilies = useSmilies
        self.defaultCategory = defaultCategory
        self.defaultPostFormat = defaultPostFormat
        self.postsPerPage = postsPerPage
        self.showOnFront = showOnFront
        self.pageOnFront = pageOnFront
        self.pageForPosts = pageForPosts
        self.defaultPingStatus = defaultPingStatus
        self.defaultCommentStatus = defaultCommentStatus
        self.siteLogo = siteLogo
        self.siteIcon = siteIcon
    }
}



extension SparseSiteSettingsWithViewContext: Equatable, Hashable {
    public static func ==(lhs: SparseSiteSettingsWithViewContext, rhs: SparseSiteSettingsWithViewContext) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.timezone != rhs.timezone {
            return false
        }
        if lhs.dateFormat != rhs.dateFormat {
            return false
        }
        if lhs.timeFormat != rhs.timeFormat {
            return false
        }
        if lhs.startOfWeek != rhs.startOfWeek {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        if lhs.useSmilies != rhs.useSmilies {
            return false
        }
        if lhs.defaultCategory != rhs.defaultCategory {
            return false
        }
        if lhs.defaultPostFormat != rhs.defaultPostFormat {
            return false
        }
        if lhs.postsPerPage != rhs.postsPerPage {
            return false
        }
        if lhs.showOnFront != rhs.showOnFront {
            return false
        }
        if lhs.pageOnFront != rhs.pageOnFront {
            return false
        }
        if lhs.pageForPosts != rhs.pageForPosts {
            return false
        }
        if lhs.defaultPingStatus != rhs.defaultPingStatus {
            return false
        }
        if lhs.defaultCommentStatus != rhs.defaultCommentStatus {
            return false
        }
        if lhs.siteLogo != rhs.siteLogo {
            return false
        }
        if lhs.siteIcon != rhs.siteIcon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(description)
        hasher.combine(url)
        hasher.combine(email)
        hasher.combine(timezone)
        hasher.combine(dateFormat)
        hasher.combine(timeFormat)
        hasher.combine(startOfWeek)
        hasher.combine(language)
        hasher.combine(useSmilies)
        hasher.combine(defaultCategory)
        hasher.combine(defaultPostFormat)
        hasher.combine(postsPerPage)
        hasher.combine(showOnFront)
        hasher.combine(pageOnFront)
        hasher.combine(pageForPosts)
        hasher.combine(defaultPingStatus)
        hasher.combine(defaultCommentStatus)
        hasher.combine(siteLogo)
        hasher.combine(siteIcon)
    }
}


public struct FfiConverterTypeSparseSiteSettingsWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseSiteSettingsWithViewContext {
        return
            try SparseSiteSettingsWithViewContext(
                title: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                timezone: FfiConverterOptionString.read(from: &buf), 
                dateFormat: FfiConverterOptionString.read(from: &buf), 
                timeFormat: FfiConverterOptionString.read(from: &buf), 
                startOfWeek: FfiConverterOptionUInt64.read(from: &buf), 
                language: FfiConverterOptionString.read(from: &buf), 
                useSmilies: FfiConverterOptionBool.read(from: &buf), 
                defaultCategory: FfiConverterOptionUInt64.read(from: &buf), 
                defaultPostFormat: FfiConverterOptionString.read(from: &buf), 
                postsPerPage: FfiConverterOptionUInt64.read(from: &buf), 
                showOnFront: FfiConverterOptionString.read(from: &buf), 
                pageOnFront: FfiConverterOptionUInt64.read(from: &buf), 
                pageForPosts: FfiConverterOptionUInt64.read(from: &buf), 
                defaultPingStatus: FfiConverterOptionTypeSiteSettingsPingStatus.read(from: &buf), 
                defaultCommentStatus: FfiConverterOptionTypeSiteSettingsCommentStatus.read(from: &buf), 
                siteLogo: FfiConverterOptionUInt64.read(from: &buf), 
                siteIcon: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SparseSiteSettingsWithViewContext, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.timezone, into: &buf)
        FfiConverterOptionString.write(value.dateFormat, into: &buf)
        FfiConverterOptionString.write(value.timeFormat, into: &buf)
        FfiConverterOptionUInt64.write(value.startOfWeek, into: &buf)
        FfiConverterOptionString.write(value.language, into: &buf)
        FfiConverterOptionBool.write(value.useSmilies, into: &buf)
        FfiConverterOptionUInt64.write(value.defaultCategory, into: &buf)
        FfiConverterOptionString.write(value.defaultPostFormat, into: &buf)
        FfiConverterOptionUInt64.write(value.postsPerPage, into: &buf)
        FfiConverterOptionString.write(value.showOnFront, into: &buf)
        FfiConverterOptionUInt64.write(value.pageOnFront, into: &buf)
        FfiConverterOptionUInt64.write(value.pageForPosts, into: &buf)
        FfiConverterOptionTypeSiteSettingsPingStatus.write(value.defaultPingStatus, into: &buf)
        FfiConverterOptionTypeSiteSettingsCommentStatus.write(value.defaultCommentStatus, into: &buf)
        FfiConverterOptionUInt64.write(value.siteLogo, into: &buf)
        FfiConverterOptionUInt64.write(value.siteIcon, into: &buf)
    }
}


public func FfiConverterTypeSparseSiteSettingsWithViewContext_lift(_ buf: RustBuffer) throws -> SparseSiteSettingsWithViewContext {
    return try FfiConverterTypeSparseSiteSettingsWithViewContext.lift(buf)
}

public func FfiConverterTypeSparseSiteSettingsWithViewContext_lower(_ value: SparseSiteSettingsWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparseSiteSettingsWithViewContext.lower(value)
}


public struct SparseUser {
    public let id: UserId?
    public let username: String?
    public let name: String?
    public let firstName: String?
    public let lastName: String?
    public let email: String?
    public let url: String?
    public let description: String?
    public let link: String?
    public let locale: String?
    public let nickname: String?
    public let slug: String?
    public let registeredDate: String?
    public let roles: [String]?
    public let capabilities: [String: Bool]?
    public let extraCapabilities: [String: Bool]?
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId?, username: String?, name: String?, firstName: String?, lastName: String?, email: String?, url: String?, description: String?, link: String?, locale: String?, nickname: String?, slug: String?, registeredDate: String?, roles: [String]?, capabilities: [String: Bool]?, extraCapabilities: [String: Bool]?, avatarUrls: [String: String]?) {
        self.id = id
        self.username = username
        self.name = name
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.url = url
        self.description = description
        self.link = link
        self.locale = locale
        self.nickname = nickname
        self.slug = slug
        self.registeredDate = registeredDate
        self.roles = roles
        self.capabilities = capabilities
        self.extraCapabilities = extraCapabilities
        self.avatarUrls = avatarUrls
    }
}



extension SparseUser: Equatable, Hashable {
    public static func ==(lhs: SparseUser, rhs: SparseUser) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.registeredDate != rhs.registeredDate {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        if lhs.extraCapabilities != rhs.extraCapabilities {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(username)
        hasher.combine(name)
        hasher.combine(firstName)
        hasher.combine(lastName)
        hasher.combine(email)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(locale)
        hasher.combine(nickname)
        hasher.combine(slug)
        hasher.combine(registeredDate)
        hasher.combine(roles)
        hasher.combine(capabilities)
        hasher.combine(extraCapabilities)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeSparseUser: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseUser {
        return
            try SparseUser(
                id: FfiConverterOptionTypeUserId.read(from: &buf), 
                username: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                firstName: FfiConverterOptionString.read(from: &buf), 
                lastName: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                link: FfiConverterOptionString.read(from: &buf), 
                locale: FfiConverterOptionString.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                registeredDate: FfiConverterOptionString.read(from: &buf), 
                roles: FfiConverterOptionSequenceString.read(from: &buf), 
                capabilities: FfiConverterOptionDictionaryStringBool.read(from: &buf), 
                extraCapabilities: FfiConverterOptionDictionaryStringBool.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: SparseUser, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUserId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.firstName, into: &buf)
        FfiConverterOptionString.write(value.lastName, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.link, into: &buf)
        FfiConverterOptionString.write(value.locale, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterOptionString.write(value.registeredDate, into: &buf)
        FfiConverterOptionSequenceString.write(value.roles, into: &buf)
        FfiConverterOptionDictionaryStringBool.write(value.capabilities, into: &buf)
        FfiConverterOptionDictionaryStringBool.write(value.extraCapabilities, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeSparseUser_lift(_ buf: RustBuffer) throws -> SparseUser {
    return try FfiConverterTypeSparseUser.lift(buf)
}

public func FfiConverterTypeSparseUser_lower(_ value: SparseUser) -> RustBuffer {
    return FfiConverterTypeSparseUser.lower(value)
}


public struct SparseUserWithEditContext {
    public let id: UserId?
    public let username: String?
    public let name: String?
    public let firstName: String?
    public let lastName: String?
    public let email: String?
    public let url: String?
    public let description: String?
    public let link: String?
    public let locale: String?
    public let nickname: String?
    public let slug: String?
    public let registeredDate: String?
    public let roles: [String]?
    public let capabilities: [String: Bool]?
    public let extraCapabilities: [String: Bool]?
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId?, username: String?, name: String?, firstName: String?, lastName: String?, email: String?, url: String?, description: String?, link: String?, locale: String?, nickname: String?, slug: String?, registeredDate: String?, roles: [String]?, capabilities: [String: Bool]?, extraCapabilities: [String: Bool]?, avatarUrls: [String: String]?) {
        self.id = id
        self.username = username
        self.name = name
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.url = url
        self.description = description
        self.link = link
        self.locale = locale
        self.nickname = nickname
        self.slug = slug
        self.registeredDate = registeredDate
        self.roles = roles
        self.capabilities = capabilities
        self.extraCapabilities = extraCapabilities
        self.avatarUrls = avatarUrls
    }
}



extension SparseUserWithEditContext: Equatable, Hashable {
    public static func ==(lhs: SparseUserWithEditContext, rhs: SparseUserWithEditContext) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.registeredDate != rhs.registeredDate {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        if lhs.extraCapabilities != rhs.extraCapabilities {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(username)
        hasher.combine(name)
        hasher.combine(firstName)
        hasher.combine(lastName)
        hasher.combine(email)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(locale)
        hasher.combine(nickname)
        hasher.combine(slug)
        hasher.combine(registeredDate)
        hasher.combine(roles)
        hasher.combine(capabilities)
        hasher.combine(extraCapabilities)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeSparseUserWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseUserWithEditContext {
        return
            try SparseUserWithEditContext(
                id: FfiConverterOptionTypeUserId.read(from: &buf), 
                username: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                firstName: FfiConverterOptionString.read(from: &buf), 
                lastName: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                link: FfiConverterOptionString.read(from: &buf), 
                locale: FfiConverterOptionString.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                registeredDate: FfiConverterOptionString.read(from: &buf), 
                roles: FfiConverterOptionSequenceString.read(from: &buf), 
                capabilities: FfiConverterOptionDictionaryStringBool.read(from: &buf), 
                extraCapabilities: FfiConverterOptionDictionaryStringBool.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: SparseUserWithEditContext, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUserId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.firstName, into: &buf)
        FfiConverterOptionString.write(value.lastName, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.link, into: &buf)
        FfiConverterOptionString.write(value.locale, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterOptionString.write(value.registeredDate, into: &buf)
        FfiConverterOptionSequenceString.write(value.roles, into: &buf)
        FfiConverterOptionDictionaryStringBool.write(value.capabilities, into: &buf)
        FfiConverterOptionDictionaryStringBool.write(value.extraCapabilities, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeSparseUserWithEditContext_lift(_ buf: RustBuffer) throws -> SparseUserWithEditContext {
    return try FfiConverterTypeSparseUserWithEditContext.lift(buf)
}

public func FfiConverterTypeSparseUserWithEditContext_lower(_ value: SparseUserWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparseUserWithEditContext.lower(value)
}


public struct SparseUserWithEmbedContext {
    public let id: UserId?
    public let name: String?
    public let url: String?
    public let description: String?
    public let link: String?
    public let slug: String?
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId?, name: String?, url: String?, description: String?, link: String?, slug: String?, avatarUrls: [String: String]?) {
        self.id = id
        self.name = name
        self.url = url
        self.description = description
        self.link = link
        self.slug = slug
        self.avatarUrls = avatarUrls
    }
}



extension SparseUserWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: SparseUserWithEmbedContext, rhs: SparseUserWithEmbedContext) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(slug)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeSparseUserWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseUserWithEmbedContext {
        return
            try SparseUserWithEmbedContext(
                id: FfiConverterOptionTypeUserId.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                link: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: SparseUserWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUserId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.link, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeSparseUserWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparseUserWithEmbedContext {
    return try FfiConverterTypeSparseUserWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparseUserWithEmbedContext_lower(_ value: SparseUserWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparseUserWithEmbedContext.lower(value)
}


public struct SparseUserWithViewContext {
    public let id: UserId?
    public let name: String?
    public let url: String?
    public let description: String?
    public let link: String?
    public let slug: String?
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId?, name: String?, url: String?, description: String?, link: String?, slug: String?, avatarUrls: [String: String]?) {
        self.id = id
        self.name = name
        self.url = url
        self.description = description
        self.link = link
        self.slug = slug
        self.avatarUrls = avatarUrls
    }
}



extension SparseUserWithViewContext: Equatable, Hashable {
    public static func ==(lhs: SparseUserWithViewContext, rhs: SparseUserWithViewContext) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(slug)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeSparseUserWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseUserWithViewContext {
        return
            try SparseUserWithViewContext(
                id: FfiConverterOptionTypeUserId.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                link: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: SparseUserWithViewContext, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUserId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.link, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeSparseUserWithViewContext_lift(_ buf: RustBuffer) throws -> SparseUserWithViewContext {
    return try FfiConverterTypeSparseUserWithViewContext.lift(buf)
}

public func FfiConverterTypeSparseUserWithViewContext_lower(_ value: SparseUserWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparseUserWithViewContext.lower(value)
}


public struct SparseWpSiteHealthDirectorySizes {
    public let databaseSize: WpSiteHealthDirectorySizeInfo?
    public let fontsSize: WpSiteHealthDirectorySizeInfo?
    public let pluginsSize: WpSiteHealthDirectorySizeInfo?
    public let themesSize: WpSiteHealthDirectorySizeInfo?
    public let totalSize: WpSiteHealthDirectorySizeInfo?
    public let uploadsSize: WpSiteHealthDirectorySizeInfo?
    public let wordpressSize: WpSiteHealthDirectorySizeInfo?
    public let raw: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(databaseSize: WpSiteHealthDirectorySizeInfo?, fontsSize: WpSiteHealthDirectorySizeInfo?, pluginsSize: WpSiteHealthDirectorySizeInfo?, themesSize: WpSiteHealthDirectorySizeInfo?, totalSize: WpSiteHealthDirectorySizeInfo?, uploadsSize: WpSiteHealthDirectorySizeInfo?, wordpressSize: WpSiteHealthDirectorySizeInfo?, raw: UInt64?) {
        self.databaseSize = databaseSize
        self.fontsSize = fontsSize
        self.pluginsSize = pluginsSize
        self.themesSize = themesSize
        self.totalSize = totalSize
        self.uploadsSize = uploadsSize
        self.wordpressSize = wordpressSize
        self.raw = raw
    }
}



extension SparseWpSiteHealthDirectorySizes: Equatable, Hashable {
    public static func ==(lhs: SparseWpSiteHealthDirectorySizes, rhs: SparseWpSiteHealthDirectorySizes) -> Bool {
        if lhs.databaseSize != rhs.databaseSize {
            return false
        }
        if lhs.fontsSize != rhs.fontsSize {
            return false
        }
        if lhs.pluginsSize != rhs.pluginsSize {
            return false
        }
        if lhs.themesSize != rhs.themesSize {
            return false
        }
        if lhs.totalSize != rhs.totalSize {
            return false
        }
        if lhs.uploadsSize != rhs.uploadsSize {
            return false
        }
        if lhs.wordpressSize != rhs.wordpressSize {
            return false
        }
        if lhs.raw != rhs.raw {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(databaseSize)
        hasher.combine(fontsSize)
        hasher.combine(pluginsSize)
        hasher.combine(themesSize)
        hasher.combine(totalSize)
        hasher.combine(uploadsSize)
        hasher.combine(wordpressSize)
        hasher.combine(raw)
    }
}


public struct FfiConverterTypeSparseWpSiteHealthDirectorySizes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseWpSiteHealthDirectorySizes {
        return
            try SparseWpSiteHealthDirectorySizes(
                databaseSize: FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                fontsSize: FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                pluginsSize: FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                themesSize: FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                totalSize: FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                uploadsSize: FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                wordpressSize: FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                raw: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SparseWpSiteHealthDirectorySizes, into buf: inout [UInt8]) {
        FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.write(value.databaseSize, into: &buf)
        FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.write(value.fontsSize, into: &buf)
        FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.write(value.pluginsSize, into: &buf)
        FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.write(value.themesSize, into: &buf)
        FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.write(value.totalSize, into: &buf)
        FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.write(value.uploadsSize, into: &buf)
        FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo.write(value.wordpressSize, into: &buf)
        FfiConverterOptionUInt64.write(value.raw, into: &buf)
    }
}


public func FfiConverterTypeSparseWpSiteHealthDirectorySizes_lift(_ buf: RustBuffer) throws -> SparseWpSiteHealthDirectorySizes {
    return try FfiConverterTypeSparseWpSiteHealthDirectorySizes.lift(buf)
}

public func FfiConverterTypeSparseWpSiteHealthDirectorySizes_lower(_ value: SparseWpSiteHealthDirectorySizes) -> RustBuffer {
    return FfiConverterTypeSparseWpSiteHealthDirectorySizes.lower(value)
}


public struct SparseWpSiteHealthTest {
    public let actions: String?
    public let badge: WpSiteHealthTestBadge?
    public let description: String?
    public let label: String?
    public let status: String?
    public let test: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(actions: String?, badge: WpSiteHealthTestBadge?, description: String?, label: String?, status: String?, test: String?) {
        self.actions = actions
        self.badge = badge
        self.description = description
        self.label = label
        self.status = status
        self.test = test
    }
}



extension SparseWpSiteHealthTest: Equatable, Hashable {
    public static func ==(lhs: SparseWpSiteHealthTest, rhs: SparseWpSiteHealthTest) -> Bool {
        if lhs.actions != rhs.actions {
            return false
        }
        if lhs.badge != rhs.badge {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.test != rhs.test {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(actions)
        hasher.combine(badge)
        hasher.combine(description)
        hasher.combine(label)
        hasher.combine(status)
        hasher.combine(test)
    }
}


public struct FfiConverterTypeSparseWpSiteHealthTest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseWpSiteHealthTest {
        return
            try SparseWpSiteHealthTest(
                actions: FfiConverterOptionString.read(from: &buf), 
                badge: FfiConverterOptionTypeWpSiteHealthTestBadge.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                label: FfiConverterOptionString.read(from: &buf), 
                status: FfiConverterOptionString.read(from: &buf), 
                test: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparseWpSiteHealthTest, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.actions, into: &buf)
        FfiConverterOptionTypeWpSiteHealthTestBadge.write(value.badge, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterOptionString.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.test, into: &buf)
    }
}


public func FfiConverterTypeSparseWpSiteHealthTest_lift(_ buf: RustBuffer) throws -> SparseWpSiteHealthTest {
    return try FfiConverterTypeSparseWpSiteHealthTest.lift(buf)
}

public func FfiConverterTypeSparseWpSiteHealthTest_lower(_ value: SparseWpSiteHealthTest) -> RustBuffer {
    return FfiConverterTypeSparseWpSiteHealthTest.lower(value)
}


public struct UrlDiscoveryAttemptSuccess {
    public let siteUrl: ParsedUrl
    public let apiDetails: WpApiDetails
    public let apiRootUrl: ParsedUrl

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(siteUrl: ParsedUrl, apiDetails: WpApiDetails, apiRootUrl: ParsedUrl) {
        self.siteUrl = siteUrl
        self.apiDetails = apiDetails
        self.apiRootUrl = apiRootUrl
    }
}



public struct FfiConverterTypeUrlDiscoveryAttemptSuccess: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlDiscoveryAttemptSuccess {
        return
            try UrlDiscoveryAttemptSuccess(
                siteUrl: FfiConverterTypeParsedUrl.read(from: &buf), 
                apiDetails: FfiConverterTypeWpApiDetails.read(from: &buf), 
                apiRootUrl: FfiConverterTypeParsedUrl.read(from: &buf)
        )
    }

    public static func write(_ value: UrlDiscoveryAttemptSuccess, into buf: inout [UInt8]) {
        FfiConverterTypeParsedUrl.write(value.siteUrl, into: &buf)
        FfiConverterTypeWpApiDetails.write(value.apiDetails, into: &buf)
        FfiConverterTypeParsedUrl.write(value.apiRootUrl, into: &buf)
    }
}


public func FfiConverterTypeUrlDiscoveryAttemptSuccess_lift(_ buf: RustBuffer) throws -> UrlDiscoveryAttemptSuccess {
    return try FfiConverterTypeUrlDiscoveryAttemptSuccess.lift(buf)
}

public func FfiConverterTypeUrlDiscoveryAttemptSuccess_lower(_ value: UrlDiscoveryAttemptSuccess) -> RustBuffer {
    return FfiConverterTypeUrlDiscoveryAttemptSuccess.lower(value)
}


public struct UrlDiscoverySuccess {
    public let siteUrl: ParsedUrl
    public let apiDetails: WpApiDetails
    public let apiRootUrl: ParsedUrl
    public let attempts: [UrlDiscoveryState]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(siteUrl: ParsedUrl, apiDetails: WpApiDetails, apiRootUrl: ParsedUrl, attempts: [UrlDiscoveryState]) {
        self.siteUrl = siteUrl
        self.apiDetails = apiDetails
        self.apiRootUrl = apiRootUrl
        self.attempts = attempts
    }
}



public struct FfiConverterTypeUrlDiscoverySuccess: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlDiscoverySuccess {
        return
            try UrlDiscoverySuccess(
                siteUrl: FfiConverterTypeParsedUrl.read(from: &buf), 
                apiDetails: FfiConverterTypeWpApiDetails.read(from: &buf), 
                apiRootUrl: FfiConverterTypeParsedUrl.read(from: &buf), 
                attempts: FfiConverterSequenceTypeUrlDiscoveryState.read(from: &buf)
        )
    }

    public static func write(_ value: UrlDiscoverySuccess, into buf: inout [UInt8]) {
        FfiConverterTypeParsedUrl.write(value.siteUrl, into: &buf)
        FfiConverterTypeWpApiDetails.write(value.apiDetails, into: &buf)
        FfiConverterTypeParsedUrl.write(value.apiRootUrl, into: &buf)
        FfiConverterSequenceTypeUrlDiscoveryState.write(value.attempts, into: &buf)
    }
}


public func FfiConverterTypeUrlDiscoverySuccess_lift(_ buf: RustBuffer) throws -> UrlDiscoverySuccess {
    return try FfiConverterTypeUrlDiscoverySuccess.lift(buf)
}

public func FfiConverterTypeUrlDiscoverySuccess_lower(_ value: UrlDiscoverySuccess) -> RustBuffer {
    return FfiConverterTypeUrlDiscoverySuccess.lower(value)
}


public struct UserCreateParams {
    /**
     * Login name for the user.
     */
    public let username: String
    /**
     * The email address for the user.
     */
    public let email: String
    /**
     * Password for the user (never included).
     */
    public let password: String
    /**
     * Display name for the user.
     */
    public let name: String?
    /**
     * First name for the user.
     */
    public let firstName: String?
    /**
     * Last name for the user.
     */
    public let lastName: String?
    /**
     * URL of the user.
     */
    public let url: String?
    /**
     * Description of the user.
     */
    public let description: String?
    /**
     * Locale for the user.
     * One of: , `en_US`
     */
    public let locale: String?
    /**
     * The nickname for the user.
     */
    public let nickname: String?
    /**
     * An alphanumeric identifier for the user.
     */
    public let slug: String?
    /**
     * Roles assigned to the user.
     */
    public let roles: [String]
    /**
     * Meta fields.
     */
    public let meta: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Login name for the user.
         */username: String, 
        /**
         * The email address for the user.
         */email: String, 
        /**
         * Password for the user (never included).
         */password: String, 
        /**
         * Display name for the user.
         */name: String? = nil, 
        /**
         * First name for the user.
         */firstName: String? = nil, 
        /**
         * Last name for the user.
         */lastName: String? = nil, 
        /**
         * URL of the user.
         */url: String? = nil, 
        /**
         * Description of the user.
         */description: String? = nil, 
        /**
         * Locale for the user.
         * One of: , `en_US`
         */locale: String? = nil, 
        /**
         * The nickname for the user.
         */nickname: String? = nil, 
        /**
         * An alphanumeric identifier for the user.
         */slug: String? = nil, 
        /**
         * Roles assigned to the user.
         */roles: [String] = [], 
        /**
         * Meta fields.
         */meta: String? = nil) {
        self.username = username
        self.email = email
        self.password = password
        self.name = name
        self.firstName = firstName
        self.lastName = lastName
        self.url = url
        self.description = description
        self.locale = locale
        self.nickname = nickname
        self.slug = slug
        self.roles = roles
        self.meta = meta
    }
}



extension UserCreateParams: Equatable, Hashable {
    public static func ==(lhs: UserCreateParams, rhs: UserCreateParams) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.meta != rhs.meta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(email)
        hasher.combine(password)
        hasher.combine(name)
        hasher.combine(firstName)
        hasher.combine(lastName)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(locale)
        hasher.combine(nickname)
        hasher.combine(slug)
        hasher.combine(roles)
        hasher.combine(meta)
    }
}


public struct FfiConverterTypeUserCreateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserCreateParams {
        return
            try UserCreateParams(
                username: FfiConverterString.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                firstName: FfiConverterOptionString.read(from: &buf), 
                lastName: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                locale: FfiConverterOptionString.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                roles: FfiConverterSequenceString.read(from: &buf), 
                meta: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserCreateParams, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.firstName, into: &buf)
        FfiConverterOptionString.write(value.lastName, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.locale, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterSequenceString.write(value.roles, into: &buf)
        FfiConverterOptionString.write(value.meta, into: &buf)
    }
}


public func FfiConverterTypeUserCreateParams_lift(_ buf: RustBuffer) throws -> UserCreateParams {
    return try FfiConverterTypeUserCreateParams.lift(buf)
}

public func FfiConverterTypeUserCreateParams_lower(_ value: UserCreateParams) -> RustBuffer {
    return FfiConverterTypeUserCreateParams.lower(value)
}


public struct UserDeleteParams {
    /**
     * Reassign the deleted user's posts and links to this user ID.
     */
    public let reassign: UserId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Reassign the deleted user's posts and links to this user ID.
         */reassign: UserId) {
        self.reassign = reassign
    }
}



extension UserDeleteParams: Equatable, Hashable {
    public static func ==(lhs: UserDeleteParams, rhs: UserDeleteParams) -> Bool {
        if lhs.reassign != rhs.reassign {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reassign)
    }
}


public struct FfiConverterTypeUserDeleteParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserDeleteParams {
        return
            try UserDeleteParams(
                reassign: FfiConverterTypeUserId.read(from: &buf)
        )
    }

    public static func write(_ value: UserDeleteParams, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.reassign, into: &buf)
    }
}


public func FfiConverterTypeUserDeleteParams_lift(_ buf: RustBuffer) throws -> UserDeleteParams {
    return try FfiConverterTypeUserDeleteParams.lift(buf)
}

public func FfiConverterTypeUserDeleteParams_lower(_ value: UserDeleteParams) -> RustBuffer {
    return FfiConverterTypeUserDeleteParams.lower(value)
}


public struct UserDeleteResponse {
    public let deleted: Bool
    public let previous: UserWithEditContext

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deleted: Bool, previous: UserWithEditContext) {
        self.deleted = deleted
        self.previous = previous
    }
}



extension UserDeleteResponse: Equatable, Hashable {
    public static func ==(lhs: UserDeleteResponse, rhs: UserDeleteResponse) -> Bool {
        if lhs.deleted != rhs.deleted {
            return false
        }
        if lhs.previous != rhs.previous {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deleted)
        hasher.combine(previous)
    }
}


public struct FfiConverterTypeUserDeleteResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserDeleteResponse {
        return
            try UserDeleteResponse(
                deleted: FfiConverterBool.read(from: &buf), 
                previous: FfiConverterTypeUserWithEditContext.read(from: &buf)
        )
    }

    public static func write(_ value: UserDeleteResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.deleted, into: &buf)
        FfiConverterTypeUserWithEditContext.write(value.previous, into: &buf)
    }
}


public func FfiConverterTypeUserDeleteResponse_lift(_ buf: RustBuffer) throws -> UserDeleteResponse {
    return try FfiConverterTypeUserDeleteResponse.lift(buf)
}

public func FfiConverterTypeUserDeleteResponse_lower(_ value: UserDeleteResponse) -> RustBuffer {
    return FfiConverterTypeUserDeleteResponse.lower(value)
}


public struct UserListParams {
    /**
     * Current page of the collection.
     * Default: `1`
     */
    public let page: UInt32?
    /**
     * Maximum number of items to be returned in result set.
     * Default: `10`
     */
    public let perPage: UInt32?
    /**
     * Limit results to those matching a string.
     */
    public let search: String?
    /**
     * Ensure result set excludes specific IDs.
     */
    public let exclude: [UserId]
    /**
     * Limit result set to specific IDs.
     */
    public let include: [UserId]
    /**
     * Offset the result set by a specific number of items.
     */
    public let offset: UInt32?
    /**
     * Order sort attribute ascending or descending.
     * Default: `asc`
     * One of: `asc`, `desc`
     */
    public let order: WpApiParamOrder?
    /**
     * Sort collection by user attribute.
     * Default: `name`
     * One of: `id`, `include`, `name`, `registered_date`, `slug`, `include_slugs`, `email`, `url`
     */
    public let orderby: WpApiParamUsersOrderBy?
    /**
     * Limit result set to users with one or more specific slugs.
     */
    public let slug: [String]
    /**
     * Limit result set to users matching at least one specific role provided. Accepts csv list or single role.
     */
    public let roles: [String]
    /**
     * Limit result set to users matching at least one specific capability provided. Accepts csv list or single capability.
     */
    public let capabilities: [String]
    /**
     * Limit result set to users who are considered authors.
     * One of: `authors`
     */
    public let who: WpApiParamUsersWho?
    /**
     * Limit result set to users who have published posts.
     */
    public let hasPublishedPosts: WpApiParamUsersHasPublishedPosts?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Current page of the collection.
         * Default: `1`
         */page: UInt32? = nil, 
        /**
         * Maximum number of items to be returned in result set.
         * Default: `10`
         */perPage: UInt32? = nil, 
        /**
         * Limit results to those matching a string.
         */search: String? = nil, 
        /**
         * Ensure result set excludes specific IDs.
         */exclude: [UserId] = [], 
        /**
         * Limit result set to specific IDs.
         */include: [UserId] = [], 
        /**
         * Offset the result set by a specific number of items.
         */offset: UInt32? = nil, 
        /**
         * Order sort attribute ascending or descending.
         * Default: `asc`
         * One of: `asc`, `desc`
         */order: WpApiParamOrder? = nil, 
        /**
         * Sort collection by user attribute.
         * Default: `name`
         * One of: `id`, `include`, `name`, `registered_date`, `slug`, `include_slugs`, `email`, `url`
         */orderby: WpApiParamUsersOrderBy? = nil, 
        /**
         * Limit result set to users with one or more specific slugs.
         */slug: [String] = [], 
        /**
         * Limit result set to users matching at least one specific role provided. Accepts csv list or single role.
         */roles: [String] = [], 
        /**
         * Limit result set to users matching at least one specific capability provided. Accepts csv list or single capability.
         */capabilities: [String] = [], 
        /**
         * Limit result set to users who are considered authors.
         * One of: `authors`
         */who: WpApiParamUsersWho? = nil, 
        /**
         * Limit result set to users who have published posts.
         */hasPublishedPosts: WpApiParamUsersHasPublishedPosts? = nil) {
        self.page = page
        self.perPage = perPage
        self.search = search
        self.exclude = exclude
        self.include = include
        self.offset = offset
        self.order = order
        self.orderby = orderby
        self.slug = slug
        self.roles = roles
        self.capabilities = capabilities
        self.who = who
        self.hasPublishedPosts = hasPublishedPosts
    }
}



extension UserListParams: Equatable, Hashable {
    public static func ==(lhs: UserListParams, rhs: UserListParams) -> Bool {
        if lhs.page != rhs.page {
            return false
        }
        if lhs.perPage != rhs.perPage {
            return false
        }
        if lhs.search != rhs.search {
            return false
        }
        if lhs.exclude != rhs.exclude {
            return false
        }
        if lhs.include != rhs.include {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        if lhs.orderby != rhs.orderby {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        if lhs.who != rhs.who {
            return false
        }
        if lhs.hasPublishedPosts != rhs.hasPublishedPosts {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(page)
        hasher.combine(perPage)
        hasher.combine(search)
        hasher.combine(exclude)
        hasher.combine(include)
        hasher.combine(offset)
        hasher.combine(order)
        hasher.combine(orderby)
        hasher.combine(slug)
        hasher.combine(roles)
        hasher.combine(capabilities)
        hasher.combine(who)
        hasher.combine(hasPublishedPosts)
    }
}


public struct FfiConverterTypeUserListParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserListParams {
        return
            try UserListParams(
                page: FfiConverterOptionUInt32.read(from: &buf), 
                perPage: FfiConverterOptionUInt32.read(from: &buf), 
                search: FfiConverterOptionString.read(from: &buf), 
                exclude: FfiConverterSequenceTypeUserId.read(from: &buf), 
                include: FfiConverterSequenceTypeUserId.read(from: &buf), 
                offset: FfiConverterOptionUInt32.read(from: &buf), 
                order: FfiConverterOptionTypeWpApiParamOrder.read(from: &buf), 
                orderby: FfiConverterOptionTypeWpApiParamUsersOrderBy.read(from: &buf), 
                slug: FfiConverterSequenceString.read(from: &buf), 
                roles: FfiConverterSequenceString.read(from: &buf), 
                capabilities: FfiConverterSequenceString.read(from: &buf), 
                who: FfiConverterOptionTypeWpApiParamUsersWho.read(from: &buf), 
                hasPublishedPosts: FfiConverterOptionTypeWpApiParamUsersHasPublishedPosts.read(from: &buf)
        )
    }

    public static func write(_ value: UserListParams, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.page, into: &buf)
        FfiConverterOptionUInt32.write(value.perPage, into: &buf)
        FfiConverterOptionString.write(value.search, into: &buf)
        FfiConverterSequenceTypeUserId.write(value.exclude, into: &buf)
        FfiConverterSequenceTypeUserId.write(value.include, into: &buf)
        FfiConverterOptionUInt32.write(value.offset, into: &buf)
        FfiConverterOptionTypeWpApiParamOrder.write(value.order, into: &buf)
        FfiConverterOptionTypeWpApiParamUsersOrderBy.write(value.orderby, into: &buf)
        FfiConverterSequenceString.write(value.slug, into: &buf)
        FfiConverterSequenceString.write(value.roles, into: &buf)
        FfiConverterSequenceString.write(value.capabilities, into: &buf)
        FfiConverterOptionTypeWpApiParamUsersWho.write(value.who, into: &buf)
        FfiConverterOptionTypeWpApiParamUsersHasPublishedPosts.write(value.hasPublishedPosts, into: &buf)
    }
}


public func FfiConverterTypeUserListParams_lift(_ buf: RustBuffer) throws -> UserListParams {
    return try FfiConverterTypeUserListParams.lift(buf)
}

public func FfiConverterTypeUserListParams_lower(_ value: UserListParams) -> RustBuffer {
    return FfiConverterTypeUserListParams.lower(value)
}


public struct UserUpdateParams {
    /**
     * Display name for the user.
     */
    public let name: String?
    /**
     * First name for the user.
     */
    public let firstName: String?
    /**
     * Last name for the user.
     */
    public let lastName: String?
    /**
     * The email address for the user.
     */
    public let email: String?
    /**
     * URL of the user.
     */
    public let url: String?
    /**
     * Description of the user.
     */
    public let description: String?
    /**
     * Locale for the user.
     * One of: , `en_US`
     */
    public let locale: String?
    /**
     * The nickname for the user.
     */
    public let nickname: String?
    /**
     * An alphanumeric identifier for the user.
     */
    public let slug: String?
    /**
     * Roles assigned to the user.
     */
    public let roles: [String]
    /**
     * Password for the user (never included).
     */
    public let password: String?
    /**
     * Meta fields.
     */
    public let meta: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Display name for the user.
         */name: String? = nil, 
        /**
         * First name for the user.
         */firstName: String? = nil, 
        /**
         * Last name for the user.
         */lastName: String? = nil, 
        /**
         * The email address for the user.
         */email: String? = nil, 
        /**
         * URL of the user.
         */url: String? = nil, 
        /**
         * Description of the user.
         */description: String? = nil, 
        /**
         * Locale for the user.
         * One of: , `en_US`
         */locale: String? = nil, 
        /**
         * The nickname for the user.
         */nickname: String? = nil, 
        /**
         * An alphanumeric identifier for the user.
         */slug: String? = nil, 
        /**
         * Roles assigned to the user.
         */roles: [String] = [], 
        /**
         * Password for the user (never included).
         */password: String? = nil, 
        /**
         * Meta fields.
         */meta: String? = nil) {
        self.name = name
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.url = url
        self.description = description
        self.locale = locale
        self.nickname = nickname
        self.slug = slug
        self.roles = roles
        self.password = password
        self.meta = meta
    }
}



extension UserUpdateParams: Equatable, Hashable {
    public static func ==(lhs: UserUpdateParams, rhs: UserUpdateParams) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.meta != rhs.meta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(firstName)
        hasher.combine(lastName)
        hasher.combine(email)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(locale)
        hasher.combine(nickname)
        hasher.combine(slug)
        hasher.combine(roles)
        hasher.combine(password)
        hasher.combine(meta)
    }
}


public struct FfiConverterTypeUserUpdateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserUpdateParams {
        return
            try UserUpdateParams(
                name: FfiConverterOptionString.read(from: &buf), 
                firstName: FfiConverterOptionString.read(from: &buf), 
                lastName: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                locale: FfiConverterOptionString.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                roles: FfiConverterSequenceString.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf), 
                meta: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserUpdateParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.firstName, into: &buf)
        FfiConverterOptionString.write(value.lastName, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.locale, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterSequenceString.write(value.roles, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
        FfiConverterOptionString.write(value.meta, into: &buf)
    }
}


public func FfiConverterTypeUserUpdateParams_lift(_ buf: RustBuffer) throws -> UserUpdateParams {
    return try FfiConverterTypeUserUpdateParams.lift(buf)
}

public func FfiConverterTypeUserUpdateParams_lower(_ value: UserUpdateParams) -> RustBuffer {
    return FfiConverterTypeUserUpdateParams.lower(value)
}


public struct UserWithEditContext {
    public let id: UserId
    public let username: String
    public let name: String
    public let firstName: String
    public let lastName: String
    public let email: String
    public let url: String
    public let description: String
    public let link: String
    public let locale: String
    public let nickname: String
    public let slug: String
    public let registeredDate: String
    public let roles: [String]
    public let capabilities: [String: Bool]
    public let extraCapabilities: [String: Bool]
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId, username: String, name: String, firstName: String, lastName: String, email: String, url: String, description: String, link: String, locale: String, nickname: String, slug: String, registeredDate: String, roles: [String], capabilities: [String: Bool], extraCapabilities: [String: Bool], avatarUrls: [String: String]?) {
        self.id = id
        self.username = username
        self.name = name
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.url = url
        self.description = description
        self.link = link
        self.locale = locale
        self.nickname = nickname
        self.slug = slug
        self.registeredDate = registeredDate
        self.roles = roles
        self.capabilities = capabilities
        self.extraCapabilities = extraCapabilities
        self.avatarUrls = avatarUrls
    }
}



extension UserWithEditContext: Equatable, Hashable {
    public static func ==(lhs: UserWithEditContext, rhs: UserWithEditContext) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.registeredDate != rhs.registeredDate {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        if lhs.extraCapabilities != rhs.extraCapabilities {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(username)
        hasher.combine(name)
        hasher.combine(firstName)
        hasher.combine(lastName)
        hasher.combine(email)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(locale)
        hasher.combine(nickname)
        hasher.combine(slug)
        hasher.combine(registeredDate)
        hasher.combine(roles)
        hasher.combine(capabilities)
        hasher.combine(extraCapabilities)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeUserWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserWithEditContext {
        return
            try UserWithEditContext(
                id: FfiConverterTypeUserId.read(from: &buf), 
                username: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                firstName: FfiConverterString.read(from: &buf), 
                lastName: FfiConverterString.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                link: FfiConverterString.read(from: &buf), 
                locale: FfiConverterString.read(from: &buf), 
                nickname: FfiConverterString.read(from: &buf), 
                slug: FfiConverterString.read(from: &buf), 
                registeredDate: FfiConverterString.read(from: &buf), 
                roles: FfiConverterSequenceString.read(from: &buf), 
                capabilities: FfiConverterDictionaryStringBool.read(from: &buf), 
                extraCapabilities: FfiConverterDictionaryStringBool.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: UserWithEditContext, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.id, into: &buf)
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.firstName, into: &buf)
        FfiConverterString.write(value.lastName, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.link, into: &buf)
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterString.write(value.nickname, into: &buf)
        FfiConverterString.write(value.slug, into: &buf)
        FfiConverterString.write(value.registeredDate, into: &buf)
        FfiConverterSequenceString.write(value.roles, into: &buf)
        FfiConverterDictionaryStringBool.write(value.capabilities, into: &buf)
        FfiConverterDictionaryStringBool.write(value.extraCapabilities, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeUserWithEditContext_lift(_ buf: RustBuffer) throws -> UserWithEditContext {
    return try FfiConverterTypeUserWithEditContext.lift(buf)
}

public func FfiConverterTypeUserWithEditContext_lower(_ value: UserWithEditContext) -> RustBuffer {
    return FfiConverterTypeUserWithEditContext.lower(value)
}


public struct UserWithEmbedContext {
    public let id: UserId
    public let name: String
    public let url: String
    public let description: String
    public let link: String
    public let slug: String
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId, name: String, url: String, description: String, link: String, slug: String, avatarUrls: [String: String]?) {
        self.id = id
        self.name = name
        self.url = url
        self.description = description
        self.link = link
        self.slug = slug
        self.avatarUrls = avatarUrls
    }
}



extension UserWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: UserWithEmbedContext, rhs: UserWithEmbedContext) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(slug)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeUserWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserWithEmbedContext {
        return
            try UserWithEmbedContext(
                id: FfiConverterTypeUserId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                link: FfiConverterString.read(from: &buf), 
                slug: FfiConverterString.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: UserWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.link, into: &buf)
        FfiConverterString.write(value.slug, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeUserWithEmbedContext_lift(_ buf: RustBuffer) throws -> UserWithEmbedContext {
    return try FfiConverterTypeUserWithEmbedContext.lift(buf)
}

public func FfiConverterTypeUserWithEmbedContext_lower(_ value: UserWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeUserWithEmbedContext.lower(value)
}


public struct UserWithViewContext {
    public let id: UserId
    public let name: String
    public let url: String
    public let description: String
    public let link: String
    public let slug: String
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId, name: String, url: String, description: String, link: String, slug: String, avatarUrls: [String: String]?) {
        self.id = id
        self.name = name
        self.url = url
        self.description = description
        self.link = link
        self.slug = slug
        self.avatarUrls = avatarUrls
    }
}



extension UserWithViewContext: Equatable, Hashable {
    public static func ==(lhs: UserWithViewContext, rhs: UserWithViewContext) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(slug)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeUserWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserWithViewContext {
        return
            try UserWithViewContext(
                id: FfiConverterTypeUserId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                link: FfiConverterString.read(from: &buf), 
                slug: FfiConverterString.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: UserWithViewContext, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.link, into: &buf)
        FfiConverterString.write(value.slug, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeUserWithViewContext_lift(_ buf: RustBuffer) throws -> UserWithViewContext {
    return try FfiConverterTypeUserWithViewContext.lift(buf)
}

public func FfiConverterTypeUserWithViewContext_lower(_ value: UserWithViewContext) -> RustBuffer {
    return FfiConverterTypeUserWithViewContext.lower(value)
}


public struct WpApiApplicationPasswordDetails {
    public let siteUrl: String
    public let userLogin: String
    public let password: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(siteUrl: String, userLogin: String, password: String) {
        self.siteUrl = siteUrl
        self.userLogin = userLogin
        self.password = password
    }
}



extension WpApiApplicationPasswordDetails: Equatable, Hashable {
    public static func ==(lhs: WpApiApplicationPasswordDetails, rhs: WpApiApplicationPasswordDetails) -> Bool {
        if lhs.siteUrl != rhs.siteUrl {
            return false
        }
        if lhs.userLogin != rhs.userLogin {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(siteUrl)
        hasher.combine(userLogin)
        hasher.combine(password)
    }
}


public struct FfiConverterTypeWpApiApplicationPasswordDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiApplicationPasswordDetails {
        return
            try WpApiApplicationPasswordDetails(
                siteUrl: FfiConverterString.read(from: &buf), 
                userLogin: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WpApiApplicationPasswordDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.siteUrl, into: &buf)
        FfiConverterString.write(value.userLogin, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
    }
}


public func FfiConverterTypeWpApiApplicationPasswordDetails_lift(_ buf: RustBuffer) throws -> WpApiApplicationPasswordDetails {
    return try FfiConverterTypeWpApiApplicationPasswordDetails.lift(buf)
}

public func FfiConverterTypeWpApiApplicationPasswordDetails_lower(_ value: WpApiApplicationPasswordDetails) -> RustBuffer {
    return FfiConverterTypeWpApiApplicationPasswordDetails.lower(value)
}


public struct WpNetworkResponse {
    public let body: Data
    public let statusCode: UInt16
    public let headerMap: WpNetworkHeaderMap

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: Data, statusCode: UInt16, headerMap: WpNetworkHeaderMap) {
        self.body = body
        self.statusCode = statusCode
        self.headerMap = headerMap
    }
}



public struct FfiConverterTypeWpNetworkResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpNetworkResponse {
        return
            try WpNetworkResponse(
                body: FfiConverterData.read(from: &buf), 
                statusCode: FfiConverterUInt16.read(from: &buf), 
                headerMap: FfiConverterTypeWpNetworkHeaderMap.read(from: &buf)
        )
    }

    public static func write(_ value: WpNetworkResponse, into buf: inout [UInt8]) {
        FfiConverterData.write(value.body, into: &buf)
        FfiConverterUInt16.write(value.statusCode, into: &buf)
        FfiConverterTypeWpNetworkHeaderMap.write(value.headerMap, into: &buf)
    }
}


public func FfiConverterTypeWpNetworkResponse_lift(_ buf: RustBuffer) throws -> WpNetworkResponse {
    return try FfiConverterTypeWpNetworkResponse.lift(buf)
}

public func FfiConverterTypeWpNetworkResponse_lower(_ value: WpNetworkResponse) -> RustBuffer {
    return FfiConverterTypeWpNetworkResponse.lower(value)
}


public struct WpRestApiAuthenticationEndpoint {
    public let authorization: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(authorization: String) {
        self.authorization = authorization
    }
}



extension WpRestApiAuthenticationEndpoint: Equatable, Hashable {
    public static func ==(lhs: WpRestApiAuthenticationEndpoint, rhs: WpRestApiAuthenticationEndpoint) -> Bool {
        if lhs.authorization != rhs.authorization {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(authorization)
    }
}


public struct FfiConverterTypeWpRestApiAuthenticationEndpoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpRestApiAuthenticationEndpoint {
        return
            try WpRestApiAuthenticationEndpoint(
                authorization: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WpRestApiAuthenticationEndpoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.authorization, into: &buf)
    }
}


public func FfiConverterTypeWpRestApiAuthenticationEndpoint_lift(_ buf: RustBuffer) throws -> WpRestApiAuthenticationEndpoint {
    return try FfiConverterTypeWpRestApiAuthenticationEndpoint.lift(buf)
}

public func FfiConverterTypeWpRestApiAuthenticationEndpoint_lower(_ value: WpRestApiAuthenticationEndpoint) -> RustBuffer {
    return FfiConverterTypeWpRestApiAuthenticationEndpoint.lower(value)
}


public struct WpRestApiAuthenticationScheme {
    public let endpoints: WpRestApiAuthenticationEndpoint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(endpoints: WpRestApiAuthenticationEndpoint) {
        self.endpoints = endpoints
    }
}



extension WpRestApiAuthenticationScheme: Equatable, Hashable {
    public static func ==(lhs: WpRestApiAuthenticationScheme, rhs: WpRestApiAuthenticationScheme) -> Bool {
        if lhs.endpoints != rhs.endpoints {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(endpoints)
    }
}


public struct FfiConverterTypeWpRestApiAuthenticationScheme: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpRestApiAuthenticationScheme {
        return
            try WpRestApiAuthenticationScheme(
                endpoints: FfiConverterTypeWpRestApiAuthenticationEndpoint.read(from: &buf)
        )
    }

    public static func write(_ value: WpRestApiAuthenticationScheme, into buf: inout [UInt8]) {
        FfiConverterTypeWpRestApiAuthenticationEndpoint.write(value.endpoints, into: &buf)
    }
}


public func FfiConverterTypeWpRestApiAuthenticationScheme_lift(_ buf: RustBuffer) throws -> WpRestApiAuthenticationScheme {
    return try FfiConverterTypeWpRestApiAuthenticationScheme.lift(buf)
}

public func FfiConverterTypeWpRestApiAuthenticationScheme_lower(_ value: WpRestApiAuthenticationScheme) -> RustBuffer {
    return FfiConverterTypeWpRestApiAuthenticationScheme.lower(value)
}


public struct WpRestApiUrls {
    public let apiDetails: WpApiDetails
    public let apiRootUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(apiDetails: WpApiDetails, apiRootUrl: String) {
        self.apiDetails = apiDetails
        self.apiRootUrl = apiRootUrl
    }
}



public struct FfiConverterTypeWpRestApiUrls: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpRestApiUrls {
        return
            try WpRestApiUrls(
                apiDetails: FfiConverterTypeWpApiDetails.read(from: &buf), 
                apiRootUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WpRestApiUrls, into buf: inout [UInt8]) {
        FfiConverterTypeWpApiDetails.write(value.apiDetails, into: &buf)
        FfiConverterString.write(value.apiRootUrl, into: &buf)
    }
}


public func FfiConverterTypeWpRestApiUrls_lift(_ buf: RustBuffer) throws -> WpRestApiUrls {
    return try FfiConverterTypeWpRestApiUrls.lift(buf)
}

public func FfiConverterTypeWpRestApiUrls_lower(_ value: WpRestApiUrls) -> RustBuffer {
    return FfiConverterTypeWpRestApiUrls.lower(value)
}


public struct WpSiteHealthDirectorySizeInfo {
    public let debug: String
    public let size: String
    public let raw: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(debug: String, size: String, raw: UInt64?) {
        self.debug = debug
        self.size = size
        self.raw = raw
    }
}



extension WpSiteHealthDirectorySizeInfo: Equatable, Hashable {
    public static func ==(lhs: WpSiteHealthDirectorySizeInfo, rhs: WpSiteHealthDirectorySizeInfo) -> Bool {
        if lhs.debug != rhs.debug {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.raw != rhs.raw {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(debug)
        hasher.combine(size)
        hasher.combine(raw)
    }
}


public struct FfiConverterTypeWpSiteHealthDirectorySizeInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpSiteHealthDirectorySizeInfo {
        return
            try WpSiteHealthDirectorySizeInfo(
                debug: FfiConverterString.read(from: &buf), 
                size: FfiConverterString.read(from: &buf), 
                raw: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: WpSiteHealthDirectorySizeInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.debug, into: &buf)
        FfiConverterString.write(value.size, into: &buf)
        FfiConverterOptionUInt64.write(value.raw, into: &buf)
    }
}


public func FfiConverterTypeWpSiteHealthDirectorySizeInfo_lift(_ buf: RustBuffer) throws -> WpSiteHealthDirectorySizeInfo {
    return try FfiConverterTypeWpSiteHealthDirectorySizeInfo.lift(buf)
}

public func FfiConverterTypeWpSiteHealthDirectorySizeInfo_lower(_ value: WpSiteHealthDirectorySizeInfo) -> RustBuffer {
    return FfiConverterTypeWpSiteHealthDirectorySizeInfo.lower(value)
}


public struct WpSiteHealthDirectorySizes {
    public let databaseSize: WpSiteHealthDirectorySizeInfo
    public let fontsSize: WpSiteHealthDirectorySizeInfo
    public let pluginsSize: WpSiteHealthDirectorySizeInfo
    public let themesSize: WpSiteHealthDirectorySizeInfo
    public let totalSize: WpSiteHealthDirectorySizeInfo
    public let uploadsSize: WpSiteHealthDirectorySizeInfo
    public let wordpressSize: WpSiteHealthDirectorySizeInfo
    public let raw: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(databaseSize: WpSiteHealthDirectorySizeInfo, fontsSize: WpSiteHealthDirectorySizeInfo, pluginsSize: WpSiteHealthDirectorySizeInfo, themesSize: WpSiteHealthDirectorySizeInfo, totalSize: WpSiteHealthDirectorySizeInfo, uploadsSize: WpSiteHealthDirectorySizeInfo, wordpressSize: WpSiteHealthDirectorySizeInfo, raw: UInt64?) {
        self.databaseSize = databaseSize
        self.fontsSize = fontsSize
        self.pluginsSize = pluginsSize
        self.themesSize = themesSize
        self.totalSize = totalSize
        self.uploadsSize = uploadsSize
        self.wordpressSize = wordpressSize
        self.raw = raw
    }
}



extension WpSiteHealthDirectorySizes: Equatable, Hashable {
    public static func ==(lhs: WpSiteHealthDirectorySizes, rhs: WpSiteHealthDirectorySizes) -> Bool {
        if lhs.databaseSize != rhs.databaseSize {
            return false
        }
        if lhs.fontsSize != rhs.fontsSize {
            return false
        }
        if lhs.pluginsSize != rhs.pluginsSize {
            return false
        }
        if lhs.themesSize != rhs.themesSize {
            return false
        }
        if lhs.totalSize != rhs.totalSize {
            return false
        }
        if lhs.uploadsSize != rhs.uploadsSize {
            return false
        }
        if lhs.wordpressSize != rhs.wordpressSize {
            return false
        }
        if lhs.raw != rhs.raw {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(databaseSize)
        hasher.combine(fontsSize)
        hasher.combine(pluginsSize)
        hasher.combine(themesSize)
        hasher.combine(totalSize)
        hasher.combine(uploadsSize)
        hasher.combine(wordpressSize)
        hasher.combine(raw)
    }
}


public struct FfiConverterTypeWpSiteHealthDirectorySizes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpSiteHealthDirectorySizes {
        return
            try WpSiteHealthDirectorySizes(
                databaseSize: FfiConverterTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                fontsSize: FfiConverterTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                pluginsSize: FfiConverterTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                themesSize: FfiConverterTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                totalSize: FfiConverterTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                uploadsSize: FfiConverterTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                wordpressSize: FfiConverterTypeWpSiteHealthDirectorySizeInfo.read(from: &buf), 
                raw: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: WpSiteHealthDirectorySizes, into buf: inout [UInt8]) {
        FfiConverterTypeWpSiteHealthDirectorySizeInfo.write(value.databaseSize, into: &buf)
        FfiConverterTypeWpSiteHealthDirectorySizeInfo.write(value.fontsSize, into: &buf)
        FfiConverterTypeWpSiteHealthDirectorySizeInfo.write(value.pluginsSize, into: &buf)
        FfiConverterTypeWpSiteHealthDirectorySizeInfo.write(value.themesSize, into: &buf)
        FfiConverterTypeWpSiteHealthDirectorySizeInfo.write(value.totalSize, into: &buf)
        FfiConverterTypeWpSiteHealthDirectorySizeInfo.write(value.uploadsSize, into: &buf)
        FfiConverterTypeWpSiteHealthDirectorySizeInfo.write(value.wordpressSize, into: &buf)
        FfiConverterOptionUInt64.write(value.raw, into: &buf)
    }
}


public func FfiConverterTypeWpSiteHealthDirectorySizes_lift(_ buf: RustBuffer) throws -> WpSiteHealthDirectorySizes {
    return try FfiConverterTypeWpSiteHealthDirectorySizes.lift(buf)
}

public func FfiConverterTypeWpSiteHealthDirectorySizes_lower(_ value: WpSiteHealthDirectorySizes) -> RustBuffer {
    return FfiConverterTypeWpSiteHealthDirectorySizes.lower(value)
}


public struct WpSiteHealthTest {
    public let actions: String
    public let badge: WpSiteHealthTestBadge
    public let description: String
    public let label: String
    public let status: String
    public let test: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(actions: String, badge: WpSiteHealthTestBadge, description: String, label: String, status: String, test: String) {
        self.actions = actions
        self.badge = badge
        self.description = description
        self.label = label
        self.status = status
        self.test = test
    }
}



extension WpSiteHealthTest: Equatable, Hashable {
    public static func ==(lhs: WpSiteHealthTest, rhs: WpSiteHealthTest) -> Bool {
        if lhs.actions != rhs.actions {
            return false
        }
        if lhs.badge != rhs.badge {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.test != rhs.test {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(actions)
        hasher.combine(badge)
        hasher.combine(description)
        hasher.combine(label)
        hasher.combine(status)
        hasher.combine(test)
    }
}


public struct FfiConverterTypeWpSiteHealthTest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpSiteHealthTest {
        return
            try WpSiteHealthTest(
                actions: FfiConverterString.read(from: &buf), 
                badge: FfiConverterTypeWpSiteHealthTestBadge.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                label: FfiConverterString.read(from: &buf), 
                status: FfiConverterString.read(from: &buf), 
                test: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WpSiteHealthTest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.actions, into: &buf)
        FfiConverterTypeWpSiteHealthTestBadge.write(value.badge, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterString.write(value.test, into: &buf)
    }
}


public func FfiConverterTypeWpSiteHealthTest_lift(_ buf: RustBuffer) throws -> WpSiteHealthTest {
    return try FfiConverterTypeWpSiteHealthTest.lift(buf)
}

public func FfiConverterTypeWpSiteHealthTest_lower(_ value: WpSiteHealthTest) -> RustBuffer {
    return FfiConverterTypeWpSiteHealthTest.lower(value)
}


public struct WpSiteHealthTestBadge {
    public let color: String
    public let label: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(color: String, label: String) {
        self.color = color
        self.label = label
    }
}



extension WpSiteHealthTestBadge: Equatable, Hashable {
    public static func ==(lhs: WpSiteHealthTestBadge, rhs: WpSiteHealthTestBadge) -> Bool {
        if lhs.color != rhs.color {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(color)
        hasher.combine(label)
    }
}


public struct FfiConverterTypeWpSiteHealthTestBadge: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpSiteHealthTestBadge {
        return
            try WpSiteHealthTestBadge(
                color: FfiConverterString.read(from: &buf), 
                label: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WpSiteHealthTestBadge, into buf: inout [UInt8]) {
        FfiConverterString.write(value.color, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
    }
}


public func FfiConverterTypeWpSiteHealthTestBadge_lift(_ buf: RustBuffer) throws -> WpSiteHealthTestBadge {
    return try FfiConverterTypeWpSiteHealthTestBadge.lift(buf)
}

public func FfiConverterTypeWpSiteHealthTestBadge_lower(_ value: WpSiteHealthTestBadge) -> RustBuffer {
    return FfiConverterTypeWpSiteHealthTestBadge.lower(value)
}


public enum FetchApiDetailsError {

    
    
    case RequestExecutionFailed(statusCode: UInt16?, reason: String
    )
    case ApiDetailsCouldntBeParsed(reason: String, response: String
    )
}


public struct FfiConverterTypeFetchApiDetailsError: FfiConverterRustBuffer {
    typealias SwiftType = FetchApiDetailsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FetchApiDetailsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestExecutionFailed(
            statusCode: try FfiConverterOptionUInt16.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .ApiDetailsCouldntBeParsed(
            reason: try FfiConverterString.read(from: &buf), 
            response: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FetchApiDetailsError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .RequestExecutionFailed(statusCode,reason):
            writeInt(&buf, Int32(1))
            FfiConverterOptionUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .ApiDetailsCouldntBeParsed(reason,response):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(reason, into: &buf)
            FfiConverterString.write(response, into: &buf)
            
        }
    }
}


extension FetchApiDetailsError: Equatable, Hashable {}

extension FetchApiDetailsError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum FetchApiRootUrlError {

    
    
    case RequestExecutionFailed(statusCode: UInt16?, reason: String
    )
    case ApiRootLinkHeaderNotFound(headerMap: WpNetworkHeaderMap
    )
}


public struct FfiConverterTypeFetchApiRootUrlError: FfiConverterRustBuffer {
    typealias SwiftType = FetchApiRootUrlError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FetchApiRootUrlError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestExecutionFailed(
            statusCode: try FfiConverterOptionUInt16.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .ApiRootLinkHeaderNotFound(
            headerMap: try FfiConverterTypeWpNetworkHeaderMap.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FetchApiRootUrlError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .RequestExecutionFailed(statusCode,reason):
            writeInt(&buf, Int32(1))
            FfiConverterOptionUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .ApiRootLinkHeaderNotFound(headerMap):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWpNetworkHeaderMap.write(headerMap, into: &buf)
            
        }
    }
}


extension FetchApiRootUrlError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum OAuthResponseUrlError {

    
    
    case MissingSiteUrl
    case MissingUsername
    case MissingPassword
    case UnsuccessfulLogin
}


public struct FfiConverterTypeOAuthResponseUrlError: FfiConverterRustBuffer {
    typealias SwiftType = OAuthResponseUrlError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OAuthResponseUrlError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingSiteUrl
        case 2: return .MissingUsername
        case 3: return .MissingPassword
        case 4: return .UnsuccessfulLogin

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OAuthResponseUrlError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingSiteUrl:
            writeInt(&buf, Int32(1))
        
        
        case .MissingUsername:
            writeInt(&buf, Int32(2))
        
        
        case .MissingPassword:
            writeInt(&buf, Int32(3))
        
        
        case .UnsuccessfulLogin:
            writeInt(&buf, Int32(4))
        
        }
    }
}


extension OAuthResponseUrlError: Equatable, Hashable {}

extension OAuthResponseUrlError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum ParseUrlError {

    
    
    case Generic(reason: String
    )
    case EmptyHost
    case IdnaError
    case InvalidPort
    case InvalidIpv4Address
    case InvalidIpv6Address
    case InvalidDomainCharacter
    case RelativeUrlWithoutBase
    case RelativeUrlWithCannotBeABaseBase
    case SetHostOnCannotBeABaseUrl
    case Overflow
}


public struct FfiConverterTypeParseUrlError: FfiConverterRustBuffer {
    typealias SwiftType = ParseUrlError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseUrlError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .EmptyHost
        case 3: return .IdnaError
        case 4: return .InvalidPort
        case 5: return .InvalidIpv4Address
        case 6: return .InvalidIpv6Address
        case 7: return .InvalidDomainCharacter
        case 8: return .RelativeUrlWithoutBase
        case 9: return .RelativeUrlWithCannotBeABaseBase
        case 10: return .SetHostOnCannotBeABaseUrl
        case 11: return .Overflow

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseUrlError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)
            
        
        case .EmptyHost:
            writeInt(&buf, Int32(2))
        
        
        case .IdnaError:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidPort:
            writeInt(&buf, Int32(4))
        
        
        case .InvalidIpv4Address:
            writeInt(&buf, Int32(5))
        
        
        case .InvalidIpv6Address:
            writeInt(&buf, Int32(6))
        
        
        case .InvalidDomainCharacter:
            writeInt(&buf, Int32(7))
        
        
        case .RelativeUrlWithoutBase:
            writeInt(&buf, Int32(8))
        
        
        case .RelativeUrlWithCannotBeABaseBase:
            writeInt(&buf, Int32(9))
        
        
        case .SetHostOnCannotBeABaseUrl:
            writeInt(&buf, Int32(10))
        
        
        case .Overflow:
            writeInt(&buf, Int32(11))
        
        }
    }
}


extension ParseUrlError: Equatable, Hashable {}

extension ParseUrlError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PluginStatus {
    
    case active
    case inactive
    case networkActive
}


public struct FfiConverterTypePluginStatus: FfiConverterRustBuffer {
    typealias SwiftType = PluginStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .active
        
        case 2: return .inactive
        
        case 3: return .networkActive
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PluginStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .active:
            writeInt(&buf, Int32(1))
        
        
        case .inactive:
            writeInt(&buf, Int32(2))
        
        
        case .networkActive:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypePluginStatus_lift(_ buf: RustBuffer) throws -> PluginStatus {
    return try FfiConverterTypePluginStatus.lift(buf)
}

public func FfiConverterTypePluginStatus_lower(_ value: PluginStatus) -> RustBuffer {
    return FfiConverterTypePluginStatus.lower(value)
}



extension PluginStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PostType {
    
    case post
    case page
    case attachment
    case navMenuItem
    case wpBlock
    case wpTemplate
    case wpTemplatePart
    case wpNavigation
    case wpFontFamily
    case wpFontFace
    case custom(String
    )
}


public struct FfiConverterTypePostType: FfiConverterRustBuffer {
    typealias SwiftType = PostType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .post
        
        case 2: return .page
        
        case 3: return .attachment
        
        case 4: return .navMenuItem
        
        case 5: return .wpBlock
        
        case 6: return .wpTemplate
        
        case 7: return .wpTemplatePart
        
        case 8: return .wpNavigation
        
        case 9: return .wpFontFamily
        
        case 10: return .wpFontFace
        
        case 11: return .custom(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PostType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .post:
            writeInt(&buf, Int32(1))
        
        
        case .page:
            writeInt(&buf, Int32(2))
        
        
        case .attachment:
            writeInt(&buf, Int32(3))
        
        
        case .navMenuItem:
            writeInt(&buf, Int32(4))
        
        
        case .wpBlock:
            writeInt(&buf, Int32(5))
        
        
        case .wpTemplate:
            writeInt(&buf, Int32(6))
        
        
        case .wpTemplatePart:
            writeInt(&buf, Int32(7))
        
        
        case .wpNavigation:
            writeInt(&buf, Int32(8))
        
        
        case .wpFontFamily:
            writeInt(&buf, Int32(9))
        
        
        case .wpFontFace:
            writeInt(&buf, Int32(10))
        
        
        case let .custom(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypePostType_lift(_ buf: RustBuffer) throws -> PostType {
    return try FfiConverterTypePostType.lift(buf)
}

public func FfiConverterTypePostType_lower(_ value: PostType) -> RustBuffer {
    return FfiConverterTypePostType.lower(value)
}



extension PostType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PostTypeCapabilities {
    
    case createPosts
    case deleteOthersPosts
    case deletePost
    case deletePosts
    case deletePrivatePosts
    case deletePublishedPosts
    case editOthersPosts
    case editPost
    case editPosts
    case editPrivatePosts
    case editPublishedPosts
    case publishPosts
    case read
    case readPost
    case readPrivatePosts
    case custom(String
    )
}


public struct FfiConverterTypePostTypeCapabilities: FfiConverterRustBuffer {
    typealias SwiftType = PostTypeCapabilities

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypeCapabilities {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .createPosts
        
        case 2: return .deleteOthersPosts
        
        case 3: return .deletePost
        
        case 4: return .deletePosts
        
        case 5: return .deletePrivatePosts
        
        case 6: return .deletePublishedPosts
        
        case 7: return .editOthersPosts
        
        case 8: return .editPost
        
        case 9: return .editPosts
        
        case 10: return .editPrivatePosts
        
        case 11: return .editPublishedPosts
        
        case 12: return .publishPosts
        
        case 13: return .read
        
        case 14: return .readPost
        
        case 15: return .readPrivatePosts
        
        case 16: return .custom(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PostTypeCapabilities, into buf: inout [UInt8]) {
        switch value {
        
        
        case .createPosts:
            writeInt(&buf, Int32(1))
        
        
        case .deleteOthersPosts:
            writeInt(&buf, Int32(2))
        
        
        case .deletePost:
            writeInt(&buf, Int32(3))
        
        
        case .deletePosts:
            writeInt(&buf, Int32(4))
        
        
        case .deletePrivatePosts:
            writeInt(&buf, Int32(5))
        
        
        case .deletePublishedPosts:
            writeInt(&buf, Int32(6))
        
        
        case .editOthersPosts:
            writeInt(&buf, Int32(7))
        
        
        case .editPost:
            writeInt(&buf, Int32(8))
        
        
        case .editPosts:
            writeInt(&buf, Int32(9))
        
        
        case .editPrivatePosts:
            writeInt(&buf, Int32(10))
        
        
        case .editPublishedPosts:
            writeInt(&buf, Int32(11))
        
        
        case .publishPosts:
            writeInt(&buf, Int32(12))
        
        
        case .read:
            writeInt(&buf, Int32(13))
        
        
        case .readPost:
            writeInt(&buf, Int32(14))
        
        
        case .readPrivatePosts:
            writeInt(&buf, Int32(15))
        
        
        case let .custom(v1):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypePostTypeCapabilities_lift(_ buf: RustBuffer) throws -> PostTypeCapabilities {
    return try FfiConverterTypePostTypeCapabilities.lift(buf)
}

public func FfiConverterTypePostTypeCapabilities_lower(_ value: PostTypeCapabilities) -> RustBuffer {
    return FfiConverterTypePostTypeCapabilities.lower(value)
}



extension PostTypeCapabilities: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PostTypeSupports {
    
    case author
    case comments
    case customFields
    case editor
    case excerpt
    case pageAttributes
    case postFormats
    case revisions
    case slug
    case thumbnail
    case title
    case trackbacks
    case custom(String
    )
}


public struct FfiConverterTypePostTypeSupports: FfiConverterRustBuffer {
    typealias SwiftType = PostTypeSupports

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PostTypeSupports {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .author
        
        case 2: return .comments
        
        case 3: return .customFields
        
        case 4: return .editor
        
        case 5: return .excerpt
        
        case 6: return .pageAttributes
        
        case 7: return .postFormats
        
        case 8: return .revisions
        
        case 9: return .slug
        
        case 10: return .thumbnail
        
        case 11: return .title
        
        case 12: return .trackbacks
        
        case 13: return .custom(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PostTypeSupports, into buf: inout [UInt8]) {
        switch value {
        
        
        case .author:
            writeInt(&buf, Int32(1))
        
        
        case .comments:
            writeInt(&buf, Int32(2))
        
        
        case .customFields:
            writeInt(&buf, Int32(3))
        
        
        case .editor:
            writeInt(&buf, Int32(4))
        
        
        case .excerpt:
            writeInt(&buf, Int32(5))
        
        
        case .pageAttributes:
            writeInt(&buf, Int32(6))
        
        
        case .postFormats:
            writeInt(&buf, Int32(7))
        
        
        case .revisions:
            writeInt(&buf, Int32(8))
        
        
        case .slug:
            writeInt(&buf, Int32(9))
        
        
        case .thumbnail:
            writeInt(&buf, Int32(10))
        
        
        case .title:
            writeInt(&buf, Int32(11))
        
        
        case .trackbacks:
            writeInt(&buf, Int32(12))
        
        
        case let .custom(v1):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypePostTypeSupports_lift(_ buf: RustBuffer) throws -> PostTypeSupports {
    return try FfiConverterTypePostTypeSupports.lift(buf)
}

public func FfiConverterTypePostTypeSupports_lower(_ value: PostTypeSupports) -> RustBuffer {
    return FfiConverterTypePostTypeSupports.lower(value)
}



extension PostTypeSupports: Equatable, Hashable {}




public enum RequestExecutionError {

    
    
    case RequestExecutionFailed(statusCode: UInt16?, reason: String
    )
}


public struct FfiConverterTypeRequestExecutionError: FfiConverterRustBuffer {
    typealias SwiftType = RequestExecutionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestExecutionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestExecutionFailed(
            statusCode: try FfiConverterOptionUInt16.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestExecutionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .RequestExecutionFailed(statusCode,reason):
            writeInt(&buf, Int32(1))
            FfiConverterOptionUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


extension RequestExecutionError: Equatable, Hashable {}

extension RequestExecutionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RequestMethod {
    
    case get
    case post
    case put
    case delete
    case head
}


public struct FfiConverterTypeRequestMethod: FfiConverterRustBuffer {
    typealias SwiftType = RequestMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .get
        
        case 2: return .post
        
        case 3: return .put
        
        case 4: return .delete
        
        case 5: return .head
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .get:
            writeInt(&buf, Int32(1))
        
        
        case .post:
            writeInt(&buf, Int32(2))
        
        
        case .put:
            writeInt(&buf, Int32(3))
        
        
        case .delete:
            writeInt(&buf, Int32(4))
        
        
        case .head:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeRequestMethod_lift(_ buf: RustBuffer) throws -> RequestMethod {
    return try FfiConverterTypeRequestMethod.lift(buf)
}

public func FfiConverterTypeRequestMethod_lower(_ value: RequestMethod) -> RustBuffer {
    return FfiConverterTypeRequestMethod.lower(value)
}



extension RequestMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SiteSettingsCommentStatus {
    
    case `open`
    case closed
    case custom(String
    )
}


public struct FfiConverterTypeSiteSettingsCommentStatus: FfiConverterRustBuffer {
    typealias SwiftType = SiteSettingsCommentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SiteSettingsCommentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`open`
        
        case 2: return .closed
        
        case 3: return .custom(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SiteSettingsCommentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`open`:
            writeInt(&buf, Int32(1))
        
        
        case .closed:
            writeInt(&buf, Int32(2))
        
        
        case let .custom(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSiteSettingsCommentStatus_lift(_ buf: RustBuffer) throws -> SiteSettingsCommentStatus {
    return try FfiConverterTypeSiteSettingsCommentStatus.lift(buf)
}

public func FfiConverterTypeSiteSettingsCommentStatus_lower(_ value: SiteSettingsCommentStatus) -> RustBuffer {
    return FfiConverterTypeSiteSettingsCommentStatus.lower(value)
}



extension SiteSettingsCommentStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SiteSettingsPingStatus {
    
    case `open`
    case closed
    case custom(String
    )
}


public struct FfiConverterTypeSiteSettingsPingStatus: FfiConverterRustBuffer {
    typealias SwiftType = SiteSettingsPingStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SiteSettingsPingStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`open`
        
        case 2: return .closed
        
        case 3: return .custom(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SiteSettingsPingStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`open`:
            writeInt(&buf, Int32(1))
        
        
        case .closed:
            writeInt(&buf, Int32(2))
        
        
        case let .custom(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSiteSettingsPingStatus_lift(_ buf: RustBuffer) throws -> SiteSettingsPingStatus {
    return try FfiConverterTypeSiteSettingsPingStatus.lift(buf)
}

public func FfiConverterTypeSiteSettingsPingStatus_lower(_ value: SiteSettingsPingStatus) -> RustBuffer {
    return FfiConverterTypeSiteSettingsPingStatus.lower(value)
}



extension SiteSettingsPingStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseApplicationPasswordFieldWithEditContext {
    
    case uuid
    case appId
    case name
    case created
    case lastUsed
    case lastIp
    case password
}


public struct FfiConverterTypeSparseApplicationPasswordFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = SparseApplicationPasswordFieldWithEditContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseApplicationPasswordFieldWithEditContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .uuid
        
        case 2: return .appId
        
        case 3: return .name
        
        case 4: return .created
        
        case 5: return .lastUsed
        
        case 6: return .lastIp
        
        case 7: return .password
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseApplicationPasswordFieldWithEditContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .uuid:
            writeInt(&buf, Int32(1))
        
        
        case .appId:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .created:
            writeInt(&buf, Int32(4))
        
        
        case .lastUsed:
            writeInt(&buf, Int32(5))
        
        
        case .lastIp:
            writeInt(&buf, Int32(6))
        
        
        case .password:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeSparseApplicationPasswordFieldWithEditContext_lift(_ buf: RustBuffer) throws -> SparseApplicationPasswordFieldWithEditContext {
    return try FfiConverterTypeSparseApplicationPasswordFieldWithEditContext.lift(buf)
}

public func FfiConverterTypeSparseApplicationPasswordFieldWithEditContext_lower(_ value: SparseApplicationPasswordFieldWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparseApplicationPasswordFieldWithEditContext.lower(value)
}



extension SparseApplicationPasswordFieldWithEditContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseApplicationPasswordFieldWithEmbedContext {
    
    case uuid
    case appId
    case name
}


public struct FfiConverterTypeSparseApplicationPasswordFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = SparseApplicationPasswordFieldWithEmbedContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseApplicationPasswordFieldWithEmbedContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .uuid
        
        case 2: return .appId
        
        case 3: return .name
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseApplicationPasswordFieldWithEmbedContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .uuid:
            writeInt(&buf, Int32(1))
        
        
        case .appId:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeSparseApplicationPasswordFieldWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparseApplicationPasswordFieldWithEmbedContext {
    return try FfiConverterTypeSparseApplicationPasswordFieldWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparseApplicationPasswordFieldWithEmbedContext_lower(_ value: SparseApplicationPasswordFieldWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparseApplicationPasswordFieldWithEmbedContext.lower(value)
}



extension SparseApplicationPasswordFieldWithEmbedContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseApplicationPasswordFieldWithViewContext {
    
    case uuid
    case appId
    case name
    case created
    case lastUsed
    case lastIp
}


public struct FfiConverterTypeSparseApplicationPasswordFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = SparseApplicationPasswordFieldWithViewContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseApplicationPasswordFieldWithViewContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .uuid
        
        case 2: return .appId
        
        case 3: return .name
        
        case 4: return .created
        
        case 5: return .lastUsed
        
        case 6: return .lastIp
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseApplicationPasswordFieldWithViewContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .uuid:
            writeInt(&buf, Int32(1))
        
        
        case .appId:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .created:
            writeInt(&buf, Int32(4))
        
        
        case .lastUsed:
            writeInt(&buf, Int32(5))
        
        
        case .lastIp:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeSparseApplicationPasswordFieldWithViewContext_lift(_ buf: RustBuffer) throws -> SparseApplicationPasswordFieldWithViewContext {
    return try FfiConverterTypeSparseApplicationPasswordFieldWithViewContext.lift(buf)
}

public func FfiConverterTypeSparseApplicationPasswordFieldWithViewContext_lower(_ value: SparseApplicationPasswordFieldWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparseApplicationPasswordFieldWithViewContext.lower(value)
}



extension SparseApplicationPasswordFieldWithViewContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparsePluginFieldWithEditContext {
    
    case plugin
    case status
    case name
    case pluginUri
    case author
    case authorUri
    case description
    case version
    case networkOnly
    case requiresWp
    case requiresPhp
    case textdomain
}


public struct FfiConverterTypeSparsePluginFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = SparsePluginFieldWithEditContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePluginFieldWithEditContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .plugin
        
        case 2: return .status
        
        case 3: return .name
        
        case 4: return .pluginUri
        
        case 5: return .author
        
        case 6: return .authorUri
        
        case 7: return .description
        
        case 8: return .version
        
        case 9: return .networkOnly
        
        case 10: return .requiresWp
        
        case 11: return .requiresPhp
        
        case 12: return .textdomain
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparsePluginFieldWithEditContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .plugin:
            writeInt(&buf, Int32(1))
        
        
        case .status:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .pluginUri:
            writeInt(&buf, Int32(4))
        
        
        case .author:
            writeInt(&buf, Int32(5))
        
        
        case .authorUri:
            writeInt(&buf, Int32(6))
        
        
        case .description:
            writeInt(&buf, Int32(7))
        
        
        case .version:
            writeInt(&buf, Int32(8))
        
        
        case .networkOnly:
            writeInt(&buf, Int32(9))
        
        
        case .requiresWp:
            writeInt(&buf, Int32(10))
        
        
        case .requiresPhp:
            writeInt(&buf, Int32(11))
        
        
        case .textdomain:
            writeInt(&buf, Int32(12))
        
        }
    }
}


public func FfiConverterTypeSparsePluginFieldWithEditContext_lift(_ buf: RustBuffer) throws -> SparsePluginFieldWithEditContext {
    return try FfiConverterTypeSparsePluginFieldWithEditContext.lift(buf)
}

public func FfiConverterTypeSparsePluginFieldWithEditContext_lower(_ value: SparsePluginFieldWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparsePluginFieldWithEditContext.lower(value)
}



extension SparsePluginFieldWithEditContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparsePluginFieldWithEmbedContext {
    
    case plugin
    case status
    case name
    case networkOnly
    case requiresWp
    case requiresPhp
}


public struct FfiConverterTypeSparsePluginFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = SparsePluginFieldWithEmbedContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePluginFieldWithEmbedContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .plugin
        
        case 2: return .status
        
        case 3: return .name
        
        case 4: return .networkOnly
        
        case 5: return .requiresWp
        
        case 6: return .requiresPhp
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparsePluginFieldWithEmbedContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .plugin:
            writeInt(&buf, Int32(1))
        
        
        case .status:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .networkOnly:
            writeInt(&buf, Int32(4))
        
        
        case .requiresWp:
            writeInt(&buf, Int32(5))
        
        
        case .requiresPhp:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeSparsePluginFieldWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparsePluginFieldWithEmbedContext {
    return try FfiConverterTypeSparsePluginFieldWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparsePluginFieldWithEmbedContext_lower(_ value: SparsePluginFieldWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparsePluginFieldWithEmbedContext.lower(value)
}



extension SparsePluginFieldWithEmbedContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparsePluginFieldWithViewContext {
    
    case plugin
    case status
    case name
    case pluginUri
    case author
    case authorUri
    case description
    case version
    case networkOnly
    case requiresWp
    case requiresPhp
    case textdomain
}


public struct FfiConverterTypeSparsePluginFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = SparsePluginFieldWithViewContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePluginFieldWithViewContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .plugin
        
        case 2: return .status
        
        case 3: return .name
        
        case 4: return .pluginUri
        
        case 5: return .author
        
        case 6: return .authorUri
        
        case 7: return .description
        
        case 8: return .version
        
        case 9: return .networkOnly
        
        case 10: return .requiresWp
        
        case 11: return .requiresPhp
        
        case 12: return .textdomain
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparsePluginFieldWithViewContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .plugin:
            writeInt(&buf, Int32(1))
        
        
        case .status:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .pluginUri:
            writeInt(&buf, Int32(4))
        
        
        case .author:
            writeInt(&buf, Int32(5))
        
        
        case .authorUri:
            writeInt(&buf, Int32(6))
        
        
        case .description:
            writeInt(&buf, Int32(7))
        
        
        case .version:
            writeInt(&buf, Int32(8))
        
        
        case .networkOnly:
            writeInt(&buf, Int32(9))
        
        
        case .requiresWp:
            writeInt(&buf, Int32(10))
        
        
        case .requiresPhp:
            writeInt(&buf, Int32(11))
        
        
        case .textdomain:
            writeInt(&buf, Int32(12))
        
        }
    }
}


public func FfiConverterTypeSparsePluginFieldWithViewContext_lift(_ buf: RustBuffer) throws -> SparsePluginFieldWithViewContext {
    return try FfiConverterTypeSparsePluginFieldWithViewContext.lift(buf)
}

public func FfiConverterTypeSparsePluginFieldWithViewContext_lower(_ value: SparsePluginFieldWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparsePluginFieldWithViewContext.lower(value)
}



extension SparsePluginFieldWithViewContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparsePostTypeDetailsFieldWithEditContext {
    
    case capabilities
    case description
    case hierarchical
    case viewable
    case labels
    case name
    case slug
    case supports
    case hasArchive
    case taxonomies
    case restBase
    case restNamespace
    case visibility
    case icon
}


public struct FfiConverterTypeSparsePostTypeDetailsFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = SparsePostTypeDetailsFieldWithEditContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypeDetailsFieldWithEditContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .capabilities
        
        case 2: return .description
        
        case 3: return .hierarchical
        
        case 4: return .viewable
        
        case 5: return .labels
        
        case 6: return .name
        
        case 7: return .slug
        
        case 8: return .supports
        
        case 9: return .hasArchive
        
        case 10: return .taxonomies
        
        case 11: return .restBase
        
        case 12: return .restNamespace
        
        case 13: return .visibility
        
        case 14: return .icon
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparsePostTypeDetailsFieldWithEditContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .capabilities:
            writeInt(&buf, Int32(1))
        
        
        case .description:
            writeInt(&buf, Int32(2))
        
        
        case .hierarchical:
            writeInt(&buf, Int32(3))
        
        
        case .viewable:
            writeInt(&buf, Int32(4))
        
        
        case .labels:
            writeInt(&buf, Int32(5))
        
        
        case .name:
            writeInt(&buf, Int32(6))
        
        
        case .slug:
            writeInt(&buf, Int32(7))
        
        
        case .supports:
            writeInt(&buf, Int32(8))
        
        
        case .hasArchive:
            writeInt(&buf, Int32(9))
        
        
        case .taxonomies:
            writeInt(&buf, Int32(10))
        
        
        case .restBase:
            writeInt(&buf, Int32(11))
        
        
        case .restNamespace:
            writeInt(&buf, Int32(12))
        
        
        case .visibility:
            writeInt(&buf, Int32(13))
        
        
        case .icon:
            writeInt(&buf, Int32(14))
        
        }
    }
}


public func FfiConverterTypeSparsePostTypeDetailsFieldWithEditContext_lift(_ buf: RustBuffer) throws -> SparsePostTypeDetailsFieldWithEditContext {
    return try FfiConverterTypeSparsePostTypeDetailsFieldWithEditContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypeDetailsFieldWithEditContext_lower(_ value: SparsePostTypeDetailsFieldWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypeDetailsFieldWithEditContext.lower(value)
}



extension SparsePostTypeDetailsFieldWithEditContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparsePostTypeDetailsFieldWithEmbedContext {
    
    case name
    case slug
    case restBase
    case restNamespace
    case icon
}


public struct FfiConverterTypeSparsePostTypeDetailsFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = SparsePostTypeDetailsFieldWithEmbedContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypeDetailsFieldWithEmbedContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .name
        
        case 2: return .slug
        
        case 3: return .restBase
        
        case 4: return .restNamespace
        
        case 5: return .icon
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparsePostTypeDetailsFieldWithEmbedContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .name:
            writeInt(&buf, Int32(1))
        
        
        case .slug:
            writeInt(&buf, Int32(2))
        
        
        case .restBase:
            writeInt(&buf, Int32(3))
        
        
        case .restNamespace:
            writeInt(&buf, Int32(4))
        
        
        case .icon:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeSparsePostTypeDetailsFieldWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparsePostTypeDetailsFieldWithEmbedContext {
    return try FfiConverterTypeSparsePostTypeDetailsFieldWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypeDetailsFieldWithEmbedContext_lower(_ value: SparsePostTypeDetailsFieldWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypeDetailsFieldWithEmbedContext.lower(value)
}



extension SparsePostTypeDetailsFieldWithEmbedContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparsePostTypeDetailsFieldWithViewContext {
    
    case description
    case hierarchical
    case name
    case slug
    case hasArchive
    case taxonomies
    case restBase
    case restNamespace
    case icon
}


public struct FfiConverterTypeSparsePostTypeDetailsFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = SparsePostTypeDetailsFieldWithViewContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypeDetailsFieldWithViewContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .description
        
        case 2: return .hierarchical
        
        case 3: return .name
        
        case 4: return .slug
        
        case 5: return .hasArchive
        
        case 6: return .taxonomies
        
        case 7: return .restBase
        
        case 8: return .restNamespace
        
        case 9: return .icon
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparsePostTypeDetailsFieldWithViewContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .description:
            writeInt(&buf, Int32(1))
        
        
        case .hierarchical:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .slug:
            writeInt(&buf, Int32(4))
        
        
        case .hasArchive:
            writeInt(&buf, Int32(5))
        
        
        case .taxonomies:
            writeInt(&buf, Int32(6))
        
        
        case .restBase:
            writeInt(&buf, Int32(7))
        
        
        case .restNamespace:
            writeInt(&buf, Int32(8))
        
        
        case .icon:
            writeInt(&buf, Int32(9))
        
        }
    }
}


public func FfiConverterTypeSparsePostTypeDetailsFieldWithViewContext_lift(_ buf: RustBuffer) throws -> SparsePostTypeDetailsFieldWithViewContext {
    return try FfiConverterTypeSparsePostTypeDetailsFieldWithViewContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypeDetailsFieldWithViewContext_lower(_ value: SparsePostTypeDetailsFieldWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypeDetailsFieldWithViewContext.lower(value)
}



extension SparsePostTypeDetailsFieldWithViewContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparsePostTypesResponseFieldWithEditContext {
    
    case postTypes
}


public struct FfiConverterTypeSparsePostTypesResponseFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = SparsePostTypesResponseFieldWithEditContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypesResponseFieldWithEditContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .postTypes
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparsePostTypesResponseFieldWithEditContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .postTypes:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeSparsePostTypesResponseFieldWithEditContext_lift(_ buf: RustBuffer) throws -> SparsePostTypesResponseFieldWithEditContext {
    return try FfiConverterTypeSparsePostTypesResponseFieldWithEditContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypesResponseFieldWithEditContext_lower(_ value: SparsePostTypesResponseFieldWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypesResponseFieldWithEditContext.lower(value)
}



extension SparsePostTypesResponseFieldWithEditContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparsePostTypesResponseFieldWithEmbedContext {
    
    case postTypes
}


public struct FfiConverterTypeSparsePostTypesResponseFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = SparsePostTypesResponseFieldWithEmbedContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypesResponseFieldWithEmbedContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .postTypes
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparsePostTypesResponseFieldWithEmbedContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .postTypes:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeSparsePostTypesResponseFieldWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparsePostTypesResponseFieldWithEmbedContext {
    return try FfiConverterTypeSparsePostTypesResponseFieldWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypesResponseFieldWithEmbedContext_lower(_ value: SparsePostTypesResponseFieldWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypesResponseFieldWithEmbedContext.lower(value)
}



extension SparsePostTypesResponseFieldWithEmbedContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparsePostTypesResponseFieldWithViewContext {
    
    case postTypes
}


public struct FfiConverterTypeSparsePostTypesResponseFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = SparsePostTypesResponseFieldWithViewContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePostTypesResponseFieldWithViewContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .postTypes
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparsePostTypesResponseFieldWithViewContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .postTypes:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeSparsePostTypesResponseFieldWithViewContext_lift(_ buf: RustBuffer) throws -> SparsePostTypesResponseFieldWithViewContext {
    return try FfiConverterTypeSparsePostTypesResponseFieldWithViewContext.lift(buf)
}

public func FfiConverterTypeSparsePostTypesResponseFieldWithViewContext_lower(_ value: SparsePostTypesResponseFieldWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparsePostTypesResponseFieldWithViewContext.lower(value)
}



extension SparsePostTypesResponseFieldWithViewContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseSiteSettingsFieldWithEditContext {
    
    case title
    case description
    case url
    case email
    case timezone
    case dateFormat
    case timeFormat
    case startOfWeek
    case language
    case useSmilies
    case defaultCategory
    case defaultPostFormat
    case postsPerPage
    case showOnFront
    case pageOnFront
    case pageForPosts
    case defaultPingStatus
    case defaultCommentStatus
    case siteLogo
    case siteIcon
}


public struct FfiConverterTypeSparseSiteSettingsFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = SparseSiteSettingsFieldWithEditContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseSiteSettingsFieldWithEditContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .title
        
        case 2: return .description
        
        case 3: return .url
        
        case 4: return .email
        
        case 5: return .timezone
        
        case 6: return .dateFormat
        
        case 7: return .timeFormat
        
        case 8: return .startOfWeek
        
        case 9: return .language
        
        case 10: return .useSmilies
        
        case 11: return .defaultCategory
        
        case 12: return .defaultPostFormat
        
        case 13: return .postsPerPage
        
        case 14: return .showOnFront
        
        case 15: return .pageOnFront
        
        case 16: return .pageForPosts
        
        case 17: return .defaultPingStatus
        
        case 18: return .defaultCommentStatus
        
        case 19: return .siteLogo
        
        case 20: return .siteIcon
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseSiteSettingsFieldWithEditContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .title:
            writeInt(&buf, Int32(1))
        
        
        case .description:
            writeInt(&buf, Int32(2))
        
        
        case .url:
            writeInt(&buf, Int32(3))
        
        
        case .email:
            writeInt(&buf, Int32(4))
        
        
        case .timezone:
            writeInt(&buf, Int32(5))
        
        
        case .dateFormat:
            writeInt(&buf, Int32(6))
        
        
        case .timeFormat:
            writeInt(&buf, Int32(7))
        
        
        case .startOfWeek:
            writeInt(&buf, Int32(8))
        
        
        case .language:
            writeInt(&buf, Int32(9))
        
        
        case .useSmilies:
            writeInt(&buf, Int32(10))
        
        
        case .defaultCategory:
            writeInt(&buf, Int32(11))
        
        
        case .defaultPostFormat:
            writeInt(&buf, Int32(12))
        
        
        case .postsPerPage:
            writeInt(&buf, Int32(13))
        
        
        case .showOnFront:
            writeInt(&buf, Int32(14))
        
        
        case .pageOnFront:
            writeInt(&buf, Int32(15))
        
        
        case .pageForPosts:
            writeInt(&buf, Int32(16))
        
        
        case .defaultPingStatus:
            writeInt(&buf, Int32(17))
        
        
        case .defaultCommentStatus:
            writeInt(&buf, Int32(18))
        
        
        case .siteLogo:
            writeInt(&buf, Int32(19))
        
        
        case .siteIcon:
            writeInt(&buf, Int32(20))
        
        }
    }
}


public func FfiConverterTypeSparseSiteSettingsFieldWithEditContext_lift(_ buf: RustBuffer) throws -> SparseSiteSettingsFieldWithEditContext {
    return try FfiConverterTypeSparseSiteSettingsFieldWithEditContext.lift(buf)
}

public func FfiConverterTypeSparseSiteSettingsFieldWithEditContext_lower(_ value: SparseSiteSettingsFieldWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparseSiteSettingsFieldWithEditContext.lower(value)
}



extension SparseSiteSettingsFieldWithEditContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseSiteSettingsFieldWithEmbedContext {
    
    case title
    case description
    case url
    case email
    case timezone
    case dateFormat
    case timeFormat
    case startOfWeek
    case language
    case useSmilies
    case defaultCategory
    case defaultPostFormat
    case postsPerPage
    case showOnFront
    case pageOnFront
    case pageForPosts
    case defaultPingStatus
    case defaultCommentStatus
    case siteLogo
    case siteIcon
}


public struct FfiConverterTypeSparseSiteSettingsFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = SparseSiteSettingsFieldWithEmbedContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseSiteSettingsFieldWithEmbedContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .title
        
        case 2: return .description
        
        case 3: return .url
        
        case 4: return .email
        
        case 5: return .timezone
        
        case 6: return .dateFormat
        
        case 7: return .timeFormat
        
        case 8: return .startOfWeek
        
        case 9: return .language
        
        case 10: return .useSmilies
        
        case 11: return .defaultCategory
        
        case 12: return .defaultPostFormat
        
        case 13: return .postsPerPage
        
        case 14: return .showOnFront
        
        case 15: return .pageOnFront
        
        case 16: return .pageForPosts
        
        case 17: return .defaultPingStatus
        
        case 18: return .defaultCommentStatus
        
        case 19: return .siteLogo
        
        case 20: return .siteIcon
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseSiteSettingsFieldWithEmbedContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .title:
            writeInt(&buf, Int32(1))
        
        
        case .description:
            writeInt(&buf, Int32(2))
        
        
        case .url:
            writeInt(&buf, Int32(3))
        
        
        case .email:
            writeInt(&buf, Int32(4))
        
        
        case .timezone:
            writeInt(&buf, Int32(5))
        
        
        case .dateFormat:
            writeInt(&buf, Int32(6))
        
        
        case .timeFormat:
            writeInt(&buf, Int32(7))
        
        
        case .startOfWeek:
            writeInt(&buf, Int32(8))
        
        
        case .language:
            writeInt(&buf, Int32(9))
        
        
        case .useSmilies:
            writeInt(&buf, Int32(10))
        
        
        case .defaultCategory:
            writeInt(&buf, Int32(11))
        
        
        case .defaultPostFormat:
            writeInt(&buf, Int32(12))
        
        
        case .postsPerPage:
            writeInt(&buf, Int32(13))
        
        
        case .showOnFront:
            writeInt(&buf, Int32(14))
        
        
        case .pageOnFront:
            writeInt(&buf, Int32(15))
        
        
        case .pageForPosts:
            writeInt(&buf, Int32(16))
        
        
        case .defaultPingStatus:
            writeInt(&buf, Int32(17))
        
        
        case .defaultCommentStatus:
            writeInt(&buf, Int32(18))
        
        
        case .siteLogo:
            writeInt(&buf, Int32(19))
        
        
        case .siteIcon:
            writeInt(&buf, Int32(20))
        
        }
    }
}


public func FfiConverterTypeSparseSiteSettingsFieldWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparseSiteSettingsFieldWithEmbedContext {
    return try FfiConverterTypeSparseSiteSettingsFieldWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparseSiteSettingsFieldWithEmbedContext_lower(_ value: SparseSiteSettingsFieldWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparseSiteSettingsFieldWithEmbedContext.lower(value)
}



extension SparseSiteSettingsFieldWithEmbedContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseSiteSettingsFieldWithViewContext {
    
    case title
    case description
    case url
    case email
    case timezone
    case dateFormat
    case timeFormat
    case startOfWeek
    case language
    case useSmilies
    case defaultCategory
    case defaultPostFormat
    case postsPerPage
    case showOnFront
    case pageOnFront
    case pageForPosts
    case defaultPingStatus
    case defaultCommentStatus
    case siteLogo
    case siteIcon
}


public struct FfiConverterTypeSparseSiteSettingsFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = SparseSiteSettingsFieldWithViewContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseSiteSettingsFieldWithViewContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .title
        
        case 2: return .description
        
        case 3: return .url
        
        case 4: return .email
        
        case 5: return .timezone
        
        case 6: return .dateFormat
        
        case 7: return .timeFormat
        
        case 8: return .startOfWeek
        
        case 9: return .language
        
        case 10: return .useSmilies
        
        case 11: return .defaultCategory
        
        case 12: return .defaultPostFormat
        
        case 13: return .postsPerPage
        
        case 14: return .showOnFront
        
        case 15: return .pageOnFront
        
        case 16: return .pageForPosts
        
        case 17: return .defaultPingStatus
        
        case 18: return .defaultCommentStatus
        
        case 19: return .siteLogo
        
        case 20: return .siteIcon
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseSiteSettingsFieldWithViewContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .title:
            writeInt(&buf, Int32(1))
        
        
        case .description:
            writeInt(&buf, Int32(2))
        
        
        case .url:
            writeInt(&buf, Int32(3))
        
        
        case .email:
            writeInt(&buf, Int32(4))
        
        
        case .timezone:
            writeInt(&buf, Int32(5))
        
        
        case .dateFormat:
            writeInt(&buf, Int32(6))
        
        
        case .timeFormat:
            writeInt(&buf, Int32(7))
        
        
        case .startOfWeek:
            writeInt(&buf, Int32(8))
        
        
        case .language:
            writeInt(&buf, Int32(9))
        
        
        case .useSmilies:
            writeInt(&buf, Int32(10))
        
        
        case .defaultCategory:
            writeInt(&buf, Int32(11))
        
        
        case .defaultPostFormat:
            writeInt(&buf, Int32(12))
        
        
        case .postsPerPage:
            writeInt(&buf, Int32(13))
        
        
        case .showOnFront:
            writeInt(&buf, Int32(14))
        
        
        case .pageOnFront:
            writeInt(&buf, Int32(15))
        
        
        case .pageForPosts:
            writeInt(&buf, Int32(16))
        
        
        case .defaultPingStatus:
            writeInt(&buf, Int32(17))
        
        
        case .defaultCommentStatus:
            writeInt(&buf, Int32(18))
        
        
        case .siteLogo:
            writeInt(&buf, Int32(19))
        
        
        case .siteIcon:
            writeInt(&buf, Int32(20))
        
        }
    }
}


public func FfiConverterTypeSparseSiteSettingsFieldWithViewContext_lift(_ buf: RustBuffer) throws -> SparseSiteSettingsFieldWithViewContext {
    return try FfiConverterTypeSparseSiteSettingsFieldWithViewContext.lift(buf)
}

public func FfiConverterTypeSparseSiteSettingsFieldWithViewContext_lower(_ value: SparseSiteSettingsFieldWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparseSiteSettingsFieldWithViewContext.lower(value)
}



extension SparseSiteSettingsFieldWithViewContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseUserFieldWithEditContext {
    
    case id
    case username
    case name
    case firstName
    case lastName
    case email
    case url
    case description
    case link
    case locale
    case nickname
    case slug
    case registeredDate
    case roles
    case capabilities
    case extraCapabilities
    case avatarUrls
}


public struct FfiConverterTypeSparseUserFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = SparseUserFieldWithEditContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseUserFieldWithEditContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .id
        
        case 2: return .username
        
        case 3: return .name
        
        case 4: return .firstName
        
        case 5: return .lastName
        
        case 6: return .email
        
        case 7: return .url
        
        case 8: return .description
        
        case 9: return .link
        
        case 10: return .locale
        
        case 11: return .nickname
        
        case 12: return .slug
        
        case 13: return .registeredDate
        
        case 14: return .roles
        
        case 15: return .capabilities
        
        case 16: return .extraCapabilities
        
        case 17: return .avatarUrls
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseUserFieldWithEditContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .id:
            writeInt(&buf, Int32(1))
        
        
        case .username:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .firstName:
            writeInt(&buf, Int32(4))
        
        
        case .lastName:
            writeInt(&buf, Int32(5))
        
        
        case .email:
            writeInt(&buf, Int32(6))
        
        
        case .url:
            writeInt(&buf, Int32(7))
        
        
        case .description:
            writeInt(&buf, Int32(8))
        
        
        case .link:
            writeInt(&buf, Int32(9))
        
        
        case .locale:
            writeInt(&buf, Int32(10))
        
        
        case .nickname:
            writeInt(&buf, Int32(11))
        
        
        case .slug:
            writeInt(&buf, Int32(12))
        
        
        case .registeredDate:
            writeInt(&buf, Int32(13))
        
        
        case .roles:
            writeInt(&buf, Int32(14))
        
        
        case .capabilities:
            writeInt(&buf, Int32(15))
        
        
        case .extraCapabilities:
            writeInt(&buf, Int32(16))
        
        
        case .avatarUrls:
            writeInt(&buf, Int32(17))
        
        }
    }
}


public func FfiConverterTypeSparseUserFieldWithEditContext_lift(_ buf: RustBuffer) throws -> SparseUserFieldWithEditContext {
    return try FfiConverterTypeSparseUserFieldWithEditContext.lift(buf)
}

public func FfiConverterTypeSparseUserFieldWithEditContext_lower(_ value: SparseUserFieldWithEditContext) -> RustBuffer {
    return FfiConverterTypeSparseUserFieldWithEditContext.lower(value)
}



extension SparseUserFieldWithEditContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseUserFieldWithEmbedContext {
    
    case id
    case name
    case url
    case description
    case link
    case slug
    case avatarUrls
}


public struct FfiConverterTypeSparseUserFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = SparseUserFieldWithEmbedContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseUserFieldWithEmbedContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .id
        
        case 2: return .name
        
        case 3: return .url
        
        case 4: return .description
        
        case 5: return .link
        
        case 6: return .slug
        
        case 7: return .avatarUrls
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseUserFieldWithEmbedContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .id:
            writeInt(&buf, Int32(1))
        
        
        case .name:
            writeInt(&buf, Int32(2))
        
        
        case .url:
            writeInt(&buf, Int32(3))
        
        
        case .description:
            writeInt(&buf, Int32(4))
        
        
        case .link:
            writeInt(&buf, Int32(5))
        
        
        case .slug:
            writeInt(&buf, Int32(6))
        
        
        case .avatarUrls:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeSparseUserFieldWithEmbedContext_lift(_ buf: RustBuffer) throws -> SparseUserFieldWithEmbedContext {
    return try FfiConverterTypeSparseUserFieldWithEmbedContext.lift(buf)
}

public func FfiConverterTypeSparseUserFieldWithEmbedContext_lower(_ value: SparseUserFieldWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeSparseUserFieldWithEmbedContext.lower(value)
}



extension SparseUserFieldWithEmbedContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseUserFieldWithViewContext {
    
    case id
    case name
    case url
    case description
    case link
    case slug
    case avatarUrls
}


public struct FfiConverterTypeSparseUserFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = SparseUserFieldWithViewContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseUserFieldWithViewContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .id
        
        case 2: return .name
        
        case 3: return .url
        
        case 4: return .description
        
        case 5: return .link
        
        case 6: return .slug
        
        case 7: return .avatarUrls
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseUserFieldWithViewContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .id:
            writeInt(&buf, Int32(1))
        
        
        case .name:
            writeInt(&buf, Int32(2))
        
        
        case .url:
            writeInt(&buf, Int32(3))
        
        
        case .description:
            writeInt(&buf, Int32(4))
        
        
        case .link:
            writeInt(&buf, Int32(5))
        
        
        case .slug:
            writeInt(&buf, Int32(6))
        
        
        case .avatarUrls:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeSparseUserFieldWithViewContext_lift(_ buf: RustBuffer) throws -> SparseUserFieldWithViewContext {
    return try FfiConverterTypeSparseUserFieldWithViewContext.lift(buf)
}

public func FfiConverterTypeSparseUserFieldWithViewContext_lower(_ value: SparseUserFieldWithViewContext) -> RustBuffer {
    return FfiConverterTypeSparseUserFieldWithViewContext.lower(value)
}



extension SparseUserFieldWithViewContext: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseWpSiteHealthDirectorySizesField {
    
    case databaseSize
    case fontsSize
    case pluginsSize
    case themesSize
    case totalSize
    case uploadsSize
    case wordpressSize
    case raw
}


public struct FfiConverterTypeSparseWpSiteHealthDirectorySizesField: FfiConverterRustBuffer {
    typealias SwiftType = SparseWpSiteHealthDirectorySizesField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseWpSiteHealthDirectorySizesField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .databaseSize
        
        case 2: return .fontsSize
        
        case 3: return .pluginsSize
        
        case 4: return .themesSize
        
        case 5: return .totalSize
        
        case 6: return .uploadsSize
        
        case 7: return .wordpressSize
        
        case 8: return .raw
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseWpSiteHealthDirectorySizesField, into buf: inout [UInt8]) {
        switch value {
        
        
        case .databaseSize:
            writeInt(&buf, Int32(1))
        
        
        case .fontsSize:
            writeInt(&buf, Int32(2))
        
        
        case .pluginsSize:
            writeInt(&buf, Int32(3))
        
        
        case .themesSize:
            writeInt(&buf, Int32(4))
        
        
        case .totalSize:
            writeInt(&buf, Int32(5))
        
        
        case .uploadsSize:
            writeInt(&buf, Int32(6))
        
        
        case .wordpressSize:
            writeInt(&buf, Int32(7))
        
        
        case .raw:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypeSparseWpSiteHealthDirectorySizesField_lift(_ buf: RustBuffer) throws -> SparseWpSiteHealthDirectorySizesField {
    return try FfiConverterTypeSparseWpSiteHealthDirectorySizesField.lift(buf)
}

public func FfiConverterTypeSparseWpSiteHealthDirectorySizesField_lower(_ value: SparseWpSiteHealthDirectorySizesField) -> RustBuffer {
    return FfiConverterTypeSparseWpSiteHealthDirectorySizesField.lower(value)
}



extension SparseWpSiteHealthDirectorySizesField: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseWpSiteHealthTestField {
    
    case actions
    case badge
    case description
    case label
    case status
    case test
}


public struct FfiConverterTypeSparseWpSiteHealthTestField: FfiConverterRustBuffer {
    typealias SwiftType = SparseWpSiteHealthTestField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseWpSiteHealthTestField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .actions
        
        case 2: return .badge
        
        case 3: return .description
        
        case 4: return .label
        
        case 5: return .status
        
        case 6: return .test
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseWpSiteHealthTestField, into buf: inout [UInt8]) {
        switch value {
        
        
        case .actions:
            writeInt(&buf, Int32(1))
        
        
        case .badge:
            writeInt(&buf, Int32(2))
        
        
        case .description:
            writeInt(&buf, Int32(3))
        
        
        case .label:
            writeInt(&buf, Int32(4))
        
        
        case .status:
            writeInt(&buf, Int32(5))
        
        
        case .test:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeSparseWpSiteHealthTestField_lift(_ buf: RustBuffer) throws -> SparseWpSiteHealthTestField {
    return try FfiConverterTypeSparseWpSiteHealthTestField.lift(buf)
}

public func FfiConverterTypeSparseWpSiteHealthTestField_lower(_ value: SparseWpSiteHealthTestField) -> RustBuffer {
    return FfiConverterTypeSparseWpSiteHealthTestField.lower(value)
}



extension SparseWpSiteHealthTestField: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UrlDiscoveryAttemptError {
    
    case failedToParseSiteUrl(siteUrl: String, error: ParseUrlError
    )
    case fetchApiRootUrlFailed(siteUrl: ParsedUrl, error: FetchApiRootUrlError
    )
    case fetchApiDetailsFailed(siteUrl: ParsedUrl, apiRootUrl: ParsedUrl, error: FetchApiDetailsError
    )
}


public struct FfiConverterTypeUrlDiscoveryAttemptError: FfiConverterRustBuffer {
    typealias SwiftType = UrlDiscoveryAttemptError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlDiscoveryAttemptError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .failedToParseSiteUrl(siteUrl: try FfiConverterString.read(from: &buf), error: try FfiConverterTypeParseUrlError.read(from: &buf)
        )
        
        case 2: return .fetchApiRootUrlFailed(siteUrl: try FfiConverterTypeParsedUrl.read(from: &buf), error: try FfiConverterTypeFetchApiRootUrlError.read(from: &buf)
        )
        
        case 3: return .fetchApiDetailsFailed(siteUrl: try FfiConverterTypeParsedUrl.read(from: &buf), apiRootUrl: try FfiConverterTypeParsedUrl.read(from: &buf), error: try FfiConverterTypeFetchApiDetailsError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UrlDiscoveryAttemptError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .failedToParseSiteUrl(siteUrl,error):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(siteUrl, into: &buf)
            FfiConverterTypeParseUrlError.write(error, into: &buf)
            
        
        case let .fetchApiRootUrlFailed(siteUrl,error):
            writeInt(&buf, Int32(2))
            FfiConverterTypeParsedUrl.write(siteUrl, into: &buf)
            FfiConverterTypeFetchApiRootUrlError.write(error, into: &buf)
            
        
        case let .fetchApiDetailsFailed(siteUrl,apiRootUrl,error):
            writeInt(&buf, Int32(3))
            FfiConverterTypeParsedUrl.write(siteUrl, into: &buf)
            FfiConverterTypeParsedUrl.write(apiRootUrl, into: &buf)
            FfiConverterTypeFetchApiDetailsError.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeUrlDiscoveryAttemptError_lift(_ buf: RustBuffer) throws -> UrlDiscoveryAttemptError {
    return try FfiConverterTypeUrlDiscoveryAttemptError.lift(buf)
}

public func FfiConverterTypeUrlDiscoveryAttemptError_lower(_ value: UrlDiscoveryAttemptError) -> RustBuffer {
    return FfiConverterTypeUrlDiscoveryAttemptError.lower(value)
}





public enum UrlDiscoveryError {

    
    
    case UrlDiscoveryFailed(attempts: [UrlDiscoveryState]
    )
}


public struct FfiConverterTypeUrlDiscoveryError: FfiConverterRustBuffer {
    typealias SwiftType = UrlDiscoveryError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlDiscoveryError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .UrlDiscoveryFailed(
            attempts: try FfiConverterSequenceTypeUrlDiscoveryState.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UrlDiscoveryError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .UrlDiscoveryFailed(attempts):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeUrlDiscoveryState.write(attempts, into: &buf)
            
        }
    }
}


extension UrlDiscoveryError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UrlDiscoveryState {
    
    case success(UrlDiscoveryAttemptSuccess
    )
    case failure(UrlDiscoveryAttemptError
    )
}


public struct FfiConverterTypeUrlDiscoveryState: FfiConverterRustBuffer {
    typealias SwiftType = UrlDiscoveryState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlDiscoveryState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success(try FfiConverterTypeUrlDiscoveryAttemptSuccess.read(from: &buf)
        )
        
        case 2: return .failure(try FfiConverterTypeUrlDiscoveryAttemptError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UrlDiscoveryState, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .success(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUrlDiscoveryAttemptSuccess.write(v1, into: &buf)
            
        
        case let .failure(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUrlDiscoveryAttemptError.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeUrlDiscoveryState_lift(_ buf: RustBuffer) throws -> UrlDiscoveryState {
    return try FfiConverterTypeUrlDiscoveryState.lift(buf)
}

public func FfiConverterTypeUrlDiscoveryState_lower(_ value: UrlDiscoveryState) -> RustBuffer {
    return FfiConverterTypeUrlDiscoveryState.lower(value)
}





public enum WpApiError {

    
    
    case InvalidStatusCode(statusCode: UInt16
    )
    case RequestExecutionFailed(statusCode: UInt16?, reason: String
    )
    case ResponseParsingError(reason: String, response: String
    )
    case SiteUrlParsingError(reason: String
    )
    case UnknownError(statusCode: UInt16, response: String
    )
    case WpError(errorCode: WpErrorCode, errorMessage: String, statusCode: UInt16, response: String
    )
}


public struct FfiConverterTypeWpApiError: FfiConverterRustBuffer {
    typealias SwiftType = WpApiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidStatusCode(
            statusCode: try FfiConverterUInt16.read(from: &buf)
            )
        case 2: return .RequestExecutionFailed(
            statusCode: try FfiConverterOptionUInt16.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )
        case 3: return .ResponseParsingError(
            reason: try FfiConverterString.read(from: &buf), 
            response: try FfiConverterString.read(from: &buf)
            )
        case 4: return .SiteUrlParsingError(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 5: return .UnknownError(
            statusCode: try FfiConverterUInt16.read(from: &buf), 
            response: try FfiConverterString.read(from: &buf)
            )
        case 6: return .WpError(
            errorCode: try FfiConverterTypeWpErrorCode.read(from: &buf), 
            errorMessage: try FfiConverterString.read(from: &buf), 
            statusCode: try FfiConverterUInt16.read(from: &buf), 
            response: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpApiError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidStatusCode(statusCode):
            writeInt(&buf, Int32(1))
            FfiConverterUInt16.write(statusCode, into: &buf)
            
        
        case let .RequestExecutionFailed(statusCode,reason):
            writeInt(&buf, Int32(2))
            FfiConverterOptionUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .ResponseParsingError(reason,response):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(reason, into: &buf)
            FfiConverterString.write(response, into: &buf)
            
        
        case let .SiteUrlParsingError(reason):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .UnknownError(statusCode,response):
            writeInt(&buf, Int32(5))
            FfiConverterUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(response, into: &buf)
            
        
        case let .WpError(errorCode,errorMessage,statusCode,response):
            writeInt(&buf, Int32(6))
            FfiConverterTypeWpErrorCode.write(errorCode, into: &buf)
            FfiConverterString.write(errorMessage, into: &buf)
            FfiConverterUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(response, into: &buf)
            
        }
    }
}


extension WpApiError: Equatable, Hashable {}

extension WpApiError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpApiParamOrder {
    
    case asc
    case desc
}


public struct FfiConverterTypeWpApiParamOrder: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamOrder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiParamOrder {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .asc
        
        case 2: return .desc
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpApiParamOrder, into buf: inout [UInt8]) {
        switch value {
        
        
        case .asc:
            writeInt(&buf, Int32(1))
        
        
        case .desc:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeWpApiParamOrder_lift(_ buf: RustBuffer) throws -> WpApiParamOrder {
    return try FfiConverterTypeWpApiParamOrder.lift(buf)
}

public func FfiConverterTypeWpApiParamOrder_lower(_ value: WpApiParamOrder) -> RustBuffer {
    return FfiConverterTypeWpApiParamOrder.lower(value)
}



extension WpApiParamOrder: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpApiParamUsersHasPublishedPosts {
    
    case `true`
    case `false`
    case postTypes([String]
    )
}


public struct FfiConverterTypeWpApiParamUsersHasPublishedPosts: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersHasPublishedPosts

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiParamUsersHasPublishedPosts {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`true`
        
        case 2: return .`false`
        
        case 3: return .postTypes(try FfiConverterSequenceString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpApiParamUsersHasPublishedPosts, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`true`:
            writeInt(&buf, Int32(1))
        
        
        case .`false`:
            writeInt(&buf, Int32(2))
        
        
        case let .postTypes(v1):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeWpApiParamUsersHasPublishedPosts_lift(_ buf: RustBuffer) throws -> WpApiParamUsersHasPublishedPosts {
    return try FfiConverterTypeWpApiParamUsersHasPublishedPosts.lift(buf)
}

public func FfiConverterTypeWpApiParamUsersHasPublishedPosts_lower(_ value: WpApiParamUsersHasPublishedPosts) -> RustBuffer {
    return FfiConverterTypeWpApiParamUsersHasPublishedPosts.lower(value)
}



extension WpApiParamUsersHasPublishedPosts: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpApiParamUsersOrderBy {
    
    case id
    case include
    case name
    case registeredDate
    case slug
    case includeSlugs
    case email
    case url
}


public struct FfiConverterTypeWpApiParamUsersOrderBy: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersOrderBy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiParamUsersOrderBy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .id
        
        case 2: return .include
        
        case 3: return .name
        
        case 4: return .registeredDate
        
        case 5: return .slug
        
        case 6: return .includeSlugs
        
        case 7: return .email
        
        case 8: return .url
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpApiParamUsersOrderBy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .id:
            writeInt(&buf, Int32(1))
        
        
        case .include:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .registeredDate:
            writeInt(&buf, Int32(4))
        
        
        case .slug:
            writeInt(&buf, Int32(5))
        
        
        case .includeSlugs:
            writeInt(&buf, Int32(6))
        
        
        case .email:
            writeInt(&buf, Int32(7))
        
        
        case .url:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypeWpApiParamUsersOrderBy_lift(_ buf: RustBuffer) throws -> WpApiParamUsersOrderBy {
    return try FfiConverterTypeWpApiParamUsersOrderBy.lift(buf)
}

public func FfiConverterTypeWpApiParamUsersOrderBy_lower(_ value: WpApiParamUsersOrderBy) -> RustBuffer {
    return FfiConverterTypeWpApiParamUsersOrderBy.lower(value)
}



extension WpApiParamUsersOrderBy: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpApiParamUsersWho {
    
    case all
    case authors
}


public struct FfiConverterTypeWpApiParamUsersWho: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersWho

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiParamUsersWho {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all
        
        case 2: return .authors
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpApiParamUsersWho, into buf: inout [UInt8]) {
        switch value {
        
        
        case .all:
            writeInt(&buf, Int32(1))
        
        
        case .authors:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeWpApiParamUsersWho_lift(_ buf: RustBuffer) throws -> WpApiParamUsersWho {
    return try FfiConverterTypeWpApiParamUsersWho.lift(buf)
}

public func FfiConverterTypeWpApiParamUsersWho_lower(_ value: WpApiParamUsersWho) -> RustBuffer {
    return FfiConverterTypeWpApiParamUsersWho.lower(value)
}



extension WpApiParamUsersWho: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpAuthentication {
    
    case authorizationHeader(token: String
    )
    case none
}


public struct FfiConverterTypeWpAuthentication: FfiConverterRustBuffer {
    typealias SwiftType = WpAuthentication

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpAuthentication {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .authorizationHeader(token: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpAuthentication, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .authorizationHeader(token):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(token, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeWpAuthentication_lift(_ buf: RustBuffer) throws -> WpAuthentication {
    return try FfiConverterTypeWpAuthentication.lift(buf)
}

public func FfiConverterTypeWpAuthentication_lower(_ value: WpAuthentication) -> RustBuffer {
    return FfiConverterTypeWpAuthentication.lower(value)
}



extension WpAuthentication: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpContext {
    
    case edit
    case embed
    case view
}


public struct FfiConverterTypeWpContext: FfiConverterRustBuffer {
    typealias SwiftType = WpContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .edit
        
        case 2: return .embed
        
        case 3: return .view
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .edit:
            writeInt(&buf, Int32(1))
        
        
        case .embed:
            writeInt(&buf, Int32(2))
        
        
        case .view:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeWpContext_lift(_ buf: RustBuffer) throws -> WpContext {
    return try FfiConverterTypeWpContext.lift(buf)
}

public func FfiConverterTypeWpContext_lower(_ value: WpContext) -> RustBuffer {
    return FfiConverterTypeWpContext.lower(value)
}



extension WpContext: Equatable, Hashable {}




public enum WpErrorCode {

    
    
    case ApplicationPasswordNotFound
    case CannotCreateApplicationPasswords
    case CannotCreateUser
    case CannotDeleteActivePlugin
    case CannotDeleteApplicationPassword
    case CannotDeleteApplicationPasswords
    case CannotEdit
    case CannotEditApplicationPassword
    case CannotEditRoles
    case CannotIntrospectAppPasswordForNonAuthenticatedUser
    case CannotInstallPlugin
    case CannotListApplicationPasswords
    case CannotManagePlugins
    case CannotReadApplicationPassword
    case CannotView
    case CannotViewPlugin
    case CannotViewPlugins
    case ForbiddenContext
    case ForbiddenOrderBy
    case ForbiddenWho
    case InvalidParam
    case PluginNotFound
    case TypeInvalid
    case Unauthorized
    case UserCannotDelete
    case UserCannotView
    case UserInvalidEmail
    case UserInvalidId
    case UserInvalidReassign
    case UserInvalidRole
    case UserInvalidSlug
    case ApplicationPasswordsDisabled
    case ApplicationPasswordsDisabledForUser
    case CannotManageApplicationPasswords
    case CannotReadType
    case NoAuthenticatedAppPassword
    case CannotManageNetworkPlugins
    case NetworkOnlyPlugin
    case UserCreate
    /**
     * If a plugin is tried to be activated without the `activate_plugin` permission.
     * However, in a default setup a prior check of `activate_plugins` will fail
     * resulting in `CannotManagePlugins` error instead.
     */
    case CannotActivatePlugin
    /**
     * If a plugin is tried to be deactivated without the `deactivate_plugin` permission.
     * However, in a default setup a prior check of `deactivate_plugin` will fail
     * resulting in `CannotManagePlugins` error instead.
     */
    case CannotDeactivatePlugin
    case TrashNotSupported
    case UserExists
    case UserInvalidArgument
    case UserInvalidUsername
    case UserInvalidPassword
    case WpCoreCouldNotRemovePlugin
    case WpCoreCouldNotResumePlugin
    case WpCoreFolderExists
    case WpCoreFsError
    case WpCoreFsNoPluginsDir
    case WpCoreFsUnavailable
    case WpCoreNoPluginHeader
    case WpCorePluginInvalid
    case WpCorePluginMissingDependencies
    case WpCorePluginNotFound
    case WpCorePluginPhpIncompatible
    case WpCorePluginWpIncompatible
    case WpCorePluginWpPhpIncompatible
    case WpCorePluginsInvalid
    case WpCorePluginsApiFailed
    case WpCoreUnableToConnectToFilesystem
    case WpCoreUnableToDetermineInstalledPlugin
    case WpCoreUnexpectedOutput
    case CustomError(String
    )
}


public struct FfiConverterTypeWpErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = WpErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ApplicationPasswordNotFound
        case 2: return .CannotCreateApplicationPasswords
        case 3: return .CannotCreateUser
        case 4: return .CannotDeleteActivePlugin
        case 5: return .CannotDeleteApplicationPassword
        case 6: return .CannotDeleteApplicationPasswords
        case 7: return .CannotEdit
        case 8: return .CannotEditApplicationPassword
        case 9: return .CannotEditRoles
        case 10: return .CannotIntrospectAppPasswordForNonAuthenticatedUser
        case 11: return .CannotInstallPlugin
        case 12: return .CannotListApplicationPasswords
        case 13: return .CannotManagePlugins
        case 14: return .CannotReadApplicationPassword
        case 15: return .CannotView
        case 16: return .CannotViewPlugin
        case 17: return .CannotViewPlugins
        case 18: return .ForbiddenContext
        case 19: return .ForbiddenOrderBy
        case 20: return .ForbiddenWho
        case 21: return .InvalidParam
        case 22: return .PluginNotFound
        case 23: return .TypeInvalid
        case 24: return .Unauthorized
        case 25: return .UserCannotDelete
        case 26: return .UserCannotView
        case 27: return .UserInvalidEmail
        case 28: return .UserInvalidId
        case 29: return .UserInvalidReassign
        case 30: return .UserInvalidRole
        case 31: return .UserInvalidSlug
        case 32: return .ApplicationPasswordsDisabled
        case 33: return .ApplicationPasswordsDisabledForUser
        case 34: return .CannotManageApplicationPasswords
        case 35: return .CannotReadType
        case 36: return .NoAuthenticatedAppPassword
        case 37: return .CannotManageNetworkPlugins
        case 38: return .NetworkOnlyPlugin
        case 39: return .UserCreate
        case 40: return .CannotActivatePlugin
        case 41: return .CannotDeactivatePlugin
        case 42: return .TrashNotSupported
        case 43: return .UserExists
        case 44: return .UserInvalidArgument
        case 45: return .UserInvalidUsername
        case 46: return .UserInvalidPassword
        case 47: return .WpCoreCouldNotRemovePlugin
        case 48: return .WpCoreCouldNotResumePlugin
        case 49: return .WpCoreFolderExists
        case 50: return .WpCoreFsError
        case 51: return .WpCoreFsNoPluginsDir
        case 52: return .WpCoreFsUnavailable
        case 53: return .WpCoreNoPluginHeader
        case 54: return .WpCorePluginInvalid
        case 55: return .WpCorePluginMissingDependencies
        case 56: return .WpCorePluginNotFound
        case 57: return .WpCorePluginPhpIncompatible
        case 58: return .WpCorePluginWpIncompatible
        case 59: return .WpCorePluginWpPhpIncompatible
        case 60: return .WpCorePluginsInvalid
        case 61: return .WpCorePluginsApiFailed
        case 62: return .WpCoreUnableToConnectToFilesystem
        case 63: return .WpCoreUnableToDetermineInstalledPlugin
        case 64: return .WpCoreUnexpectedOutput
        case 65: return .CustomError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpErrorCode, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .ApplicationPasswordNotFound:
            writeInt(&buf, Int32(1))
        
        
        case .CannotCreateApplicationPasswords:
            writeInt(&buf, Int32(2))
        
        
        case .CannotCreateUser:
            writeInt(&buf, Int32(3))
        
        
        case .CannotDeleteActivePlugin:
            writeInt(&buf, Int32(4))
        
        
        case .CannotDeleteApplicationPassword:
            writeInt(&buf, Int32(5))
        
        
        case .CannotDeleteApplicationPasswords:
            writeInt(&buf, Int32(6))
        
        
        case .CannotEdit:
            writeInt(&buf, Int32(7))
        
        
        case .CannotEditApplicationPassword:
            writeInt(&buf, Int32(8))
        
        
        case .CannotEditRoles:
            writeInt(&buf, Int32(9))
        
        
        case .CannotIntrospectAppPasswordForNonAuthenticatedUser:
            writeInt(&buf, Int32(10))
        
        
        case .CannotInstallPlugin:
            writeInt(&buf, Int32(11))
        
        
        case .CannotListApplicationPasswords:
            writeInt(&buf, Int32(12))
        
        
        case .CannotManagePlugins:
            writeInt(&buf, Int32(13))
        
        
        case .CannotReadApplicationPassword:
            writeInt(&buf, Int32(14))
        
        
        case .CannotView:
            writeInt(&buf, Int32(15))
        
        
        case .CannotViewPlugin:
            writeInt(&buf, Int32(16))
        
        
        case .CannotViewPlugins:
            writeInt(&buf, Int32(17))
        
        
        case .ForbiddenContext:
            writeInt(&buf, Int32(18))
        
        
        case .ForbiddenOrderBy:
            writeInt(&buf, Int32(19))
        
        
        case .ForbiddenWho:
            writeInt(&buf, Int32(20))
        
        
        case .InvalidParam:
            writeInt(&buf, Int32(21))
        
        
        case .PluginNotFound:
            writeInt(&buf, Int32(22))
        
        
        case .TypeInvalid:
            writeInt(&buf, Int32(23))
        
        
        case .Unauthorized:
            writeInt(&buf, Int32(24))
        
        
        case .UserCannotDelete:
            writeInt(&buf, Int32(25))
        
        
        case .UserCannotView:
            writeInt(&buf, Int32(26))
        
        
        case .UserInvalidEmail:
            writeInt(&buf, Int32(27))
        
        
        case .UserInvalidId:
            writeInt(&buf, Int32(28))
        
        
        case .UserInvalidReassign:
            writeInt(&buf, Int32(29))
        
        
        case .UserInvalidRole:
            writeInt(&buf, Int32(30))
        
        
        case .UserInvalidSlug:
            writeInt(&buf, Int32(31))
        
        
        case .ApplicationPasswordsDisabled:
            writeInt(&buf, Int32(32))
        
        
        case .ApplicationPasswordsDisabledForUser:
            writeInt(&buf, Int32(33))
        
        
        case .CannotManageApplicationPasswords:
            writeInt(&buf, Int32(34))
        
        
        case .CannotReadType:
            writeInt(&buf, Int32(35))
        
        
        case .NoAuthenticatedAppPassword:
            writeInt(&buf, Int32(36))
        
        
        case .CannotManageNetworkPlugins:
            writeInt(&buf, Int32(37))
        
        
        case .NetworkOnlyPlugin:
            writeInt(&buf, Int32(38))
        
        
        case .UserCreate:
            writeInt(&buf, Int32(39))
        
        
        case .CannotActivatePlugin:
            writeInt(&buf, Int32(40))
        
        
        case .CannotDeactivatePlugin:
            writeInt(&buf, Int32(41))
        
        
        case .TrashNotSupported:
            writeInt(&buf, Int32(42))
        
        
        case .UserExists:
            writeInt(&buf, Int32(43))
        
        
        case .UserInvalidArgument:
            writeInt(&buf, Int32(44))
        
        
        case .UserInvalidUsername:
            writeInt(&buf, Int32(45))
        
        
        case .UserInvalidPassword:
            writeInt(&buf, Int32(46))
        
        
        case .WpCoreCouldNotRemovePlugin:
            writeInt(&buf, Int32(47))
        
        
        case .WpCoreCouldNotResumePlugin:
            writeInt(&buf, Int32(48))
        
        
        case .WpCoreFolderExists:
            writeInt(&buf, Int32(49))
        
        
        case .WpCoreFsError:
            writeInt(&buf, Int32(50))
        
        
        case .WpCoreFsNoPluginsDir:
            writeInt(&buf, Int32(51))
        
        
        case .WpCoreFsUnavailable:
            writeInt(&buf, Int32(52))
        
        
        case .WpCoreNoPluginHeader:
            writeInt(&buf, Int32(53))
        
        
        case .WpCorePluginInvalid:
            writeInt(&buf, Int32(54))
        
        
        case .WpCorePluginMissingDependencies:
            writeInt(&buf, Int32(55))
        
        
        case .WpCorePluginNotFound:
            writeInt(&buf, Int32(56))
        
        
        case .WpCorePluginPhpIncompatible:
            writeInt(&buf, Int32(57))
        
        
        case .WpCorePluginWpIncompatible:
            writeInt(&buf, Int32(58))
        
        
        case .WpCorePluginWpPhpIncompatible:
            writeInt(&buf, Int32(59))
        
        
        case .WpCorePluginsInvalid:
            writeInt(&buf, Int32(60))
        
        
        case .WpCorePluginsApiFailed:
            writeInt(&buf, Int32(61))
        
        
        case .WpCoreUnableToConnectToFilesystem:
            writeInt(&buf, Int32(62))
        
        
        case .WpCoreUnableToDetermineInstalledPlugin:
            writeInt(&buf, Int32(63))
        
        
        case .WpCoreUnexpectedOutput:
            writeInt(&buf, Int32(64))
        
        
        case let .CustomError(v1):
            writeInt(&buf, Int32(65))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


extension WpErrorCode: Equatable, Hashable {}

extension WpErrorCode: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum WpNetworkHeaderMapError {

    
    
    case InvalidHeaderName(headerName: String
    )
    case InvalidHeaderValue(headerValue: String
    )
}


public struct FfiConverterTypeWpNetworkHeaderMapError: FfiConverterRustBuffer {
    typealias SwiftType = WpNetworkHeaderMapError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpNetworkHeaderMapError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidHeaderName(
            headerName: try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidHeaderValue(
            headerValue: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpNetworkHeaderMapError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidHeaderName(headerName):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(headerName, into: &buf)
            
        
        case let .InvalidHeaderValue(headerValue):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(headerValue, into: &buf)
            
        }
    }
}


extension WpNetworkHeaderMapError: Equatable, Hashable {}

extension WpNetworkHeaderMapError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpNetworkRequestBody: FfiConverterRustBuffer {
    typealias SwiftType = WpNetworkRequestBody?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpNetworkRequestBody.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpNetworkRequestBody.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeApplicationPasswordAppId: FfiConverterRustBuffer {
    typealias SwiftType = ApplicationPasswordAppId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeApplicationPasswordAppId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeApplicationPasswordAppId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeApplicationPasswordUuid: FfiConverterRustBuffer {
    typealias SwiftType = ApplicationPasswordUuid?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeApplicationPasswordUuid.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeApplicationPasswordUuid.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIpAddress: FfiConverterRustBuffer {
    typealias SwiftType = IpAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIpAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIpAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePluginDescription: FfiConverterRustBuffer {
    typealias SwiftType = PluginDescription?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePluginDescription.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePluginDescription.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePluginSlug: FfiConverterRustBuffer {
    typealias SwiftType = PluginSlug?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePluginSlug.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePluginSlug.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePostTypeLabels: FfiConverterRustBuffer {
    typealias SwiftType = PostTypeLabels?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePostTypeLabels.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePostTypeLabels.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePostTypeVisibility: FfiConverterRustBuffer {
    typealias SwiftType = PostTypeVisibility?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePostTypeVisibility.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePostTypeVisibility.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpSiteHealthDirectorySizeInfo: FfiConverterRustBuffer {
    typealias SwiftType = WpSiteHealthDirectorySizeInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpSiteHealthDirectorySizeInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpSiteHealthDirectorySizeInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpSiteHealthTestBadge: FfiConverterRustBuffer {
    typealias SwiftType = WpSiteHealthTestBadge?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpSiteHealthTestBadge.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpSiteHealthTestBadge.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePluginStatus: FfiConverterRustBuffer {
    typealias SwiftType = PluginStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePluginStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePluginStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSiteSettingsCommentStatus: FfiConverterRustBuffer {
    typealias SwiftType = SiteSettingsCommentStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSiteSettingsCommentStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSiteSettingsCommentStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSiteSettingsPingStatus: FfiConverterRustBuffer {
    typealias SwiftType = SiteSettingsPingStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSiteSettingsPingStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSiteSettingsPingStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpApiParamOrder: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamOrder?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpApiParamOrder.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpApiParamOrder.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpApiParamUsersHasPublishedPosts: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersHasPublishedPosts?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpApiParamUsersHasPublishedPosts.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpApiParamUsersHasPublishedPosts.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpApiParamUsersOrderBy: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersOrderBy?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpApiParamUsersOrderBy.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpApiParamUsersOrderBy.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpApiParamUsersWho: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersWho?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpApiParamUsersWho.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpApiParamUsersWho.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryStringBool: FfiConverterRustBuffer {
    typealias SwiftType = [String: Bool]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetails: FfiConverterRustBuffer {
    typealias SwiftType = [PostType: SparsePostTypeDetails]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [PostType: SparsePostTypeDetailsWithEditContext]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEditContext.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEditContext.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [PostType: SparsePostTypeDetailsWithEmbedContext]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEmbedContext.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEmbedContext.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryTypePostTypeTypeSparsePostTypeDetailsWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [PostType: SparsePostTypeDetailsWithViewContext]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetailsWithViewContext.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetailsWithViewContext.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryTypePostTypeCapabilitiesString: FfiConverterRustBuffer {
    typealias SwiftType = [PostTypeCapabilities: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryTypePostTypeCapabilitiesString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryTypePostTypeCapabilitiesString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryTypePostTypeSupportsBool: FfiConverterRustBuffer {
    typealias SwiftType = [PostTypeSupports: Bool]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryTypePostTypeSupportsBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryTypePostTypeSupportsBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUserId: FfiConverterRustBuffer {
    typealias SwiftType = UserId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeApplicationPasswordWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [ApplicationPasswordWithEditContext]

    public static func write(_ value: [ApplicationPasswordWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeApplicationPasswordWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ApplicationPasswordWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [ApplicationPasswordWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeApplicationPasswordWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeApplicationPasswordWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [ApplicationPasswordWithEmbedContext]

    public static func write(_ value: [ApplicationPasswordWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeApplicationPasswordWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ApplicationPasswordWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [ApplicationPasswordWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeApplicationPasswordWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeApplicationPasswordWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [ApplicationPasswordWithViewContext]

    public static func write(_ value: [ApplicationPasswordWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeApplicationPasswordWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ApplicationPasswordWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [ApplicationPasswordWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeApplicationPasswordWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePluginWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [PluginWithEditContext]

    public static func write(_ value: [PluginWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePluginWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PluginWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [PluginWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePluginWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePluginWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [PluginWithEmbedContext]

    public static func write(_ value: [PluginWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePluginWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PluginWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [PluginWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePluginWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePluginWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [PluginWithViewContext]

    public static func write(_ value: [PluginWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePluginWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PluginWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [PluginWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePluginWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseApplicationPasswordWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseApplicationPasswordWithEditContext]

    public static func write(_ value: [SparseApplicationPasswordWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseApplicationPasswordWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseApplicationPasswordWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseApplicationPasswordWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseApplicationPasswordWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseApplicationPasswordWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseApplicationPasswordWithEmbedContext]

    public static func write(_ value: [SparseApplicationPasswordWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseApplicationPasswordWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseApplicationPasswordWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseApplicationPasswordWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseApplicationPasswordWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseApplicationPasswordWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseApplicationPasswordWithViewContext]

    public static func write(_ value: [SparseApplicationPasswordWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseApplicationPasswordWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseApplicationPasswordWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseApplicationPasswordWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseApplicationPasswordWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePluginWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePluginWithEditContext]

    public static func write(_ value: [SparsePluginWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePluginWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePluginWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePluginWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePluginWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePluginWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePluginWithEmbedContext]

    public static func write(_ value: [SparsePluginWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePluginWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePluginWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePluginWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePluginWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePluginWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePluginWithViewContext]

    public static func write(_ value: [SparsePluginWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePluginWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePluginWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePluginWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePluginWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseUserWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseUserWithEditContext]

    public static func write(_ value: [SparseUserWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseUserWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseUserWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseUserWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseUserWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseUserWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseUserWithEmbedContext]

    public static func write(_ value: [SparseUserWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseUserWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseUserWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseUserWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseUserWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseUserWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseUserWithViewContext]

    public static func write(_ value: [SparseUserWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseUserWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseUserWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseUserWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseUserWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [UserWithEditContext]

    public static func write(_ value: [UserWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [UserWithEmbedContext]

    public static func write(_ value: [UserWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [UserWithViewContext]

    public static func write(_ value: [UserWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseApplicationPasswordFieldWithEditContext]

    public static func write(_ value: [SparseApplicationPasswordFieldWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseApplicationPasswordFieldWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseApplicationPasswordFieldWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseApplicationPasswordFieldWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseApplicationPasswordFieldWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseApplicationPasswordFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseApplicationPasswordFieldWithEmbedContext]

    public static func write(_ value: [SparseApplicationPasswordFieldWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseApplicationPasswordFieldWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseApplicationPasswordFieldWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseApplicationPasswordFieldWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseApplicationPasswordFieldWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseApplicationPasswordFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseApplicationPasswordFieldWithViewContext]

    public static func write(_ value: [SparseApplicationPasswordFieldWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseApplicationPasswordFieldWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseApplicationPasswordFieldWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseApplicationPasswordFieldWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseApplicationPasswordFieldWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePluginFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePluginFieldWithEditContext]

    public static func write(_ value: [SparsePluginFieldWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePluginFieldWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePluginFieldWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePluginFieldWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePluginFieldWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePluginFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePluginFieldWithEmbedContext]

    public static func write(_ value: [SparsePluginFieldWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePluginFieldWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePluginFieldWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePluginFieldWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePluginFieldWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePluginFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePluginFieldWithViewContext]

    public static func write(_ value: [SparsePluginFieldWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePluginFieldWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePluginFieldWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePluginFieldWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePluginFieldWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePostTypeDetailsFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePostTypeDetailsFieldWithEditContext]

    public static func write(_ value: [SparsePostTypeDetailsFieldWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePostTypeDetailsFieldWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePostTypeDetailsFieldWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePostTypeDetailsFieldWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePostTypeDetailsFieldWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePostTypeDetailsFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePostTypeDetailsFieldWithEmbedContext]

    public static func write(_ value: [SparsePostTypeDetailsFieldWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePostTypeDetailsFieldWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePostTypeDetailsFieldWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePostTypeDetailsFieldWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePostTypeDetailsFieldWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePostTypeDetailsFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePostTypeDetailsFieldWithViewContext]

    public static func write(_ value: [SparsePostTypeDetailsFieldWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePostTypeDetailsFieldWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePostTypeDetailsFieldWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePostTypeDetailsFieldWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePostTypeDetailsFieldWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseSiteSettingsFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseSiteSettingsFieldWithEditContext]

    public static func write(_ value: [SparseSiteSettingsFieldWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseSiteSettingsFieldWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseSiteSettingsFieldWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseSiteSettingsFieldWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseSiteSettingsFieldWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseSiteSettingsFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseSiteSettingsFieldWithEmbedContext]

    public static func write(_ value: [SparseSiteSettingsFieldWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseSiteSettingsFieldWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseSiteSettingsFieldWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseSiteSettingsFieldWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseSiteSettingsFieldWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseSiteSettingsFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseSiteSettingsFieldWithViewContext]

    public static func write(_ value: [SparseSiteSettingsFieldWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseSiteSettingsFieldWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseSiteSettingsFieldWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseSiteSettingsFieldWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseSiteSettingsFieldWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseUserFieldWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseUserFieldWithEditContext]

    public static func write(_ value: [SparseUserFieldWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseUserFieldWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseUserFieldWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseUserFieldWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseUserFieldWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseUserFieldWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseUserFieldWithEmbedContext]

    public static func write(_ value: [SparseUserFieldWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseUserFieldWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseUserFieldWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseUserFieldWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseUserFieldWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseUserFieldWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [SparseUserFieldWithViewContext]

    public static func write(_ value: [SparseUserFieldWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseUserFieldWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseUserFieldWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseUserFieldWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseUserFieldWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseWpSiteHealthDirectorySizesField: FfiConverterRustBuffer {
    typealias SwiftType = [SparseWpSiteHealthDirectorySizesField]

    public static func write(_ value: [SparseWpSiteHealthDirectorySizesField], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseWpSiteHealthDirectorySizesField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseWpSiteHealthDirectorySizesField] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseWpSiteHealthDirectorySizesField]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseWpSiteHealthDirectorySizesField.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseWpSiteHealthTestField: FfiConverterRustBuffer {
    typealias SwiftType = [SparseWpSiteHealthTestField]

    public static func write(_ value: [SparseWpSiteHealthTestField], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseWpSiteHealthTestField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseWpSiteHealthTestField] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseWpSiteHealthTestField]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseWpSiteHealthTestField.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUrlDiscoveryState: FfiConverterRustBuffer {
    typealias SwiftType = [UrlDiscoveryState]

    public static func write(_ value: [UrlDiscoveryState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUrlDiscoveryState.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UrlDiscoveryState] {
        let len: Int32 = try readInt(&buf)
        var seq = [UrlDiscoveryState]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUrlDiscoveryState.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserId: FfiConverterRustBuffer {
    typealias SwiftType = [UserId]

    public static func write(_ value: [UserId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserId] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePostTypeTypePostTypeDetailsWithEditContext: FfiConverterRustBuffer {
    public static func write(_ value: [PostType: PostTypeDetailsWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePostType.write(key, into: &buf)
            FfiConverterTypePostTypeDetailsWithEditContext.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PostType: PostTypeDetailsWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var dict = [PostType: PostTypeDetailsWithEditContext]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePostType.read(from: &buf)
            let value = try FfiConverterTypePostTypeDetailsWithEditContext.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePostTypeTypePostTypeDetailsWithEmbedContext: FfiConverterRustBuffer {
    public static func write(_ value: [PostType: PostTypeDetailsWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePostType.write(key, into: &buf)
            FfiConverterTypePostTypeDetailsWithEmbedContext.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PostType: PostTypeDetailsWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var dict = [PostType: PostTypeDetailsWithEmbedContext]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePostType.read(from: &buf)
            let value = try FfiConverterTypePostTypeDetailsWithEmbedContext.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePostTypeTypePostTypeDetailsWithViewContext: FfiConverterRustBuffer {
    public static func write(_ value: [PostType: PostTypeDetailsWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePostType.write(key, into: &buf)
            FfiConverterTypePostTypeDetailsWithViewContext.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PostType: PostTypeDetailsWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var dict = [PostType: PostTypeDetailsWithViewContext]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePostType.read(from: &buf)
            let value = try FfiConverterTypePostTypeDetailsWithViewContext.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetails: FfiConverterRustBuffer {
    public static func write(_ value: [PostType: SparsePostTypeDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePostType.write(key, into: &buf)
            FfiConverterTypeSparsePostTypeDetails.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PostType: SparsePostTypeDetails] {
        let len: Int32 = try readInt(&buf)
        var dict = [PostType: SparsePostTypeDetails]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePostType.read(from: &buf)
            let value = try FfiConverterTypeSparsePostTypeDetails.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEditContext: FfiConverterRustBuffer {
    public static func write(_ value: [PostType: SparsePostTypeDetailsWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePostType.write(key, into: &buf)
            FfiConverterTypeSparsePostTypeDetailsWithEditContext.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PostType: SparsePostTypeDetailsWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var dict = [PostType: SparsePostTypeDetailsWithEditContext]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePostType.read(from: &buf)
            let value = try FfiConverterTypeSparsePostTypeDetailsWithEditContext.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetailsWithEmbedContext: FfiConverterRustBuffer {
    public static func write(_ value: [PostType: SparsePostTypeDetailsWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePostType.write(key, into: &buf)
            FfiConverterTypeSparsePostTypeDetailsWithEmbedContext.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PostType: SparsePostTypeDetailsWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var dict = [PostType: SparsePostTypeDetailsWithEmbedContext]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePostType.read(from: &buf)
            let value = try FfiConverterTypeSparsePostTypeDetailsWithEmbedContext.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePostTypeTypeSparsePostTypeDetailsWithViewContext: FfiConverterRustBuffer {
    public static func write(_ value: [PostType: SparsePostTypeDetailsWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePostType.write(key, into: &buf)
            FfiConverterTypeSparsePostTypeDetailsWithViewContext.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PostType: SparsePostTypeDetailsWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var dict = [PostType: SparsePostTypeDetailsWithViewContext]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePostType.read(from: &buf)
            let value = try FfiConverterTypeSparsePostTypeDetailsWithViewContext.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePostTypeCapabilitiesString: FfiConverterRustBuffer {
    public static func write(_ value: [PostTypeCapabilities: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePostTypeCapabilities.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PostTypeCapabilities: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [PostTypeCapabilities: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePostTypeCapabilities.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypePostTypeSupportsBool: FfiConverterRustBuffer {
    public static func write(_ value: [PostTypeSupports: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypePostTypeSupports.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PostTypeSupports: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [PostTypeSupports: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypePostTypeSupports.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UserId = Int32
public struct FfiConverterTypeUserId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserId {
        return try FfiConverterInt32.read(from: &buf)
    }

    public static func write(_ value: UserId, into buf: inout [UInt8]) {
        return FfiConverterInt32.write(value, into: &buf)
    }

    public static func lift(_ value: Int32) throws -> UserId {
        return try FfiConverterInt32.lift(value)
    }

    public static func lower(_ value: UserId) -> Int32 {
        return FfiConverterInt32.lower(value)
    }
}


public func FfiConverterTypeUserId_lift(_ value: Int32) throws -> UserId {
    return try FfiConverterTypeUserId.lift(value)
}

public func FfiConverterTypeUserId_lower(_ value: UserId) -> Int32 {
    return FfiConverterTypeUserId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WpEndpointUrl = String
public struct FfiConverterTypeWpEndpointUrl: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpEndpointUrl {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: WpEndpointUrl, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> WpEndpointUrl {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: WpEndpointUrl) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeWpEndpointUrl_lift(_ value: RustBuffer) throws -> WpEndpointUrl {
    return try FfiConverterTypeWpEndpointUrl.lift(value)
}

public func FfiConverterTypeWpEndpointUrl_lower(_ value: WpEndpointUrl) -> RustBuffer {
    return FfiConverterTypeWpEndpointUrl.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountWpApi() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func extractLoginDetailsFromUrl(url: ParsedUrl)throws  -> WpApiApplicationPasswordDetails {
    return try  FfiConverterTypeWpApiApplicationPasswordDetails.lift(try rustCallWithError(FfiConverterTypeOAuthResponseUrlError.lift) {
    uniffi_wp_api_fn_func_extract_login_details_from_url(
        FfiConverterTypeParsedUrl.lower(url),$0
    )
})
}
public func wpAuthenticationFromUsernameAndPassword(username: String, password: String) -> WpAuthentication {
    return try!  FfiConverterTypeWpAuthentication.lift(try! rustCall() {
    uniffi_wp_api_fn_func_wp_authentication_from_username_and_password(
        FfiConverterString.lower(username),
        FfiConverterString.lower(password),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_wp_api_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_wp_api_checksum_func_extract_login_details_from_url() != 33603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_func_wp_authentication_from_username_and_password() != 52469) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_create() != 28747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_delete() != 64126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_delete_all() != 21799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_list_with_edit_context() != 47524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_list_with_embed_context() != 28973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_list_with_view_context() != 39100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_retrieve_current_with_edit_context() != 61040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_retrieve_current_with_embed_context() != 38017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_retrieve_current_with_view_context() != 21656) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_retrieve_with_edit_context() != 53417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_retrieve_with_embed_context() != 28813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_retrieve_with_view_context() != 21814) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_list_with_edit_context() != 36746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_list_with_embed_context() != 44351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_list_with_view_context() != 15295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_current_with_edit_context() != 13545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_current_with_embed_context() != 26033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_current_with_view_context() != 35743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_with_edit_context() != 58711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_with_embed_context() != 20644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_with_view_context() != 12386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_update() != 17590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_create() != 5377) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_delete() != 29928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_delete_all() != 748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_list_with_edit_context() != 24725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_list_with_embed_context() != 42532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_list_with_view_context() != 8280) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_retrieve_current_with_edit_context() != 17416) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_retrieve_current_with_embed_context() != 51753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_retrieve_current_with_view_context() != 53659) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_retrieve_with_edit_context() != 49096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_retrieve_with_embed_context() != 64624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_retrieve_with_view_context() != 20001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_list_with_edit_context() != 62518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_list_with_embed_context() != 64156) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_list_with_view_context() != 30495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_current_with_edit_context() != 37377) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_current_with_embed_context() != 43046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_current_with_view_context() != 51319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_with_edit_context() != 10005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_with_embed_context() != 26992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_with_view_context() != 9092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_update() != 29032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_parsedurl_url() != 51586) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_create() != 5886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_delete() != 21139) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_filter_list_with_edit_context() != 11224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_filter_list_with_embed_context() != 56723) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_filter_list_with_view_context() != 47052) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_filter_retrieve_with_edit_context() != 47699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_filter_retrieve_with_embed_context() != 42245) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_filter_retrieve_with_view_context() != 35931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_list_with_edit_context() != 28144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_list_with_embed_context() != 51715) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_list_with_view_context() != 22725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_retrieve_with_edit_context() != 42499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_retrieve_with_embed_context() != 11482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_retrieve_with_view_context() != 57123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_update() != 4390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_create() != 51926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_delete() != 38438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_filter_list_with_edit_context() != 64551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_filter_list_with_embed_context() != 44734) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_filter_list_with_view_context() != 48858) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_filter_retrieve_with_edit_context() != 60016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_filter_retrieve_with_embed_context() != 59969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_filter_retrieve_with_view_context() != 2209) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_list_with_edit_context() != 57195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_list_with_embed_context() != 50734) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_list_with_view_context() != 20383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_retrieve_with_edit_context() != 55162) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_retrieve_with_embed_context() != 19830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_retrieve_with_view_context() != 18919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_update() != 46564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestbuilder_filter_retrieve_with_edit_context() != 33386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestbuilder_filter_retrieve_with_embed_context() != 25516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestbuilder_filter_retrieve_with_view_context() != 37200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestbuilder_list_with_edit_context() != 5559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestbuilder_list_with_embed_context() != 25233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestbuilder_list_with_view_context() != 36262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestbuilder_retrieve_with_edit_context() != 17426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestbuilder_retrieve_with_embed_context() != 35565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestbuilder_retrieve_with_view_context() != 28985) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestexecutor_filter_retrieve_with_edit_context() != 64001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestexecutor_filter_retrieve_with_embed_context() != 49593) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestexecutor_filter_retrieve_with_view_context() != 19961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestexecutor_list_with_edit_context() != 32764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestexecutor_list_with_embed_context() != 9148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestexecutor_list_with_view_context() != 9232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestexecutor_retrieve_with_edit_context() != 31211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestexecutor_retrieve_with_embed_context() != 5443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_posttypesrequestexecutor_retrieve_with_view_context() != 43711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_requestexecutor_execute() != 39962) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestbuilder_filter_retrieve_with_edit_context() != 62127) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestbuilder_filter_retrieve_with_embed_context() != 26011) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestbuilder_filter_retrieve_with_view_context() != 6880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestbuilder_retrieve_with_edit_context() != 60562) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestbuilder_retrieve_with_embed_context() != 22956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestbuilder_retrieve_with_view_context() != 20930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestbuilder_update() != 65041) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestexecutor_filter_retrieve_with_edit_context() != 21947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestexecutor_filter_retrieve_with_embed_context() != 51872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestexecutor_filter_retrieve_with_view_context() != 63820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestexecutor_retrieve_with_edit_context() != 454) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestexecutor_retrieve_with_embed_context() != 52681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestexecutor_retrieve_with_view_context() != 37577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_sitesettingsrequestexecutor_update() != 50856) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapiclient_application_passwords() != 57830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapiclient_plugins() != 54558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapiclient_post_types() != 46907) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapiclient_site_settings() != 59933) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapiclient_users() != 2759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapiclient_wp_site_health_tests() != 198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapirequestbuilder_application_passwords() != 12259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapirequestbuilder_plugins() != 65526) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapirequestbuilder_post_types() != 137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapirequestbuilder_site_settings() != 52528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapirequestbuilder_users() != 41529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapirequestbuilder_wp_site_health_tests() != 57757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwploginclient_api_discovery() != 28272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_create() != 6684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_delete() != 54398) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_delete_me() != 63972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_list_with_edit_context() != 65110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_list_with_embed_context() != 6379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_list_with_view_context() != 41598) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_retrieve_me_with_edit_context() != 52852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_retrieve_me_with_embed_context() != 34265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_retrieve_me_with_view_context() != 22313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_retrieve_with_edit_context() != 736) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_retrieve_with_embed_context() != 34033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_retrieve_with_view_context() != 53069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_list_with_edit_context() != 1885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_list_with_embed_context() != 49398) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_list_with_view_context() != 7811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_me_with_edit_context() != 51915) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_me_with_embed_context() != 34510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_me_with_view_context() != 62545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_with_edit_context() != 50322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_with_embed_context() != 61113) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_with_view_context() != 21480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_update() != 6966) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_update_me() != 32323) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_create() != 50724) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_delete() != 20471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_delete_me() != 18459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_list_with_edit_context() != 18252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_list_with_embed_context() != 51180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_list_with_view_context() != 53365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_retrieve_me_with_edit_context() != 9825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_retrieve_me_with_embed_context() != 60357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_retrieve_me_with_view_context() != 55766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_retrieve_with_edit_context() != 59904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_retrieve_with_embed_context() != 56612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_retrieve_with_view_context() != 64714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_list_with_edit_context() != 51811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_list_with_embed_context() != 8582) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_list_with_view_context() != 17140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_me_with_edit_context() != 42507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_me_with_embed_context() != 58296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_me_with_view_context() != 28326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_with_edit_context() != 61453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_with_embed_context() != 12341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_with_view_context() != 49013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_update() != 25129) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_update_me() != 52559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpapidetails_find_application_passwords_authentication_url() != 4304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkheadermap_to_map() != 38263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequest_body() != 14272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequest_body_as_string() != 16088) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequest_header_map() != 64881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequest_method() != 5762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequest_url() != 46843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequestbody_contents() != 62522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_authorization_header() != 6286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_background_updates() != 25322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_directory_sizes() != 51108) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_dotorg_communication() != 28261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_filter_authorization_header() != 20168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_filter_background_updates() != 47047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_filter_directory_sizes() != 37928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_filter_dotorg_communication() != 51064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_filter_https_status() != 38274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_filter_loopback_requests() != 32421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_filter_page_cache() != 56198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_https_status() != 17060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_loopback_requests() != 58279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestbuilder_page_cache() != 6120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_authorization_header() != 18015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_background_updates() != 2901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_directory_sizes() != 20019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_dotorg_communication() != 14365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_filter_authorization_header() != 18967) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_filter_background_updates() != 50658) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_filter_directory_sizes() != 59117) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_filter_dotorg_communication() != 53652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_filter_https_status() != 17176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_filter_loopback_requests() != 28677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_filter_page_cache() != 4678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_https_status() != 53099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_loopback_requests() != 1716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpsitehealthtestsrequestexecutor_page_cache() != 51851) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_parsedurl_parse() != 30042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_uniffiwpapiclient_new() != 23745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_uniffiwpapirequestbuilder_new() != 62069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_uniffiwploginclient_new() != 26720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_wpnetworkheadermap_from_map() != 30501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_wpnetworkheadermap_from_multi_map() != 50205) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitRequestExecutor()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all