// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(libwordpressFFI)
import libwordpressFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_wp_api_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_wp_api_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol ApplicationPasswordsRequestBuilderProtocol : AnyObject {
    
    func create(userId: UserId, params: ApplicationPasswordCreateParams)  -> WpNetworkRequest
    
    func delete(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)  -> WpNetworkRequest
    
    func deleteAll(userId: UserId)  -> WpNetworkRequest
    
    func filterList(userId: UserId, context: WpContext, fields: [SparseApplicationPasswordField])  -> WpNetworkRequest
    
    func filterRetrieve(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, context: WpContext, fields: [SparseApplicationPasswordField])  -> WpNetworkRequest
    
    func filterRetrieveCurrent(userId: UserId, context: WpContext, fields: [SparseApplicationPasswordField])  -> WpNetworkRequest
    
    func listWithEditContext(userId: UserId)  -> WpNetworkRequest
    
    func listWithEmbedContext(userId: UserId)  -> WpNetworkRequest
    
    func listWithViewContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveCurrentWithEditContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveCurrentWithEmbedContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveCurrentWithViewContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)  -> WpNetworkRequest
    
    func retrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)  -> WpNetworkRequest
    
    func retrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)  -> WpNetworkRequest
    
    func update(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, params: ApplicationPasswordUpdateParams)  -> WpNetworkRequest
    
}

open class ApplicationPasswordsRequestBuilder:
    ApplicationPasswordsRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_applicationpasswordsrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_applicationpasswordsrequestbuilder(pointer, $0) }
    }

    

    
open func create(userId: UserId, params: ApplicationPasswordCreateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_create(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordCreateParams.lower(params),$0
    )
})
}
    
open func delete(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_delete(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),$0
    )
})
}
    
open func deleteAll(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_delete_all(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func filterList(userId: UserId, context: WpContext, fields: [SparseApplicationPasswordField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_list(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeWpContext.lower(context),
        FfiConverterSequenceTypeSparseApplicationPasswordField.lower(fields),$0
    )
})
}
    
open func filterRetrieve(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, context: WpContext, fields: [SparseApplicationPasswordField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_retrieve(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),
        FfiConverterTypeWpContext.lower(context),
        FfiConverterSequenceTypeSparseApplicationPasswordField.lower(fields),$0
    )
})
}
    
open func filterRetrieveCurrent(userId: UserId, context: WpContext, fields: [SparseApplicationPasswordField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_filter_retrieve_current(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeWpContext.lower(context),
        FfiConverterSequenceTypeSparseApplicationPasswordField.lower(fields),$0
    )
})
}
    
open func listWithEditContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_list_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func listWithEmbedContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_list_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func listWithViewContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_list_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveCurrentWithEditContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_current_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveCurrentWithEmbedContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_current_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveCurrentWithViewContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_current_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),$0
    )
})
}
    
open func retrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),$0
    )
})
}
    
open func retrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),$0
    )
})
}
    
open func update(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, params: ApplicationPasswordUpdateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_applicationpasswordsrequestbuilder_update(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),
        FfiConverterTypeApplicationPasswordUpdateParams.lower(params),$0
    )
})
}
    

}

public struct FfiConverterTypeApplicationPasswordsRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ApplicationPasswordsRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ApplicationPasswordsRequestBuilder {
        return ApplicationPasswordsRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ApplicationPasswordsRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordsRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ApplicationPasswordsRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeApplicationPasswordsRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ApplicationPasswordsRequestBuilder {
    return try FfiConverterTypeApplicationPasswordsRequestBuilder.lift(pointer)
}

public func FfiConverterTypeApplicationPasswordsRequestBuilder_lower(_ value: ApplicationPasswordsRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeApplicationPasswordsRequestBuilder.lower(value)
}




public protocol ApplicationPasswordsRequestExecutorProtocol : AnyObject {
    
    func create(userId: UserId, params: ApplicationPasswordCreateParams) async throws  -> ApplicationPasswordWithEditContext
    
    func delete(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) async throws  -> ApplicationPasswordDeleteResponse
    
    func deleteAll(userId: UserId) async throws  -> ApplicationPasswordDeleteAllResponse
    
    func filterList(userId: UserId, context: WpContext, fields: [SparseApplicationPasswordField]) async throws  -> [SparseApplicationPassword]
    
    func filterRetrieve(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, context: WpContext, fields: [SparseApplicationPasswordField]) async throws  -> SparseApplicationPassword
    
    func filterRetrieveCurrent(userId: UserId, context: WpContext, fields: [SparseApplicationPasswordField]) async throws  -> SparseApplicationPassword
    
    func listWithEditContext(userId: UserId) async throws  -> [ApplicationPasswordWithEditContext]
    
    func listWithEmbedContext(userId: UserId) async throws  -> [ApplicationPasswordWithEmbedContext]
    
    func listWithViewContext(userId: UserId) async throws  -> [ApplicationPasswordWithViewContext]
    
    func retrieveCurrentWithEditContext(userId: UserId) async throws  -> ApplicationPasswordWithEditContext
    
    func retrieveCurrentWithEmbedContext(userId: UserId) async throws  -> ApplicationPasswordWithEmbedContext
    
    func retrieveCurrentWithViewContext(userId: UserId) async throws  -> ApplicationPasswordWithViewContext
    
    func retrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) async throws  -> ApplicationPasswordWithEditContext
    
    func retrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) async throws  -> ApplicationPasswordWithEmbedContext
    
    func retrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid) async throws  -> ApplicationPasswordWithViewContext
    
    func update(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, params: ApplicationPasswordUpdateParams) async throws  -> ApplicationPasswordWithEditContext
    
}

open class ApplicationPasswordsRequestExecutor:
    ApplicationPasswordsRequestExecutorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_applicationpasswordsrequestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_applicationpasswordsrequestexecutor(pointer, $0) }
    }

    

    
open func create(userId: UserId, params: ApplicationPasswordCreateParams)async throws  -> ApplicationPasswordWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_create(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordCreateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func delete(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)async throws  -> ApplicationPasswordDeleteResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordDeleteResponse.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func deleteAll(userId: UserId)async throws  -> ApplicationPasswordDeleteAllResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_delete_all(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordDeleteAllResponse.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterList(userId: UserId, context: WpContext, fields: [SparseApplicationPasswordField])async throws  -> [SparseApplicationPassword] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_list(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeWpContext.lower(context),FfiConverterSequenceTypeSparseApplicationPasswordField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparseApplicationPassword.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieve(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, context: WpContext, fields: [SparseApplicationPasswordField])async throws  -> SparseApplicationPassword {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_retrieve(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),FfiConverterTypeWpContext.lower(context),FfiConverterSequenceTypeSparseApplicationPasswordField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseApplicationPassword.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveCurrent(userId: UserId, context: WpContext, fields: [SparseApplicationPasswordField])async throws  -> SparseApplicationPassword {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_filter_retrieve_current(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeWpContext.lower(context),FfiConverterSequenceTypeSparseApplicationPasswordField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseApplicationPassword.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEditContext(userId: UserId)async throws  -> [ApplicationPasswordWithEditContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_list_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEmbedContext(userId: UserId)async throws  -> [ApplicationPasswordWithEmbedContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_list_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeApplicationPasswordWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithViewContext(userId: UserId)async throws  -> [ApplicationPasswordWithViewContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_list_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeApplicationPasswordWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveCurrentWithEditContext(userId: UserId)async throws  -> ApplicationPasswordWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_current_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveCurrentWithEmbedContext(userId: UserId)async throws  -> ApplicationPasswordWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_current_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveCurrentWithViewContext(userId: UserId)async throws  -> ApplicationPasswordWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_current_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEditContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)async throws  -> ApplicationPasswordWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEmbedContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)async throws  -> ApplicationPasswordWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithViewContext(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid)async throws  -> ApplicationPasswordWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func update(userId: UserId, applicationPasswordUuid: ApplicationPasswordUuid, params: ApplicationPasswordUpdateParams)async throws  -> ApplicationPasswordWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_applicationpasswordsrequestexecutor_update(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeApplicationPasswordUuid.lower(applicationPasswordUuid),FfiConverterTypeApplicationPasswordUpdateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeApplicationPasswordWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    

}

public struct FfiConverterTypeApplicationPasswordsRequestExecutor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ApplicationPasswordsRequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ApplicationPasswordsRequestExecutor {
        return ApplicationPasswordsRequestExecutor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ApplicationPasswordsRequestExecutor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordsRequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ApplicationPasswordsRequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeApplicationPasswordsRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> ApplicationPasswordsRequestExecutor {
    return try FfiConverterTypeApplicationPasswordsRequestExecutor.lift(pointer)
}

public func FfiConverterTypeApplicationPasswordsRequestExecutor_lower(_ value: ApplicationPasswordsRequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeApplicationPasswordsRequestExecutor.lower(value)
}




public protocol ParsedUrlProtocol : AnyObject {
    
    func url()  -> String
    
}

open class ParsedUrl:
    ParsedUrlProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_parsedurl(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_parsedurl(pointer, $0) }
    }

    
public static func parse(input: String)throws  -> ParsedUrl {
    return try  FfiConverterTypeParsedUrl.lift(try rustCallWithError(FfiConverterTypeParseUrlError.lift) {
    uniffi_wp_api_fn_constructor_parsedurl_parse(
        FfiConverterString.lower(input),$0
    )
})
}
    

    
open func url() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_wp_api_fn_method_parsedurl_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeParsedUrl: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ParsedUrl

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ParsedUrl {
        return ParsedUrl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ParsedUrl) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedUrl {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ParsedUrl, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeParsedUrl_lift(_ pointer: UnsafeMutableRawPointer) throws -> ParsedUrl {
    return try FfiConverterTypeParsedUrl.lift(pointer)
}

public func FfiConverterTypeParsedUrl_lower(_ value: ParsedUrl) -> UnsafeMutableRawPointer {
    return FfiConverterTypeParsedUrl.lower(value)
}




public protocol PluginsRequestBuilderProtocol : AnyObject {
    
    func create(params: PluginCreateParams)  -> WpNetworkRequest
    
    func delete(pluginSlug: PluginSlug)  -> WpNetworkRequest
    
    func filterList(context: WpContext, params: PluginListParams, fields: [SparsePluginField])  -> WpNetworkRequest
    
    func filterRetrieve(pluginSlug: PluginSlug, context: WpContext, fields: [SparsePluginField])  -> WpNetworkRequest
    
    func listWithEditContext(params: PluginListParams)  -> WpNetworkRequest
    
    func listWithEmbedContext(params: PluginListParams)  -> WpNetworkRequest
    
    func listWithViewContext(params: PluginListParams)  -> WpNetworkRequest
    
    func retrieveWithEditContext(pluginSlug: PluginSlug)  -> WpNetworkRequest
    
    func retrieveWithEmbedContext(pluginSlug: PluginSlug)  -> WpNetworkRequest
    
    func retrieveWithViewContext(pluginSlug: PluginSlug)  -> WpNetworkRequest
    
    func update(pluginSlug: PluginSlug, params: PluginUpdateParams)  -> WpNetworkRequest
    
}

open class PluginsRequestBuilder:
    PluginsRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_pluginsrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_pluginsrequestbuilder(pointer, $0) }
    }

    

    
open func create(params: PluginCreateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_create(self.uniffiClonePointer(),
        FfiConverterTypePluginCreateParams.lower(params),$0
    )
})
}
    
open func delete(pluginSlug: PluginSlug) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_delete(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),$0
    )
})
}
    
open func filterList(context: WpContext, params: PluginListParams, fields: [SparsePluginField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_filter_list(self.uniffiClonePointer(),
        FfiConverterTypeWpContext.lower(context),
        FfiConverterTypePluginListParams.lower(params),
        FfiConverterSequenceTypeSparsePluginField.lower(fields),$0
    )
})
}
    
open func filterRetrieve(pluginSlug: PluginSlug, context: WpContext, fields: [SparsePluginField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_filter_retrieve(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),
        FfiConverterTypeWpContext.lower(context),
        FfiConverterSequenceTypeSparsePluginField.lower(fields),$0
    )
})
}
    
open func listWithEditContext(params: PluginListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_list_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypePluginListParams.lower(params),$0
    )
})
}
    
open func listWithEmbedContext(params: PluginListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_list_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypePluginListParams.lower(params),$0
    )
})
}
    
open func listWithViewContext(params: PluginListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_list_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypePluginListParams.lower(params),$0
    )
})
}
    
open func retrieveWithEditContext(pluginSlug: PluginSlug) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),$0
    )
})
}
    
open func retrieveWithEmbedContext(pluginSlug: PluginSlug) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),$0
    )
})
}
    
open func retrieveWithViewContext(pluginSlug: PluginSlug) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),$0
    )
})
}
    
open func update(pluginSlug: PluginSlug, params: PluginUpdateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_pluginsrequestbuilder_update(self.uniffiClonePointer(),
        FfiConverterTypePluginSlug.lower(pluginSlug),
        FfiConverterTypePluginUpdateParams.lower(params),$0
    )
})
}
    

}

public struct FfiConverterTypePluginsRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PluginsRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PluginsRequestBuilder {
        return PluginsRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PluginsRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginsRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PluginsRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypePluginsRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> PluginsRequestBuilder {
    return try FfiConverterTypePluginsRequestBuilder.lift(pointer)
}

public func FfiConverterTypePluginsRequestBuilder_lower(_ value: PluginsRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypePluginsRequestBuilder.lower(value)
}




public protocol PluginsRequestExecutorProtocol : AnyObject {
    
    func create(params: PluginCreateParams) async throws  -> PluginWithEditContext
    
    func delete(pluginSlug: PluginSlug) async throws  -> PluginDeleteResponse
    
    func filterList(context: WpContext, params: PluginListParams, fields: [SparsePluginField]) async throws  -> [SparsePlugin]
    
    func filterRetrieve(pluginSlug: PluginSlug, context: WpContext, fields: [SparsePluginField]) async throws  -> SparsePlugin
    
    func listWithEditContext(params: PluginListParams) async throws  -> [PluginWithEditContext]
    
    func listWithEmbedContext(params: PluginListParams) async throws  -> [PluginWithEmbedContext]
    
    func listWithViewContext(params: PluginListParams) async throws  -> [PluginWithViewContext]
    
    func retrieveWithEditContext(pluginSlug: PluginSlug) async throws  -> PluginWithEditContext
    
    func retrieveWithEmbedContext(pluginSlug: PluginSlug) async throws  -> PluginWithEmbedContext
    
    func retrieveWithViewContext(pluginSlug: PluginSlug) async throws  -> PluginWithViewContext
    
    func update(pluginSlug: PluginSlug, params: PluginUpdateParams) async throws  -> PluginWithEditContext
    
}

open class PluginsRequestExecutor:
    PluginsRequestExecutorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_pluginsrequestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_pluginsrequestexecutor(pointer, $0) }
    }

    

    
open func create(params: PluginCreateParams)async throws  -> PluginWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_create(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginCreateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func delete(pluginSlug: PluginSlug)async throws  -> PluginDeleteResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginDeleteResponse.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterList(context: WpContext, params: PluginListParams, fields: [SparsePluginField])async throws  -> [SparsePlugin] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_filter_list(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWpContext.lower(context),FfiConverterTypePluginListParams.lower(params),FfiConverterSequenceTypeSparsePluginField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparsePlugin.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieve(pluginSlug: PluginSlug, context: WpContext, fields: [SparsePluginField])async throws  -> SparsePlugin {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_filter_retrieve(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug),FfiConverterTypeWpContext.lower(context),FfiConverterSequenceTypeSparsePluginField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparsePlugin.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEditContext(params: PluginListParams)async throws  -> [PluginWithEditContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_list_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePluginWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEmbedContext(params: PluginListParams)async throws  -> [PluginWithEmbedContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_list_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePluginWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithViewContext(params: PluginListParams)async throws  -> [PluginWithViewContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_list_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypePluginWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEditContext(pluginSlug: PluginSlug)async throws  -> PluginWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEmbedContext(pluginSlug: PluginSlug)async throws  -> PluginWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithViewContext(pluginSlug: PluginSlug)async throws  -> PluginWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func update(pluginSlug: PluginSlug, params: PluginUpdateParams)async throws  -> PluginWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_pluginsrequestexecutor_update(
                    self.uniffiClonePointer(),
                    FfiConverterTypePluginSlug.lower(pluginSlug),FfiConverterTypePluginUpdateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePluginWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    

}

public struct FfiConverterTypePluginsRequestExecutor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PluginsRequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PluginsRequestExecutor {
        return PluginsRequestExecutor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PluginsRequestExecutor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginsRequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PluginsRequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypePluginsRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> PluginsRequestExecutor {
    return try FfiConverterTypePluginsRequestExecutor.lift(pointer)
}

public func FfiConverterTypePluginsRequestExecutor_lower(_ value: PluginsRequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypePluginsRequestExecutor.lower(value)
}




public protocol RequestExecutor : AnyObject {
    
    func execute(request: WpNetworkRequest) async throws  -> WpNetworkResponse
    
}

open class RequestExecutorImpl:
    RequestExecutor {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_requestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_requestexecutor(pointer, $0) }
    }

    

    
open func execute(request: WpNetworkRequest)async throws  -> WpNetworkResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_requestexecutor_execute(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWpNetworkRequest.lower(request)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeWpNetworkResponse.lift,
            errorHandler: FfiConverterTypeRequestExecutionError.lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRequestExecutor {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRequestExecutor = UniffiVTableCallbackInterfaceRequestExecutor(
        execute: { (
            uniffiHandle: UInt64,
            request: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> WpNetworkResponse in
                guard let uniffiObj = try? FfiConverterTypeRequestExecutor.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.execute(
                     request: try FfiConverterTypeWpNetworkRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: WpNetworkResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeWpNetworkResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeRequestExecutionError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeRequestExecutor.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RequestExecutor: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRequestExecutor() {
    uniffi_wp_api_fn_init_callback_vtable_requestexecutor(&UniffiCallbackInterfaceRequestExecutor.vtable)
}

public struct FfiConverterTypeRequestExecutor: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<RequestExecutor>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RequestExecutor {
        return RequestExecutorImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RequestExecutor) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> RequestExecutor {
    return try FfiConverterTypeRequestExecutor.lift(pointer)
}

public func FfiConverterTypeRequestExecutor_lower(_ value: RequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRequestExecutor.lower(value)
}




public protocol UniffiWpApiClientProtocol : AnyObject {
    
    func applicationPasswords()  -> ApplicationPasswordsRequestExecutor
    
    func plugins()  -> PluginsRequestExecutor
    
    func users()  -> UsersRequestExecutor
    
}

open class UniffiWpApiClient:
    UniffiWpApiClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_uniffiwpapiclient(self.pointer, $0) }
    }
public convenience init(siteUrl: ParsedUrl, authentication: WpAuthentication, requestExecutor: RequestExecutor) {
    let pointer =
        try! rustCall() {
    uniffi_wp_api_fn_constructor_uniffiwpapiclient_new(
        FfiConverterTypeParsedUrl.lower(siteUrl),
        FfiConverterTypeWpAuthentication.lower(authentication),
        FfiConverterTypeRequestExecutor.lower(requestExecutor),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_uniffiwpapiclient(pointer, $0) }
    }

    

    
open func applicationPasswords() -> ApplicationPasswordsRequestExecutor {
    return try!  FfiConverterTypeApplicationPasswordsRequestExecutor.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapiclient_application_passwords(self.uniffiClonePointer(),$0
    )
})
}
    
open func plugins() -> PluginsRequestExecutor {
    return try!  FfiConverterTypePluginsRequestExecutor.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapiclient_plugins(self.uniffiClonePointer(),$0
    )
})
}
    
open func users() -> UsersRequestExecutor {
    return try!  FfiConverterTypeUsersRequestExecutor.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapiclient_users(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeUniffiWpApiClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UniffiWpApiClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpApiClient {
        return UniffiWpApiClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UniffiWpApiClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiWpApiClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UniffiWpApiClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUniffiWpApiClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpApiClient {
    return try FfiConverterTypeUniffiWpApiClient.lift(pointer)
}

public func FfiConverterTypeUniffiWpApiClient_lower(_ value: UniffiWpApiClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUniffiWpApiClient.lower(value)
}




public protocol UniffiWpApiRequestBuilderProtocol : AnyObject {
    
    func applicationPasswords()  -> ApplicationPasswordsRequestBuilder
    
    func plugins()  -> PluginsRequestBuilder
    
    func users()  -> UsersRequestBuilder
    
}

open class UniffiWpApiRequestBuilder:
    UniffiWpApiRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_uniffiwpapirequestbuilder(self.pointer, $0) }
    }
public convenience init(siteUrl: ParsedUrl, authentication: WpAuthentication) {
    let pointer =
        try! rustCall() {
    uniffi_wp_api_fn_constructor_uniffiwpapirequestbuilder_new(
        FfiConverterTypeParsedUrl.lower(siteUrl),
        FfiConverterTypeWpAuthentication.lower(authentication),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_uniffiwpapirequestbuilder(pointer, $0) }
    }

    

    
open func applicationPasswords() -> ApplicationPasswordsRequestBuilder {
    return try!  FfiConverterTypeApplicationPasswordsRequestBuilder.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapirequestbuilder_application_passwords(self.uniffiClonePointer(),$0
    )
})
}
    
open func plugins() -> PluginsRequestBuilder {
    return try!  FfiConverterTypePluginsRequestBuilder.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapirequestbuilder_plugins(self.uniffiClonePointer(),$0
    )
})
}
    
open func users() -> UsersRequestBuilder {
    return try!  FfiConverterTypeUsersRequestBuilder.lift(try! rustCall() {
    uniffi_wp_api_fn_method_uniffiwpapirequestbuilder_users(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeUniffiWpApiRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UniffiWpApiRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpApiRequestBuilder {
        return UniffiWpApiRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UniffiWpApiRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiWpApiRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UniffiWpApiRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUniffiWpApiRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpApiRequestBuilder {
    return try FfiConverterTypeUniffiWpApiRequestBuilder.lift(pointer)
}

public func FfiConverterTypeUniffiWpApiRequestBuilder_lower(_ value: UniffiWpApiRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUniffiWpApiRequestBuilder.lower(value)
}




public protocol UniffiWpLoginClientProtocol : AnyObject {
    
    func apiDiscovery(siteUrl: String) async throws  -> UrlDiscoverySuccess
    
}

open class UniffiWpLoginClient:
    UniffiWpLoginClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_uniffiwploginclient(self.pointer, $0) }
    }
public convenience init(requestExecutor: RequestExecutor) {
    let pointer =
        try! rustCall() {
    uniffi_wp_api_fn_constructor_uniffiwploginclient_new(
        FfiConverterTypeRequestExecutor.lower(requestExecutor),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_uniffiwploginclient(pointer, $0) }
    }

    

    
open func apiDiscovery(siteUrl: String)async throws  -> UrlDiscoverySuccess {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_uniffiwploginclient_api_discovery(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(siteUrl)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUrlDiscoverySuccess.lift,
            errorHandler: FfiConverterTypeUrlDiscoveryError.lift
        )
}
    

}

public struct FfiConverterTypeUniffiWpLoginClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UniffiWpLoginClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpLoginClient {
        return UniffiWpLoginClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UniffiWpLoginClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiWpLoginClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UniffiWpLoginClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUniffiWpLoginClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> UniffiWpLoginClient {
    return try FfiConverterTypeUniffiWpLoginClient.lift(pointer)
}

public func FfiConverterTypeUniffiWpLoginClient_lower(_ value: UniffiWpLoginClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUniffiWpLoginClient.lower(value)
}




public protocol UsersRequestBuilderProtocol : AnyObject {
    
    func create(params: UserCreateParams)  -> WpNetworkRequest
    
    func delete(userId: UserId, params: UserDeleteParams)  -> WpNetworkRequest
    
    func deleteMe(params: UserDeleteParams)  -> WpNetworkRequest
    
    func filterList(context: WpContext, params: UserListParams, fields: [SparseUserField])  -> WpNetworkRequest
    
    func filterRetrieve(userId: UserId, context: WpContext, fields: [SparseUserField])  -> WpNetworkRequest
    
    func filterRetrieveMe(context: WpContext, fields: [SparseUserField])  -> WpNetworkRequest
    
    func listWithEditContext(params: UserListParams)  -> WpNetworkRequest
    
    func listWithEmbedContext(params: UserListParams)  -> WpNetworkRequest
    
    func listWithViewContext(params: UserListParams)  -> WpNetworkRequest
    
    func retrieveMeWithEditContext()  -> WpNetworkRequest
    
    func retrieveMeWithEmbedContext()  -> WpNetworkRequest
    
    func retrieveMeWithViewContext()  -> WpNetworkRequest
    
    func retrieveWithEditContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveWithEmbedContext(userId: UserId)  -> WpNetworkRequest
    
    func retrieveWithViewContext(userId: UserId)  -> WpNetworkRequest
    
    func update(userId: UserId, params: UserUpdateParams)  -> WpNetworkRequest
    
    func updateMe(params: UserUpdateParams)  -> WpNetworkRequest
    
}

open class UsersRequestBuilder:
    UsersRequestBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_usersrequestbuilder(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_usersrequestbuilder(pointer, $0) }
    }

    

    
open func create(params: UserCreateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_create(self.uniffiClonePointer(),
        FfiConverterTypeUserCreateParams.lower(params),$0
    )
})
}
    
open func delete(userId: UserId, params: UserDeleteParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_delete(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeUserDeleteParams.lower(params),$0
    )
})
}
    
open func deleteMe(params: UserDeleteParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_delete_me(self.uniffiClonePointer(),
        FfiConverterTypeUserDeleteParams.lower(params),$0
    )
})
}
    
open func filterList(context: WpContext, params: UserListParams, fields: [SparseUserField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_list(self.uniffiClonePointer(),
        FfiConverterTypeWpContext.lower(context),
        FfiConverterTypeUserListParams.lower(params),
        FfiConverterSequenceTypeSparseUserField.lower(fields),$0
    )
})
}
    
open func filterRetrieve(userId: UserId, context: WpContext, fields: [SparseUserField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_retrieve(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeWpContext.lower(context),
        FfiConverterSequenceTypeSparseUserField.lower(fields),$0
    )
})
}
    
open func filterRetrieveMe(context: WpContext, fields: [SparseUserField]) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_filter_retrieve_me(self.uniffiClonePointer(),
        FfiConverterTypeWpContext.lower(context),
        FfiConverterSequenceTypeSparseUserField.lower(fields),$0
    )
})
}
    
open func listWithEditContext(params: UserListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_list_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserListParams.lower(params),$0
    )
})
}
    
open func listWithEmbedContext(params: UserListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_list_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserListParams.lower(params),$0
    )
})
}
    
open func listWithViewContext(params: UserListParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_list_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserListParams.lower(params),$0
    )
})
}
    
open func retrieveMeWithEditContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_me_with_edit_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func retrieveMeWithEmbedContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_me_with_embed_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func retrieveMeWithViewContext() -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_me_with_view_context(self.uniffiClonePointer(),$0
    )
})
}
    
open func retrieveWithEditContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_with_edit_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveWithEmbedContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_with_embed_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func retrieveWithViewContext(userId: UserId) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_retrieve_with_view_context(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),$0
    )
})
}
    
open func update(userId: UserId, params: UserUpdateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_update(self.uniffiClonePointer(),
        FfiConverterTypeUserId.lower(userId),
        FfiConverterTypeUserUpdateParams.lower(params),$0
    )
})
}
    
open func updateMe(params: UserUpdateParams) -> WpNetworkRequest {
    return try!  FfiConverterTypeWpNetworkRequest.lift(try! rustCall() {
    uniffi_wp_api_fn_method_usersrequestbuilder_update_me(self.uniffiClonePointer(),
        FfiConverterTypeUserUpdateParams.lower(params),$0
    )
})
}
    

}

public struct FfiConverterTypeUsersRequestBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UsersRequestBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UsersRequestBuilder {
        return UsersRequestBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UsersRequestBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UsersRequestBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UsersRequestBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUsersRequestBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> UsersRequestBuilder {
    return try FfiConverterTypeUsersRequestBuilder.lift(pointer)
}

public func FfiConverterTypeUsersRequestBuilder_lower(_ value: UsersRequestBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUsersRequestBuilder.lower(value)
}




public protocol UsersRequestExecutorProtocol : AnyObject {
    
    func create(params: UserCreateParams) async throws  -> UserWithEditContext
    
    func delete(userId: UserId, params: UserDeleteParams) async throws  -> UserDeleteResponse
    
    func deleteMe(params: UserDeleteParams) async throws  -> UserDeleteResponse
    
    func filterList(context: WpContext, params: UserListParams, fields: [SparseUserField]) async throws  -> [SparseUser]
    
    func filterRetrieve(userId: UserId, context: WpContext, fields: [SparseUserField]) async throws  -> SparseUser
    
    func filterRetrieveMe(context: WpContext, fields: [SparseUserField]) async throws  -> SparseUser
    
    func listWithEditContext(params: UserListParams) async throws  -> [UserWithEditContext]
    
    func listWithEmbedContext(params: UserListParams) async throws  -> [UserWithEmbedContext]
    
    func listWithViewContext(params: UserListParams) async throws  -> [UserWithViewContext]
    
    func retrieveMeWithEditContext() async throws  -> UserWithEditContext
    
    func retrieveMeWithEmbedContext() async throws  -> UserWithEmbedContext
    
    func retrieveMeWithViewContext() async throws  -> UserWithViewContext
    
    func retrieveWithEditContext(userId: UserId) async throws  -> UserWithEditContext
    
    func retrieveWithEmbedContext(userId: UserId) async throws  -> UserWithEmbedContext
    
    func retrieveWithViewContext(userId: UserId) async throws  -> UserWithViewContext
    
    func update(userId: UserId, params: UserUpdateParams) async throws  -> UserWithEditContext
    
    func updateMe(params: UserUpdateParams) async throws  -> UserWithEditContext
    
}

open class UsersRequestExecutor:
    UsersRequestExecutorProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_usersrequestexecutor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_usersrequestexecutor(pointer, $0) }
    }

    

    
open func create(params: UserCreateParams)async throws  -> UserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_create(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserCreateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func delete(userId: UserId, params: UserDeleteParams)async throws  -> UserDeleteResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeUserDeleteParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserDeleteResponse.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func deleteMe(params: UserDeleteParams)async throws  -> UserDeleteResponse {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_delete_me(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserDeleteParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserDeleteResponse.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterList(context: WpContext, params: UserListParams, fields: [SparseUserField])async throws  -> [SparseUser] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_list(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWpContext.lower(context),FfiConverterTypeUserListParams.lower(params),FfiConverterSequenceTypeSparseUserField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSparseUser.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieve(userId: UserId, context: WpContext, fields: [SparseUserField])async throws  -> SparseUser {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_retrieve(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeWpContext.lower(context),FfiConverterSequenceTypeSparseUserField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseUser.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func filterRetrieveMe(context: WpContext, fields: [SparseUserField])async throws  -> SparseUser {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_filter_retrieve_me(
                    self.uniffiClonePointer(),
                    FfiConverterTypeWpContext.lower(context),FfiConverterSequenceTypeSparseUserField.lower(fields)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSparseUser.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEditContext(params: UserListParams)async throws  -> [UserWithEditContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_list_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithEmbedContext(params: UserListParams)async throws  -> [UserWithEmbedContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_list_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUserWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func listWithViewContext(params: UserListParams)async throws  -> [UserWithViewContext] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_list_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserListParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUserWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveMeWithEditContext()async throws  -> UserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_me_with_edit_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveMeWithEmbedContext()async throws  -> UserWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_me_with_embed_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveMeWithViewContext()async throws  -> UserWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_me_with_view_context(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEditContext(userId: UserId)async throws  -> UserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_with_edit_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithEmbedContext(userId: UserId)async throws  -> UserWithEmbedContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_with_embed_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEmbedContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func retrieveWithViewContext(userId: UserId)async throws  -> UserWithViewContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_retrieve_with_view_context(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithViewContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func update(userId: UserId, params: UserUpdateParams)async throws  -> UserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_update(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserId.lower(userId),FfiConverterTypeUserUpdateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    
open func updateMe(params: UserUpdateParams)async throws  -> UserWithEditContext {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_wp_api_fn_method_usersrequestexecutor_update_me(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUserUpdateParams.lower(params)
                )
            },
            pollFunc: ffi_wp_api_rust_future_poll_rust_buffer,
            completeFunc: ffi_wp_api_rust_future_complete_rust_buffer,
            freeFunc: ffi_wp_api_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserWithEditContext.lift,
            errorHandler: FfiConverterTypeWpApiError.lift
        )
}
    

}

public struct FfiConverterTypeUsersRequestExecutor: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UsersRequestExecutor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UsersRequestExecutor {
        return UsersRequestExecutor(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UsersRequestExecutor) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UsersRequestExecutor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UsersRequestExecutor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUsersRequestExecutor_lift(_ pointer: UnsafeMutableRawPointer) throws -> UsersRequestExecutor {
    return try FfiConverterTypeUsersRequestExecutor.lift(pointer)
}

public func FfiConverterTypeUsersRequestExecutor_lower(_ value: UsersRequestExecutor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUsersRequestExecutor.lower(value)
}




public protocol WpApiDetailsProtocol : AnyObject {
    
    func findApplicationPasswordsAuthenticationUrl()  -> String?
    
}

open class WpApiDetails:
    WpApiDetailsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_wpapidetails(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_wpapidetails(pointer, $0) }
    }

    

    
open func findApplicationPasswordsAuthenticationUrl() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpapidetails_find_application_passwords_authentication_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeWpApiDetails: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WpApiDetails

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WpApiDetails {
        return WpApiDetails(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WpApiDetails) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiDetails {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WpApiDetails, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWpApiDetails_lift(_ pointer: UnsafeMutableRawPointer) throws -> WpApiDetails {
    return try FfiConverterTypeWpApiDetails.lift(pointer)
}

public func FfiConverterTypeWpApiDetails_lower(_ value: WpApiDetails) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWpApiDetails.lower(value)
}




public protocol WpNetworkHeaderMapProtocol : AnyObject {
    
    func toMap()  -> [String: [String]]
    
}

open class WpNetworkHeaderMap:
    WpNetworkHeaderMapProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_wpnetworkheadermap(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_wpnetworkheadermap(pointer, $0) }
    }

    
public static func fromMap(hashMap: [String: String])throws  -> WpNetworkHeaderMap {
    return try  FfiConverterTypeWpNetworkHeaderMap.lift(try rustCallWithError(FfiConverterTypeWpNetworkHeaderMapError.lift) {
    uniffi_wp_api_fn_constructor_wpnetworkheadermap_from_map(
        FfiConverterDictionaryStringString.lower(hashMap),$0
    )
})
}
    
public static func fromMultiMap(hashMap: [String: [String]])throws  -> WpNetworkHeaderMap {
    return try  FfiConverterTypeWpNetworkHeaderMap.lift(try rustCallWithError(FfiConverterTypeWpNetworkHeaderMapError.lift) {
    uniffi_wp_api_fn_constructor_wpnetworkheadermap_from_multi_map(
        FfiConverterDictionaryStringSequenceString.lower(hashMap),$0
    )
})
}
    

    
open func toMap() -> [String: [String]] {
    return try!  FfiConverterDictionaryStringSequenceString.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkheadermap_to_map(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeWpNetworkHeaderMap: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WpNetworkHeaderMap

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkHeaderMap {
        return WpNetworkHeaderMap(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WpNetworkHeaderMap) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpNetworkHeaderMap {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WpNetworkHeaderMap, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWpNetworkHeaderMap_lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkHeaderMap {
    return try FfiConverterTypeWpNetworkHeaderMap.lift(pointer)
}

public func FfiConverterTypeWpNetworkHeaderMap_lower(_ value: WpNetworkHeaderMap) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWpNetworkHeaderMap.lower(value)
}




public protocol WpNetworkRequestProtocol : AnyObject {
    
    func body()  -> WpNetworkRequestBody?
    
    func bodyAsString()  -> String?
    
    func headerMap()  -> WpNetworkHeaderMap
    
    func method()  -> RequestMethod
    
    func url()  -> WpEndpointUrl
    
}

open class WpNetworkRequest:
    WpNetworkRequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_wpnetworkrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_wpnetworkrequest(pointer, $0) }
    }

    

    
open func body() -> WpNetworkRequestBody? {
    return try!  FfiConverterOptionTypeWpNetworkRequestBody.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequest_body(self.uniffiClonePointer(),$0
    )
})
}
    
open func bodyAsString() -> String? {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequest_body_as_string(self.uniffiClonePointer(),$0
    )
})
}
    
open func headerMap() -> WpNetworkHeaderMap {
    return try!  FfiConverterTypeWpNetworkHeaderMap.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequest_header_map(self.uniffiClonePointer(),$0
    )
})
}
    
open func method() -> RequestMethod {
    return try!  FfiConverterTypeRequestMethod.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequest_method(self.uniffiClonePointer(),$0
    )
})
}
    
open func url() -> WpEndpointUrl {
    return try!  FfiConverterTypeWpEndpointUrl.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequest_url(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeWpNetworkRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WpNetworkRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkRequest {
        return WpNetworkRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WpNetworkRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpNetworkRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WpNetworkRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWpNetworkRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkRequest {
    return try FfiConverterTypeWpNetworkRequest.lift(pointer)
}

public func FfiConverterTypeWpNetworkRequest_lower(_ value: WpNetworkRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWpNetworkRequest.lower(value)
}




public protocol WpNetworkRequestBodyProtocol : AnyObject {
    
    func contents()  -> Data
    
}

open class WpNetworkRequestBody:
    WpNetworkRequestBodyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_wp_api_fn_clone_wpnetworkrequestbody(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_wp_api_fn_free_wpnetworkrequestbody(pointer, $0) }
    }

    

    
open func contents() -> Data {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_wp_api_fn_method_wpnetworkrequestbody_contents(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeWpNetworkRequestBody: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WpNetworkRequestBody

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkRequestBody {
        return WpNetworkRequestBody(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WpNetworkRequestBody) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpNetworkRequestBody {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WpNetworkRequestBody, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeWpNetworkRequestBody_lift(_ pointer: UnsafeMutableRawPointer) throws -> WpNetworkRequestBody {
    return try FfiConverterTypeWpNetworkRequestBody.lift(pointer)
}

public func FfiConverterTypeWpNetworkRequestBody_lower(_ value: WpNetworkRequestBody) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWpNetworkRequestBody.lower(value)
}


public struct ApplicationPasswordAppId {
    public let appId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(appId: String) {
        self.appId = appId
    }
}



extension ApplicationPasswordAppId: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordAppId, rhs: ApplicationPasswordAppId) -> Bool {
        if lhs.appId != rhs.appId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(appId)
    }
}


public struct FfiConverterTypeApplicationPasswordAppId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordAppId {
        return
            try ApplicationPasswordAppId(
                appId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordAppId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.appId, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordAppId_lift(_ buf: RustBuffer) throws -> ApplicationPasswordAppId {
    return try FfiConverterTypeApplicationPasswordAppId.lift(buf)
}

public func FfiConverterTypeApplicationPasswordAppId_lower(_ value: ApplicationPasswordAppId) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordAppId.lower(value)
}


public struct ApplicationPasswordCreateParams {
    /**
     * A UUID provided by the application to uniquely identify it.
     * It is recommended to use an UUID v5 with the URL or DNS namespace.
     */
    public let appId: String?
    /**
     * The name of the application password.
     */
    public let name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A UUID provided by the application to uniquely identify it.
         * It is recommended to use an UUID v5 with the URL or DNS namespace.
         */appId: String?, 
        /**
         * The name of the application password.
         */name: String) {
        self.appId = appId
        self.name = name
    }
}



extension ApplicationPasswordCreateParams: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordCreateParams, rhs: ApplicationPasswordCreateParams) -> Bool {
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(appId)
        hasher.combine(name)
    }
}


public struct FfiConverterTypeApplicationPasswordCreateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordCreateParams {
        return
            try ApplicationPasswordCreateParams(
                appId: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordCreateParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.appId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordCreateParams_lift(_ buf: RustBuffer) throws -> ApplicationPasswordCreateParams {
    return try FfiConverterTypeApplicationPasswordCreateParams.lift(buf)
}

public func FfiConverterTypeApplicationPasswordCreateParams_lower(_ value: ApplicationPasswordCreateParams) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordCreateParams.lower(value)
}


public struct ApplicationPasswordDeleteAllResponse {
    public let deleted: Bool
    public let count: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deleted: Bool, count: Int32) {
        self.deleted = deleted
        self.count = count
    }
}



extension ApplicationPasswordDeleteAllResponse: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordDeleteAllResponse, rhs: ApplicationPasswordDeleteAllResponse) -> Bool {
        if lhs.deleted != rhs.deleted {
            return false
        }
        if lhs.count != rhs.count {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deleted)
        hasher.combine(count)
    }
}


public struct FfiConverterTypeApplicationPasswordDeleteAllResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordDeleteAllResponse {
        return
            try ApplicationPasswordDeleteAllResponse(
                deleted: FfiConverterBool.read(from: &buf), 
                count: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordDeleteAllResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.deleted, into: &buf)
        FfiConverterInt32.write(value.count, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordDeleteAllResponse_lift(_ buf: RustBuffer) throws -> ApplicationPasswordDeleteAllResponse {
    return try FfiConverterTypeApplicationPasswordDeleteAllResponse.lift(buf)
}

public func FfiConverterTypeApplicationPasswordDeleteAllResponse_lower(_ value: ApplicationPasswordDeleteAllResponse) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordDeleteAllResponse.lower(value)
}


public struct ApplicationPasswordDeleteResponse {
    public let deleted: Bool
    public let previous: ApplicationPasswordWithEditContext

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deleted: Bool, previous: ApplicationPasswordWithEditContext) {
        self.deleted = deleted
        self.previous = previous
    }
}



extension ApplicationPasswordDeleteResponse: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordDeleteResponse, rhs: ApplicationPasswordDeleteResponse) -> Bool {
        if lhs.deleted != rhs.deleted {
            return false
        }
        if lhs.previous != rhs.previous {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deleted)
        hasher.combine(previous)
    }
}


public struct FfiConverterTypeApplicationPasswordDeleteResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordDeleteResponse {
        return
            try ApplicationPasswordDeleteResponse(
                deleted: FfiConverterBool.read(from: &buf), 
                previous: FfiConverterTypeApplicationPasswordWithEditContext.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordDeleteResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.deleted, into: &buf)
        FfiConverterTypeApplicationPasswordWithEditContext.write(value.previous, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordDeleteResponse_lift(_ buf: RustBuffer) throws -> ApplicationPasswordDeleteResponse {
    return try FfiConverterTypeApplicationPasswordDeleteResponse.lift(buf)
}

public func FfiConverterTypeApplicationPasswordDeleteResponse_lower(_ value: ApplicationPasswordDeleteResponse) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordDeleteResponse.lower(value)
}


public struct ApplicationPasswordUpdateParams {
    /**
     * A UUID provided by the application to uniquely identify it.
     * It is recommended to use an UUID v5 with the URL or DNS namespace.
     */
    public let appId: String?
    /**
     * The name of the application password.
     */
    public let name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A UUID provided by the application to uniquely identify it.
         * It is recommended to use an UUID v5 with the URL or DNS namespace.
         */appId: String?, 
        /**
         * The name of the application password.
         */name: String) {
        self.appId = appId
        self.name = name
    }
}



extension ApplicationPasswordUpdateParams: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordUpdateParams, rhs: ApplicationPasswordUpdateParams) -> Bool {
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(appId)
        hasher.combine(name)
    }
}


public struct FfiConverterTypeApplicationPasswordUpdateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordUpdateParams {
        return
            try ApplicationPasswordUpdateParams(
                appId: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordUpdateParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.appId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordUpdateParams_lift(_ buf: RustBuffer) throws -> ApplicationPasswordUpdateParams {
    return try FfiConverterTypeApplicationPasswordUpdateParams.lift(buf)
}

public func FfiConverterTypeApplicationPasswordUpdateParams_lower(_ value: ApplicationPasswordUpdateParams) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordUpdateParams.lower(value)
}


public struct ApplicationPasswordUuid {
    public let uuid: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: String) {
        self.uuid = uuid
    }
}



extension ApplicationPasswordUuid: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordUuid, rhs: ApplicationPasswordUuid) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
    }
}


public struct FfiConverterTypeApplicationPasswordUuid: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordUuid {
        return
            try ApplicationPasswordUuid(
                uuid: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordUuid, into buf: inout [UInt8]) {
        FfiConverterString.write(value.uuid, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordUuid_lift(_ buf: RustBuffer) throws -> ApplicationPasswordUuid {
    return try FfiConverterTypeApplicationPasswordUuid.lift(buf)
}

public func FfiConverterTypeApplicationPasswordUuid_lower(_ value: ApplicationPasswordUuid) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordUuid.lower(value)
}


public struct ApplicationPasswordWithEditContext {
    public let uuid: ApplicationPasswordUuid
    public let appId: ApplicationPasswordAppId
    public let name: String
    public let created: String
    public let lastUsed: String?
    public let lastIp: IpAddress?
    public let password: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid, appId: ApplicationPasswordAppId, name: String, created: String, lastUsed: String?, lastIp: IpAddress?, password: String?) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
        self.created = created
        self.lastUsed = lastUsed
        self.lastIp = lastIp
        self.password = password
    }
}



extension ApplicationPasswordWithEditContext: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordWithEditContext, rhs: ApplicationPasswordWithEditContext) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        if lhs.lastUsed != rhs.lastUsed {
            return false
        }
        if lhs.lastIp != rhs.lastIp {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
        hasher.combine(created)
        hasher.combine(lastUsed)
        hasher.combine(lastIp)
        hasher.combine(password)
    }
}


public struct FfiConverterTypeApplicationPasswordWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordWithEditContext {
        return
            try ApplicationPasswordWithEditContext(
                uuid: FfiConverterTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                created: FfiConverterString.read(from: &buf), 
                lastUsed: FfiConverterOptionString.read(from: &buf), 
                lastIp: FfiConverterOptionTypeIpAddress.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordWithEditContext, into buf: inout [UInt8]) {
        FfiConverterTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.created, into: &buf)
        FfiConverterOptionString.write(value.lastUsed, into: &buf)
        FfiConverterOptionTypeIpAddress.write(value.lastIp, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordWithEditContext_lift(_ buf: RustBuffer) throws -> ApplicationPasswordWithEditContext {
    return try FfiConverterTypeApplicationPasswordWithEditContext.lift(buf)
}

public func FfiConverterTypeApplicationPasswordWithEditContext_lower(_ value: ApplicationPasswordWithEditContext) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordWithEditContext.lower(value)
}


public struct ApplicationPasswordWithEmbedContext {
    public let uuid: ApplicationPasswordUuid
    public let appId: ApplicationPasswordAppId
    public let name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid, appId: ApplicationPasswordAppId, name: String) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
    }
}



extension ApplicationPasswordWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordWithEmbedContext, rhs: ApplicationPasswordWithEmbedContext) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
    }
}


public struct FfiConverterTypeApplicationPasswordWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordWithEmbedContext {
        return
            try ApplicationPasswordWithEmbedContext(
                uuid: FfiConverterTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordWithEmbedContext_lift(_ buf: RustBuffer) throws -> ApplicationPasswordWithEmbedContext {
    return try FfiConverterTypeApplicationPasswordWithEmbedContext.lift(buf)
}

public func FfiConverterTypeApplicationPasswordWithEmbedContext_lower(_ value: ApplicationPasswordWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordWithEmbedContext.lower(value)
}


public struct ApplicationPasswordWithViewContext {
    public let uuid: ApplicationPasswordUuid
    public let appId: ApplicationPasswordAppId
    public let name: String
    public let created: String
    public let lastUsed: String?
    public let lastIp: IpAddress?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid, appId: ApplicationPasswordAppId, name: String, created: String, lastUsed: String?, lastIp: IpAddress?) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
        self.created = created
        self.lastUsed = lastUsed
        self.lastIp = lastIp
    }
}



extension ApplicationPasswordWithViewContext: Equatable, Hashable {
    public static func ==(lhs: ApplicationPasswordWithViewContext, rhs: ApplicationPasswordWithViewContext) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        if lhs.lastUsed != rhs.lastUsed {
            return false
        }
        if lhs.lastIp != rhs.lastIp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
        hasher.combine(created)
        hasher.combine(lastUsed)
        hasher.combine(lastIp)
    }
}


public struct FfiConverterTypeApplicationPasswordWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPasswordWithViewContext {
        return
            try ApplicationPasswordWithViewContext(
                uuid: FfiConverterTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                created: FfiConverterString.read(from: &buf), 
                lastUsed: FfiConverterOptionString.read(from: &buf), 
                lastIp: FfiConverterOptionTypeIpAddress.read(from: &buf)
        )
    }

    public static func write(_ value: ApplicationPasswordWithViewContext, into buf: inout [UInt8]) {
        FfiConverterTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.created, into: &buf)
        FfiConverterOptionString.write(value.lastUsed, into: &buf)
        FfiConverterOptionTypeIpAddress.write(value.lastIp, into: &buf)
    }
}


public func FfiConverterTypeApplicationPasswordWithViewContext_lift(_ buf: RustBuffer) throws -> ApplicationPasswordWithViewContext {
    return try FfiConverterTypeApplicationPasswordWithViewContext.lift(buf)
}

public func FfiConverterTypeApplicationPasswordWithViewContext_lower(_ value: ApplicationPasswordWithViewContext) -> RustBuffer {
    return FfiConverterTypeApplicationPasswordWithViewContext.lower(value)
}


public struct IpAddress {
    public let value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: String) {
        self.value = value
    }
}



extension IpAddress: Equatable, Hashable {
    public static func ==(lhs: IpAddress, rhs: IpAddress) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


public struct FfiConverterTypeIpAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IpAddress {
        return
            try IpAddress(
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: IpAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeIpAddress_lift(_ buf: RustBuffer) throws -> IpAddress {
    return try FfiConverterTypeIpAddress.lift(buf)
}

public func FfiConverterTypeIpAddress_lower(_ value: IpAddress) -> RustBuffer {
    return FfiConverterTypeIpAddress.lower(value)
}


public struct PluginCreateParams {
    /**
     * WordPress.org plugin directory slug.
     */
    public let slug: PluginWpOrgDirectorySlug
    /**
     * The plugin activation status.
     */
    public let status: PluginStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * WordPress.org plugin directory slug.
         */slug: PluginWpOrgDirectorySlug, 
        /**
         * The plugin activation status.
         */status: PluginStatus) {
        self.slug = slug
        self.status = status
    }
}



extension PluginCreateParams: Equatable, Hashable {
    public static func ==(lhs: PluginCreateParams, rhs: PluginCreateParams) -> Bool {
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(slug)
        hasher.combine(status)
    }
}


public struct FfiConverterTypePluginCreateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginCreateParams {
        return
            try PluginCreateParams(
                slug: FfiConverterTypePluginWpOrgDirectorySlug.read(from: &buf), 
                status: FfiConverterTypePluginStatus.read(from: &buf)
        )
    }

    public static func write(_ value: PluginCreateParams, into buf: inout [UInt8]) {
        FfiConverterTypePluginWpOrgDirectorySlug.write(value.slug, into: &buf)
        FfiConverterTypePluginStatus.write(value.status, into: &buf)
    }
}


public func FfiConverterTypePluginCreateParams_lift(_ buf: RustBuffer) throws -> PluginCreateParams {
    return try FfiConverterTypePluginCreateParams.lift(buf)
}

public func FfiConverterTypePluginCreateParams_lower(_ value: PluginCreateParams) -> RustBuffer {
    return FfiConverterTypePluginCreateParams.lower(value)
}


public struct PluginDeleteResponse {
    public let deleted: Bool
    public let previous: PluginWithEditContext

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deleted: Bool, previous: PluginWithEditContext) {
        self.deleted = deleted
        self.previous = previous
    }
}



extension PluginDeleteResponse: Equatable, Hashable {
    public static func ==(lhs: PluginDeleteResponse, rhs: PluginDeleteResponse) -> Bool {
        if lhs.deleted != rhs.deleted {
            return false
        }
        if lhs.previous != rhs.previous {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deleted)
        hasher.combine(previous)
    }
}


public struct FfiConverterTypePluginDeleteResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginDeleteResponse {
        return
            try PluginDeleteResponse(
                deleted: FfiConverterBool.read(from: &buf), 
                previous: FfiConverterTypePluginWithEditContext.read(from: &buf)
        )
    }

    public static func write(_ value: PluginDeleteResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.deleted, into: &buf)
        FfiConverterTypePluginWithEditContext.write(value.previous, into: &buf)
    }
}


public func FfiConverterTypePluginDeleteResponse_lift(_ buf: RustBuffer) throws -> PluginDeleteResponse {
    return try FfiConverterTypePluginDeleteResponse.lift(buf)
}

public func FfiConverterTypePluginDeleteResponse_lower(_ value: PluginDeleteResponse) -> RustBuffer {
    return FfiConverterTypePluginDeleteResponse.lower(value)
}


public struct PluginDescription {
    public let raw: String
    public let rendered: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(raw: String, rendered: String) {
        self.raw = raw
        self.rendered = rendered
    }
}



extension PluginDescription: Equatable, Hashable {
    public static func ==(lhs: PluginDescription, rhs: PluginDescription) -> Bool {
        if lhs.raw != rhs.raw {
            return false
        }
        if lhs.rendered != rhs.rendered {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(raw)
        hasher.combine(rendered)
    }
}


public struct FfiConverterTypePluginDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginDescription {
        return
            try PluginDescription(
                raw: FfiConverterString.read(from: &buf), 
                rendered: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginDescription, into buf: inout [UInt8]) {
        FfiConverterString.write(value.raw, into: &buf)
        FfiConverterString.write(value.rendered, into: &buf)
    }
}


public func FfiConverterTypePluginDescription_lift(_ buf: RustBuffer) throws -> PluginDescription {
    return try FfiConverterTypePluginDescription.lift(buf)
}

public func FfiConverterTypePluginDescription_lower(_ value: PluginDescription) -> RustBuffer {
    return FfiConverterTypePluginDescription.lower(value)
}


public struct PluginListParams {
    /**
     * Limit results to those matching a string.
     */
    public let search: String?
    /**
     * Limits results to plugins with the given status.
     */
    public let status: PluginStatus?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Limit results to those matching a string.
         */search: String? = nil, 
        /**
         * Limits results to plugins with the given status.
         */status: PluginStatus? = nil) {
        self.search = search
        self.status = status
    }
}



extension PluginListParams: Equatable, Hashable {
    public static func ==(lhs: PluginListParams, rhs: PluginListParams) -> Bool {
        if lhs.search != rhs.search {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(search)
        hasher.combine(status)
    }
}


public struct FfiConverterTypePluginListParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginListParams {
        return
            try PluginListParams(
                search: FfiConverterOptionString.read(from: &buf), 
                status: FfiConverterOptionTypePluginStatus.read(from: &buf)
        )
    }

    public static func write(_ value: PluginListParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.search, into: &buf)
        FfiConverterOptionTypePluginStatus.write(value.status, into: &buf)
    }
}


public func FfiConverterTypePluginListParams_lift(_ buf: RustBuffer) throws -> PluginListParams {
    return try FfiConverterTypePluginListParams.lift(buf)
}

public func FfiConverterTypePluginListParams_lower(_ value: PluginListParams) -> RustBuffer {
    return FfiConverterTypePluginListParams.lower(value)
}


public struct PluginSlug {
    public let slug: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(slug: String) {
        self.slug = slug
    }
}



extension PluginSlug: Equatable, Hashable {
    public static func ==(lhs: PluginSlug, rhs: PluginSlug) -> Bool {
        if lhs.slug != rhs.slug {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(slug)
    }
}


public struct FfiConverterTypePluginSlug: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginSlug {
        return
            try PluginSlug(
                slug: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginSlug, into buf: inout [UInt8]) {
        FfiConverterString.write(value.slug, into: &buf)
    }
}


public func FfiConverterTypePluginSlug_lift(_ buf: RustBuffer) throws -> PluginSlug {
    return try FfiConverterTypePluginSlug.lift(buf)
}

public func FfiConverterTypePluginSlug_lower(_ value: PluginSlug) -> RustBuffer {
    return FfiConverterTypePluginSlug.lower(value)
}


public struct PluginUpdateParams {
    /**
     * The plugin activation status.
     */
    public let status: PluginStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The plugin activation status.
         */status: PluginStatus) {
        self.status = status
    }
}



extension PluginUpdateParams: Equatable, Hashable {
    public static func ==(lhs: PluginUpdateParams, rhs: PluginUpdateParams) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
    }
}


public struct FfiConverterTypePluginUpdateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginUpdateParams {
        return
            try PluginUpdateParams(
                status: FfiConverterTypePluginStatus.read(from: &buf)
        )
    }

    public static func write(_ value: PluginUpdateParams, into buf: inout [UInt8]) {
        FfiConverterTypePluginStatus.write(value.status, into: &buf)
    }
}


public func FfiConverterTypePluginUpdateParams_lift(_ buf: RustBuffer) throws -> PluginUpdateParams {
    return try FfiConverterTypePluginUpdateParams.lift(buf)
}

public func FfiConverterTypePluginUpdateParams_lower(_ value: PluginUpdateParams) -> RustBuffer {
    return FfiConverterTypePluginUpdateParams.lower(value)
}


public struct PluginWithEditContext {
    public let plugin: PluginSlug
    public let status: PluginStatus
    public let name: String
    public let pluginUri: String
    public let author: String
    public let authorUri: String
    public let description: PluginDescription
    public let version: String
    public let networkOnly: Bool
    public let requiresWp: String
    public let requiresPhp: String
    public let textdomain: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug, status: PluginStatus, name: String, pluginUri: String, author: String, authorUri: String, description: PluginDescription, version: String, networkOnly: Bool, requiresWp: String, requiresPhp: String, textdomain: String) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.pluginUri = pluginUri
        self.author = author
        self.authorUri = authorUri
        self.description = description
        self.version = version
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
        self.textdomain = textdomain
    }
}



extension PluginWithEditContext: Equatable, Hashable {
    public static func ==(lhs: PluginWithEditContext, rhs: PluginWithEditContext) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pluginUri != rhs.pluginUri {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.authorUri != rhs.authorUri {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        if lhs.textdomain != rhs.textdomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(pluginUri)
        hasher.combine(author)
        hasher.combine(authorUri)
        hasher.combine(description)
        hasher.combine(version)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
        hasher.combine(textdomain)
    }
}


public struct FfiConverterTypePluginWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginWithEditContext {
        return
            try PluginWithEditContext(
                plugin: FfiConverterTypePluginSlug.read(from: &buf), 
                status: FfiConverterTypePluginStatus.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                pluginUri: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                authorUri: FfiConverterString.read(from: &buf), 
                description: FfiConverterTypePluginDescription.read(from: &buf), 
                version: FfiConverterString.read(from: &buf), 
                networkOnly: FfiConverterBool.read(from: &buf), 
                requiresWp: FfiConverterString.read(from: &buf), 
                requiresPhp: FfiConverterString.read(from: &buf), 
                textdomain: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginWithEditContext, into buf: inout [UInt8]) {
        FfiConverterTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterTypePluginStatus.write(value.status, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.pluginUri, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterString.write(value.authorUri, into: &buf)
        FfiConverterTypePluginDescription.write(value.description, into: &buf)
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterBool.write(value.networkOnly, into: &buf)
        FfiConverterString.write(value.requiresWp, into: &buf)
        FfiConverterString.write(value.requiresPhp, into: &buf)
        FfiConverterString.write(value.textdomain, into: &buf)
    }
}


public func FfiConverterTypePluginWithEditContext_lift(_ buf: RustBuffer) throws -> PluginWithEditContext {
    return try FfiConverterTypePluginWithEditContext.lift(buf)
}

public func FfiConverterTypePluginWithEditContext_lower(_ value: PluginWithEditContext) -> RustBuffer {
    return FfiConverterTypePluginWithEditContext.lower(value)
}


public struct PluginWithEmbedContext {
    public let plugin: PluginSlug
    public let status: PluginStatus
    public let name: String
    public let networkOnly: Bool
    public let requiresWp: String
    public let requiresPhp: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug, status: PluginStatus, name: String, networkOnly: Bool, requiresWp: String, requiresPhp: String) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
    }
}



extension PluginWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: PluginWithEmbedContext, rhs: PluginWithEmbedContext) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
    }
}


public struct FfiConverterTypePluginWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginWithEmbedContext {
        return
            try PluginWithEmbedContext(
                plugin: FfiConverterTypePluginSlug.read(from: &buf), 
                status: FfiConverterTypePluginStatus.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                networkOnly: FfiConverterBool.read(from: &buf), 
                requiresWp: FfiConverterString.read(from: &buf), 
                requiresPhp: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterTypePluginStatus.write(value.status, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterBool.write(value.networkOnly, into: &buf)
        FfiConverterString.write(value.requiresWp, into: &buf)
        FfiConverterString.write(value.requiresPhp, into: &buf)
    }
}


public func FfiConverterTypePluginWithEmbedContext_lift(_ buf: RustBuffer) throws -> PluginWithEmbedContext {
    return try FfiConverterTypePluginWithEmbedContext.lift(buf)
}

public func FfiConverterTypePluginWithEmbedContext_lower(_ value: PluginWithEmbedContext) -> RustBuffer {
    return FfiConverterTypePluginWithEmbedContext.lower(value)
}


public struct PluginWithViewContext {
    public let plugin: PluginSlug
    public let status: PluginStatus
    public let name: String
    public let pluginUri: String
    public let author: String
    public let authorUri: String
    public let description: PluginDescription
    public let version: String
    public let networkOnly: Bool
    public let requiresWp: String
    public let requiresPhp: String
    public let textdomain: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug, status: PluginStatus, name: String, pluginUri: String, author: String, authorUri: String, description: PluginDescription, version: String, networkOnly: Bool, requiresWp: String, requiresPhp: String, textdomain: String) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.pluginUri = pluginUri
        self.author = author
        self.authorUri = authorUri
        self.description = description
        self.version = version
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
        self.textdomain = textdomain
    }
}



extension PluginWithViewContext: Equatable, Hashable {
    public static func ==(lhs: PluginWithViewContext, rhs: PluginWithViewContext) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pluginUri != rhs.pluginUri {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.authorUri != rhs.authorUri {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        if lhs.textdomain != rhs.textdomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(pluginUri)
        hasher.combine(author)
        hasher.combine(authorUri)
        hasher.combine(description)
        hasher.combine(version)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
        hasher.combine(textdomain)
    }
}


public struct FfiConverterTypePluginWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginWithViewContext {
        return
            try PluginWithViewContext(
                plugin: FfiConverterTypePluginSlug.read(from: &buf), 
                status: FfiConverterTypePluginStatus.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                pluginUri: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                authorUri: FfiConverterString.read(from: &buf), 
                description: FfiConverterTypePluginDescription.read(from: &buf), 
                version: FfiConverterString.read(from: &buf), 
                networkOnly: FfiConverterBool.read(from: &buf), 
                requiresWp: FfiConverterString.read(from: &buf), 
                requiresPhp: FfiConverterString.read(from: &buf), 
                textdomain: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginWithViewContext, into buf: inout [UInt8]) {
        FfiConverterTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterTypePluginStatus.write(value.status, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.pluginUri, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterString.write(value.authorUri, into: &buf)
        FfiConverterTypePluginDescription.write(value.description, into: &buf)
        FfiConverterString.write(value.version, into: &buf)
        FfiConverterBool.write(value.networkOnly, into: &buf)
        FfiConverterString.write(value.requiresWp, into: &buf)
        FfiConverterString.write(value.requiresPhp, into: &buf)
        FfiConverterString.write(value.textdomain, into: &buf)
    }
}


public func FfiConverterTypePluginWithViewContext_lift(_ buf: RustBuffer) throws -> PluginWithViewContext {
    return try FfiConverterTypePluginWithViewContext.lift(buf)
}

public func FfiConverterTypePluginWithViewContext_lower(_ value: PluginWithViewContext) -> RustBuffer {
    return FfiConverterTypePluginWithViewContext.lower(value)
}


public struct PluginWpOrgDirectorySlug {
    public let slug: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(slug: String) {
        self.slug = slug
    }
}



extension PluginWpOrgDirectorySlug: Equatable, Hashable {
    public static func ==(lhs: PluginWpOrgDirectorySlug, rhs: PluginWpOrgDirectorySlug) -> Bool {
        if lhs.slug != rhs.slug {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(slug)
    }
}


public struct FfiConverterTypePluginWpOrgDirectorySlug: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginWpOrgDirectorySlug {
        return
            try PluginWpOrgDirectorySlug(
                slug: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PluginWpOrgDirectorySlug, into buf: inout [UInt8]) {
        FfiConverterString.write(value.slug, into: &buf)
    }
}


public func FfiConverterTypePluginWpOrgDirectorySlug_lift(_ buf: RustBuffer) throws -> PluginWpOrgDirectorySlug {
    return try FfiConverterTypePluginWpOrgDirectorySlug.lift(buf)
}

public func FfiConverterTypePluginWpOrgDirectorySlug_lower(_ value: PluginWpOrgDirectorySlug) -> RustBuffer {
    return FfiConverterTypePluginWpOrgDirectorySlug.lower(value)
}


public struct SparseApplicationPassword {
    public let uuid: ApplicationPasswordUuid?
    public let appId: ApplicationPasswordAppId?
    public let name: String?
    public let created: String?
    public let lastUsed: String?
    public let lastIp: IpAddress?
    public let password: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: ApplicationPasswordUuid?, appId: ApplicationPasswordAppId?, name: String?, created: String?, lastUsed: String?, lastIp: IpAddress?, password: String?) {
        self.uuid = uuid
        self.appId = appId
        self.name = name
        self.created = created
        self.lastUsed = lastUsed
        self.lastIp = lastIp
        self.password = password
    }
}



extension SparseApplicationPassword: Equatable, Hashable {
    public static func ==(lhs: SparseApplicationPassword, rhs: SparseApplicationPassword) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.appId != rhs.appId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.created != rhs.created {
            return false
        }
        if lhs.lastUsed != rhs.lastUsed {
            return false
        }
        if lhs.lastIp != rhs.lastIp {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(appId)
        hasher.combine(name)
        hasher.combine(created)
        hasher.combine(lastUsed)
        hasher.combine(lastIp)
        hasher.combine(password)
    }
}


public struct FfiConverterTypeSparseApplicationPassword: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseApplicationPassword {
        return
            try SparseApplicationPassword(
                uuid: FfiConverterOptionTypeApplicationPasswordUuid.read(from: &buf), 
                appId: FfiConverterOptionTypeApplicationPasswordAppId.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                created: FfiConverterOptionString.read(from: &buf), 
                lastUsed: FfiConverterOptionString.read(from: &buf), 
                lastIp: FfiConverterOptionTypeIpAddress.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparseApplicationPassword, into buf: inout [UInt8]) {
        FfiConverterOptionTypeApplicationPasswordUuid.write(value.uuid, into: &buf)
        FfiConverterOptionTypeApplicationPasswordAppId.write(value.appId, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.created, into: &buf)
        FfiConverterOptionString.write(value.lastUsed, into: &buf)
        FfiConverterOptionTypeIpAddress.write(value.lastIp, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
    }
}


public func FfiConverterTypeSparseApplicationPassword_lift(_ buf: RustBuffer) throws -> SparseApplicationPassword {
    return try FfiConverterTypeSparseApplicationPassword.lift(buf)
}

public func FfiConverterTypeSparseApplicationPassword_lower(_ value: SparseApplicationPassword) -> RustBuffer {
    return FfiConverterTypeSparseApplicationPassword.lower(value)
}


public struct SparsePlugin {
    public let plugin: PluginSlug?
    public let status: PluginStatus?
    public let name: String?
    public let pluginUri: String?
    public let author: String?
    public let authorUri: String?
    public let description: PluginDescription?
    public let version: String?
    public let networkOnly: Bool?
    public let requiresWp: String?
    public let requiresPhp: String?
    public let textdomain: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(plugin: PluginSlug?, status: PluginStatus?, name: String?, pluginUri: String?, author: String?, authorUri: String?, description: PluginDescription?, version: String?, networkOnly: Bool?, requiresWp: String?, requiresPhp: String?, textdomain: String?) {
        self.plugin = plugin
        self.status = status
        self.name = name
        self.pluginUri = pluginUri
        self.author = author
        self.authorUri = authorUri
        self.description = description
        self.version = version
        self.networkOnly = networkOnly
        self.requiresWp = requiresWp
        self.requiresPhp = requiresPhp
        self.textdomain = textdomain
    }
}



extension SparsePlugin: Equatable, Hashable {
    public static func ==(lhs: SparsePlugin, rhs: SparsePlugin) -> Bool {
        if lhs.plugin != rhs.plugin {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pluginUri != rhs.pluginUri {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.authorUri != rhs.authorUri {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkOnly != rhs.networkOnly {
            return false
        }
        if lhs.requiresWp != rhs.requiresWp {
            return false
        }
        if lhs.requiresPhp != rhs.requiresPhp {
            return false
        }
        if lhs.textdomain != rhs.textdomain {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(plugin)
        hasher.combine(status)
        hasher.combine(name)
        hasher.combine(pluginUri)
        hasher.combine(author)
        hasher.combine(authorUri)
        hasher.combine(description)
        hasher.combine(version)
        hasher.combine(networkOnly)
        hasher.combine(requiresWp)
        hasher.combine(requiresPhp)
        hasher.combine(textdomain)
    }
}


public struct FfiConverterTypeSparsePlugin: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePlugin {
        return
            try SparsePlugin(
                plugin: FfiConverterOptionTypePluginSlug.read(from: &buf), 
                status: FfiConverterOptionTypePluginStatus.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                pluginUri: FfiConverterOptionString.read(from: &buf), 
                author: FfiConverterOptionString.read(from: &buf), 
                authorUri: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionTypePluginDescription.read(from: &buf), 
                version: FfiConverterOptionString.read(from: &buf), 
                networkOnly: FfiConverterOptionBool.read(from: &buf), 
                requiresWp: FfiConverterOptionString.read(from: &buf), 
                requiresPhp: FfiConverterOptionString.read(from: &buf), 
                textdomain: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SparsePlugin, into buf: inout [UInt8]) {
        FfiConverterOptionTypePluginSlug.write(value.plugin, into: &buf)
        FfiConverterOptionTypePluginStatus.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.pluginUri, into: &buf)
        FfiConverterOptionString.write(value.author, into: &buf)
        FfiConverterOptionString.write(value.authorUri, into: &buf)
        FfiConverterOptionTypePluginDescription.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.version, into: &buf)
        FfiConverterOptionBool.write(value.networkOnly, into: &buf)
        FfiConverterOptionString.write(value.requiresWp, into: &buf)
        FfiConverterOptionString.write(value.requiresPhp, into: &buf)
        FfiConverterOptionString.write(value.textdomain, into: &buf)
    }
}


public func FfiConverterTypeSparsePlugin_lift(_ buf: RustBuffer) throws -> SparsePlugin {
    return try FfiConverterTypeSparsePlugin.lift(buf)
}

public func FfiConverterTypeSparsePlugin_lower(_ value: SparsePlugin) -> RustBuffer {
    return FfiConverterTypeSparsePlugin.lower(value)
}


public struct SparseUser {
    public let id: UserId?
    public let username: String?
    public let name: String?
    public let firstName: String?
    public let lastName: String?
    public let email: String?
    public let url: String?
    public let description: String?
    public let link: String?
    public let locale: String?
    public let nickname: String?
    public let slug: String?
    public let registeredDate: String?
    public let roles: [String]?
    public let capabilities: [String: Bool]?
    public let extraCapabilities: [String: Bool]?
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId?, username: String?, name: String?, firstName: String?, lastName: String?, email: String?, url: String?, description: String?, link: String?, locale: String?, nickname: String?, slug: String?, registeredDate: String?, roles: [String]?, capabilities: [String: Bool]?, extraCapabilities: [String: Bool]?, avatarUrls: [String: String]?) {
        self.id = id
        self.username = username
        self.name = name
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.url = url
        self.description = description
        self.link = link
        self.locale = locale
        self.nickname = nickname
        self.slug = slug
        self.registeredDate = registeredDate
        self.roles = roles
        self.capabilities = capabilities
        self.extraCapabilities = extraCapabilities
        self.avatarUrls = avatarUrls
    }
}



extension SparseUser: Equatable, Hashable {
    public static func ==(lhs: SparseUser, rhs: SparseUser) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.registeredDate != rhs.registeredDate {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        if lhs.extraCapabilities != rhs.extraCapabilities {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(username)
        hasher.combine(name)
        hasher.combine(firstName)
        hasher.combine(lastName)
        hasher.combine(email)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(locale)
        hasher.combine(nickname)
        hasher.combine(slug)
        hasher.combine(registeredDate)
        hasher.combine(roles)
        hasher.combine(capabilities)
        hasher.combine(extraCapabilities)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeSparseUser: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseUser {
        return
            try SparseUser(
                id: FfiConverterOptionTypeUserId.read(from: &buf), 
                username: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                firstName: FfiConverterOptionString.read(from: &buf), 
                lastName: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                link: FfiConverterOptionString.read(from: &buf), 
                locale: FfiConverterOptionString.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                registeredDate: FfiConverterOptionString.read(from: &buf), 
                roles: FfiConverterOptionSequenceString.read(from: &buf), 
                capabilities: FfiConverterOptionDictionaryStringBool.read(from: &buf), 
                extraCapabilities: FfiConverterOptionDictionaryStringBool.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: SparseUser, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUserId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.firstName, into: &buf)
        FfiConverterOptionString.write(value.lastName, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.link, into: &buf)
        FfiConverterOptionString.write(value.locale, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterOptionString.write(value.registeredDate, into: &buf)
        FfiConverterOptionSequenceString.write(value.roles, into: &buf)
        FfiConverterOptionDictionaryStringBool.write(value.capabilities, into: &buf)
        FfiConverterOptionDictionaryStringBool.write(value.extraCapabilities, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeSparseUser_lift(_ buf: RustBuffer) throws -> SparseUser {
    return try FfiConverterTypeSparseUser.lift(buf)
}

public func FfiConverterTypeSparseUser_lower(_ value: SparseUser) -> RustBuffer {
    return FfiConverterTypeSparseUser.lower(value)
}


public struct UnrecognizedWpRestError {
    public let code: String
    public let message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: String, message: String) {
        self.code = code
        self.message = message
    }
}



extension UnrecognizedWpRestError: Equatable, Hashable {
    public static func ==(lhs: UnrecognizedWpRestError, rhs: UnrecognizedWpRestError) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(message)
    }
}


public struct FfiConverterTypeUnrecognizedWpRestError: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnrecognizedWpRestError {
        return
            try UnrecognizedWpRestError(
                code: FfiConverterString.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UnrecognizedWpRestError, into buf: inout [UInt8]) {
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


public func FfiConverterTypeUnrecognizedWpRestError_lift(_ buf: RustBuffer) throws -> UnrecognizedWpRestError {
    return try FfiConverterTypeUnrecognizedWpRestError.lift(buf)
}

public func FfiConverterTypeUnrecognizedWpRestError_lower(_ value: UnrecognizedWpRestError) -> RustBuffer {
    return FfiConverterTypeUnrecognizedWpRestError.lower(value)
}


public struct UrlDiscoveryAttemptSuccess {
    public let siteUrl: ParsedUrl
    public let apiDetails: WpApiDetails
    public let apiRootUrl: ParsedUrl

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(siteUrl: ParsedUrl, apiDetails: WpApiDetails, apiRootUrl: ParsedUrl) {
        self.siteUrl = siteUrl
        self.apiDetails = apiDetails
        self.apiRootUrl = apiRootUrl
    }
}



public struct FfiConverterTypeUrlDiscoveryAttemptSuccess: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlDiscoveryAttemptSuccess {
        return
            try UrlDiscoveryAttemptSuccess(
                siteUrl: FfiConverterTypeParsedUrl.read(from: &buf), 
                apiDetails: FfiConverterTypeWpApiDetails.read(from: &buf), 
                apiRootUrl: FfiConverterTypeParsedUrl.read(from: &buf)
        )
    }

    public static func write(_ value: UrlDiscoveryAttemptSuccess, into buf: inout [UInt8]) {
        FfiConverterTypeParsedUrl.write(value.siteUrl, into: &buf)
        FfiConverterTypeWpApiDetails.write(value.apiDetails, into: &buf)
        FfiConverterTypeParsedUrl.write(value.apiRootUrl, into: &buf)
    }
}


public func FfiConverterTypeUrlDiscoveryAttemptSuccess_lift(_ buf: RustBuffer) throws -> UrlDiscoveryAttemptSuccess {
    return try FfiConverterTypeUrlDiscoveryAttemptSuccess.lift(buf)
}

public func FfiConverterTypeUrlDiscoveryAttemptSuccess_lower(_ value: UrlDiscoveryAttemptSuccess) -> RustBuffer {
    return FfiConverterTypeUrlDiscoveryAttemptSuccess.lower(value)
}


public struct UrlDiscoverySuccess {
    public let siteUrl: ParsedUrl
    public let apiDetails: WpApiDetails
    public let apiRootUrl: ParsedUrl
    public let attempts: [UrlDiscoveryState]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(siteUrl: ParsedUrl, apiDetails: WpApiDetails, apiRootUrl: ParsedUrl, attempts: [UrlDiscoveryState]) {
        self.siteUrl = siteUrl
        self.apiDetails = apiDetails
        self.apiRootUrl = apiRootUrl
        self.attempts = attempts
    }
}



public struct FfiConverterTypeUrlDiscoverySuccess: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlDiscoverySuccess {
        return
            try UrlDiscoverySuccess(
                siteUrl: FfiConverterTypeParsedUrl.read(from: &buf), 
                apiDetails: FfiConverterTypeWpApiDetails.read(from: &buf), 
                apiRootUrl: FfiConverterTypeParsedUrl.read(from: &buf), 
                attempts: FfiConverterSequenceTypeUrlDiscoveryState.read(from: &buf)
        )
    }

    public static func write(_ value: UrlDiscoverySuccess, into buf: inout [UInt8]) {
        FfiConverterTypeParsedUrl.write(value.siteUrl, into: &buf)
        FfiConverterTypeWpApiDetails.write(value.apiDetails, into: &buf)
        FfiConverterTypeParsedUrl.write(value.apiRootUrl, into: &buf)
        FfiConverterSequenceTypeUrlDiscoveryState.write(value.attempts, into: &buf)
    }
}


public func FfiConverterTypeUrlDiscoverySuccess_lift(_ buf: RustBuffer) throws -> UrlDiscoverySuccess {
    return try FfiConverterTypeUrlDiscoverySuccess.lift(buf)
}

public func FfiConverterTypeUrlDiscoverySuccess_lower(_ value: UrlDiscoverySuccess) -> RustBuffer {
    return FfiConverterTypeUrlDiscoverySuccess.lower(value)
}


public struct UserCreateParams {
    /**
     * Login name for the user.
     */
    public let username: String
    /**
     * The email address for the user.
     */
    public let email: String
    /**
     * Password for the user (never included).
     */
    public let password: String
    /**
     * Display name for the user.
     */
    public let name: String?
    /**
     * First name for the user.
     */
    public let firstName: String?
    /**
     * Last name for the user.
     */
    public let lastName: String?
    /**
     * URL of the user.
     */
    public let url: String?
    /**
     * Description of the user.
     */
    public let description: String?
    /**
     * Locale for the user.
     * One of: , `en_US`
     */
    public let locale: String?
    /**
     * The nickname for the user.
     */
    public let nickname: String?
    /**
     * An alphanumeric identifier for the user.
     */
    public let slug: String?
    /**
     * Roles assigned to the user.
     */
    public let roles: [String]
    /**
     * Meta fields.
     */
    public let meta: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Login name for the user.
         */username: String, 
        /**
         * The email address for the user.
         */email: String, 
        /**
         * Password for the user (never included).
         */password: String, 
        /**
         * Display name for the user.
         */name: String? = nil, 
        /**
         * First name for the user.
         */firstName: String? = nil, 
        /**
         * Last name for the user.
         */lastName: String? = nil, 
        /**
         * URL of the user.
         */url: String? = nil, 
        /**
         * Description of the user.
         */description: String? = nil, 
        /**
         * Locale for the user.
         * One of: , `en_US`
         */locale: String? = nil, 
        /**
         * The nickname for the user.
         */nickname: String? = nil, 
        /**
         * An alphanumeric identifier for the user.
         */slug: String? = nil, 
        /**
         * Roles assigned to the user.
         */roles: [String] = [], 
        /**
         * Meta fields.
         */meta: String? = nil) {
        self.username = username
        self.email = email
        self.password = password
        self.name = name
        self.firstName = firstName
        self.lastName = lastName
        self.url = url
        self.description = description
        self.locale = locale
        self.nickname = nickname
        self.slug = slug
        self.roles = roles
        self.meta = meta
    }
}



extension UserCreateParams: Equatable, Hashable {
    public static func ==(lhs: UserCreateParams, rhs: UserCreateParams) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.meta != rhs.meta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(email)
        hasher.combine(password)
        hasher.combine(name)
        hasher.combine(firstName)
        hasher.combine(lastName)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(locale)
        hasher.combine(nickname)
        hasher.combine(slug)
        hasher.combine(roles)
        hasher.combine(meta)
    }
}


public struct FfiConverterTypeUserCreateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserCreateParams {
        return
            try UserCreateParams(
                username: FfiConverterString.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                firstName: FfiConverterOptionString.read(from: &buf), 
                lastName: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                locale: FfiConverterOptionString.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                roles: FfiConverterSequenceString.read(from: &buf), 
                meta: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserCreateParams, into buf: inout [UInt8]) {
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.firstName, into: &buf)
        FfiConverterOptionString.write(value.lastName, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.locale, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterSequenceString.write(value.roles, into: &buf)
        FfiConverterOptionString.write(value.meta, into: &buf)
    }
}


public func FfiConverterTypeUserCreateParams_lift(_ buf: RustBuffer) throws -> UserCreateParams {
    return try FfiConverterTypeUserCreateParams.lift(buf)
}

public func FfiConverterTypeUserCreateParams_lower(_ value: UserCreateParams) -> RustBuffer {
    return FfiConverterTypeUserCreateParams.lower(value)
}


public struct UserDeleteParams {
    /**
     * Reassign the deleted user's posts and links to this user ID.
     */
    public let reassign: UserId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Reassign the deleted user's posts and links to this user ID.
         */reassign: UserId) {
        self.reassign = reassign
    }
}



extension UserDeleteParams: Equatable, Hashable {
    public static func ==(lhs: UserDeleteParams, rhs: UserDeleteParams) -> Bool {
        if lhs.reassign != rhs.reassign {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reassign)
    }
}


public struct FfiConverterTypeUserDeleteParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserDeleteParams {
        return
            try UserDeleteParams(
                reassign: FfiConverterTypeUserId.read(from: &buf)
        )
    }

    public static func write(_ value: UserDeleteParams, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.reassign, into: &buf)
    }
}


public func FfiConverterTypeUserDeleteParams_lift(_ buf: RustBuffer) throws -> UserDeleteParams {
    return try FfiConverterTypeUserDeleteParams.lift(buf)
}

public func FfiConverterTypeUserDeleteParams_lower(_ value: UserDeleteParams) -> RustBuffer {
    return FfiConverterTypeUserDeleteParams.lower(value)
}


public struct UserDeleteResponse {
    public let deleted: Bool
    public let previous: UserWithEditContext

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deleted: Bool, previous: UserWithEditContext) {
        self.deleted = deleted
        self.previous = previous
    }
}



extension UserDeleteResponse: Equatable, Hashable {
    public static func ==(lhs: UserDeleteResponse, rhs: UserDeleteResponse) -> Bool {
        if lhs.deleted != rhs.deleted {
            return false
        }
        if lhs.previous != rhs.previous {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deleted)
        hasher.combine(previous)
    }
}


public struct FfiConverterTypeUserDeleteResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserDeleteResponse {
        return
            try UserDeleteResponse(
                deleted: FfiConverterBool.read(from: &buf), 
                previous: FfiConverterTypeUserWithEditContext.read(from: &buf)
        )
    }

    public static func write(_ value: UserDeleteResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.deleted, into: &buf)
        FfiConverterTypeUserWithEditContext.write(value.previous, into: &buf)
    }
}


public func FfiConverterTypeUserDeleteResponse_lift(_ buf: RustBuffer) throws -> UserDeleteResponse {
    return try FfiConverterTypeUserDeleteResponse.lift(buf)
}

public func FfiConverterTypeUserDeleteResponse_lower(_ value: UserDeleteResponse) -> RustBuffer {
    return FfiConverterTypeUserDeleteResponse.lower(value)
}


public struct UserListParams {
    /**
     * Current page of the collection.
     * Default: `1`
     */
    public let page: UInt32?
    /**
     * Maximum number of items to be returned in result set.
     * Default: `10`
     */
    public let perPage: UInt32?
    /**
     * Limit results to those matching a string.
     */
    public let search: String?
    /**
     * Ensure result set excludes specific IDs.
     */
    public let exclude: [UserId]
    /**
     * Limit result set to specific IDs.
     */
    public let include: [UserId]
    /**
     * Offset the result set by a specific number of items.
     */
    public let offset: UInt32?
    /**
     * Order sort attribute ascending or descending.
     * Default: `asc`
     * One of: `asc`, `desc`
     */
    public let order: WpApiParamOrder?
    /**
     * Sort collection by user attribute.
     * Default: `name`
     * One of: `id`, `include`, `name`, `registered_date`, `slug`, `include_slugs`, `email`, `url`
     */
    public let orderby: WpApiParamUsersOrderBy?
    /**
     * Limit result set to users with one or more specific slugs.
     */
    public let slug: [String]
    /**
     * Limit result set to users matching at least one specific role provided. Accepts csv list or single role.
     */
    public let roles: [String]
    /**
     * Limit result set to users matching at least one specific capability provided. Accepts csv list or single capability.
     */
    public let capabilities: [String]
    /**
     * Limit result set to users who are considered authors.
     * One of: `authors`
     */
    public let who: WpApiParamUsersWho?
    /**
     * Limit result set to users who have published posts.
     */
    public let hasPublishedPosts: WpApiParamUsersHasPublishedPosts?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Current page of the collection.
         * Default: `1`
         */page: UInt32? = nil, 
        /**
         * Maximum number of items to be returned in result set.
         * Default: `10`
         */perPage: UInt32? = nil, 
        /**
         * Limit results to those matching a string.
         */search: String? = nil, 
        /**
         * Ensure result set excludes specific IDs.
         */exclude: [UserId] = [], 
        /**
         * Limit result set to specific IDs.
         */include: [UserId] = [], 
        /**
         * Offset the result set by a specific number of items.
         */offset: UInt32? = nil, 
        /**
         * Order sort attribute ascending or descending.
         * Default: `asc`
         * One of: `asc`, `desc`
         */order: WpApiParamOrder? = nil, 
        /**
         * Sort collection by user attribute.
         * Default: `name`
         * One of: `id`, `include`, `name`, `registered_date`, `slug`, `include_slugs`, `email`, `url`
         */orderby: WpApiParamUsersOrderBy? = nil, 
        /**
         * Limit result set to users with one or more specific slugs.
         */slug: [String] = [], 
        /**
         * Limit result set to users matching at least one specific role provided. Accepts csv list or single role.
         */roles: [String] = [], 
        /**
         * Limit result set to users matching at least one specific capability provided. Accepts csv list or single capability.
         */capabilities: [String] = [], 
        /**
         * Limit result set to users who are considered authors.
         * One of: `authors`
         */who: WpApiParamUsersWho? = nil, 
        /**
         * Limit result set to users who have published posts.
         */hasPublishedPosts: WpApiParamUsersHasPublishedPosts? = nil) {
        self.page = page
        self.perPage = perPage
        self.search = search
        self.exclude = exclude
        self.include = include
        self.offset = offset
        self.order = order
        self.orderby = orderby
        self.slug = slug
        self.roles = roles
        self.capabilities = capabilities
        self.who = who
        self.hasPublishedPosts = hasPublishedPosts
    }
}



extension UserListParams: Equatable, Hashable {
    public static func ==(lhs: UserListParams, rhs: UserListParams) -> Bool {
        if lhs.page != rhs.page {
            return false
        }
        if lhs.perPage != rhs.perPage {
            return false
        }
        if lhs.search != rhs.search {
            return false
        }
        if lhs.exclude != rhs.exclude {
            return false
        }
        if lhs.include != rhs.include {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        if lhs.orderby != rhs.orderby {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        if lhs.who != rhs.who {
            return false
        }
        if lhs.hasPublishedPosts != rhs.hasPublishedPosts {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(page)
        hasher.combine(perPage)
        hasher.combine(search)
        hasher.combine(exclude)
        hasher.combine(include)
        hasher.combine(offset)
        hasher.combine(order)
        hasher.combine(orderby)
        hasher.combine(slug)
        hasher.combine(roles)
        hasher.combine(capabilities)
        hasher.combine(who)
        hasher.combine(hasPublishedPosts)
    }
}


public struct FfiConverterTypeUserListParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserListParams {
        return
            try UserListParams(
                page: FfiConverterOptionUInt32.read(from: &buf), 
                perPage: FfiConverterOptionUInt32.read(from: &buf), 
                search: FfiConverterOptionString.read(from: &buf), 
                exclude: FfiConverterSequenceTypeUserId.read(from: &buf), 
                include: FfiConverterSequenceTypeUserId.read(from: &buf), 
                offset: FfiConverterOptionUInt32.read(from: &buf), 
                order: FfiConverterOptionTypeWpApiParamOrder.read(from: &buf), 
                orderby: FfiConverterOptionTypeWpApiParamUsersOrderBy.read(from: &buf), 
                slug: FfiConverterSequenceString.read(from: &buf), 
                roles: FfiConverterSequenceString.read(from: &buf), 
                capabilities: FfiConverterSequenceString.read(from: &buf), 
                who: FfiConverterOptionTypeWpApiParamUsersWho.read(from: &buf), 
                hasPublishedPosts: FfiConverterOptionTypeWpApiParamUsersHasPublishedPosts.read(from: &buf)
        )
    }

    public static func write(_ value: UserListParams, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.page, into: &buf)
        FfiConverterOptionUInt32.write(value.perPage, into: &buf)
        FfiConverterOptionString.write(value.search, into: &buf)
        FfiConverterSequenceTypeUserId.write(value.exclude, into: &buf)
        FfiConverterSequenceTypeUserId.write(value.include, into: &buf)
        FfiConverterOptionUInt32.write(value.offset, into: &buf)
        FfiConverterOptionTypeWpApiParamOrder.write(value.order, into: &buf)
        FfiConverterOptionTypeWpApiParamUsersOrderBy.write(value.orderby, into: &buf)
        FfiConverterSequenceString.write(value.slug, into: &buf)
        FfiConverterSequenceString.write(value.roles, into: &buf)
        FfiConverterSequenceString.write(value.capabilities, into: &buf)
        FfiConverterOptionTypeWpApiParamUsersWho.write(value.who, into: &buf)
        FfiConverterOptionTypeWpApiParamUsersHasPublishedPosts.write(value.hasPublishedPosts, into: &buf)
    }
}


public func FfiConverterTypeUserListParams_lift(_ buf: RustBuffer) throws -> UserListParams {
    return try FfiConverterTypeUserListParams.lift(buf)
}

public func FfiConverterTypeUserListParams_lower(_ value: UserListParams) -> RustBuffer {
    return FfiConverterTypeUserListParams.lower(value)
}


public struct UserUpdateParams {
    /**
     * Display name for the user.
     */
    public let name: String?
    /**
     * First name for the user.
     */
    public let firstName: String?
    /**
     * Last name for the user.
     */
    public let lastName: String?
    /**
     * The email address for the user.
     */
    public let email: String?
    /**
     * URL of the user.
     */
    public let url: String?
    /**
     * Description of the user.
     */
    public let description: String?
    /**
     * Locale for the user.
     * One of: , `en_US`
     */
    public let locale: String?
    /**
     * The nickname for the user.
     */
    public let nickname: String?
    /**
     * An alphanumeric identifier for the user.
     */
    public let slug: String?
    /**
     * Roles assigned to the user.
     */
    public let roles: [String]
    /**
     * Password for the user (never included).
     */
    public let password: String?
    /**
     * Meta fields.
     */
    public let meta: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Display name for the user.
         */name: String? = nil, 
        /**
         * First name for the user.
         */firstName: String? = nil, 
        /**
         * Last name for the user.
         */lastName: String? = nil, 
        /**
         * The email address for the user.
         */email: String? = nil, 
        /**
         * URL of the user.
         */url: String? = nil, 
        /**
         * Description of the user.
         */description: String? = nil, 
        /**
         * Locale for the user.
         * One of: , `en_US`
         */locale: String? = nil, 
        /**
         * The nickname for the user.
         */nickname: String? = nil, 
        /**
         * An alphanumeric identifier for the user.
         */slug: String? = nil, 
        /**
         * Roles assigned to the user.
         */roles: [String] = [], 
        /**
         * Password for the user (never included).
         */password: String? = nil, 
        /**
         * Meta fields.
         */meta: String? = nil) {
        self.name = name
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.url = url
        self.description = description
        self.locale = locale
        self.nickname = nickname
        self.slug = slug
        self.roles = roles
        self.password = password
        self.meta = meta
    }
}



extension UserUpdateParams: Equatable, Hashable {
    public static func ==(lhs: UserUpdateParams, rhs: UserUpdateParams) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.meta != rhs.meta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(firstName)
        hasher.combine(lastName)
        hasher.combine(email)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(locale)
        hasher.combine(nickname)
        hasher.combine(slug)
        hasher.combine(roles)
        hasher.combine(password)
        hasher.combine(meta)
    }
}


public struct FfiConverterTypeUserUpdateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserUpdateParams {
        return
            try UserUpdateParams(
                name: FfiConverterOptionString.read(from: &buf), 
                firstName: FfiConverterOptionString.read(from: &buf), 
                lastName: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                locale: FfiConverterOptionString.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                slug: FfiConverterOptionString.read(from: &buf), 
                roles: FfiConverterSequenceString.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf), 
                meta: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserUpdateParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.firstName, into: &buf)
        FfiConverterOptionString.write(value.lastName, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.locale, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.slug, into: &buf)
        FfiConverterSequenceString.write(value.roles, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
        FfiConverterOptionString.write(value.meta, into: &buf)
    }
}


public func FfiConverterTypeUserUpdateParams_lift(_ buf: RustBuffer) throws -> UserUpdateParams {
    return try FfiConverterTypeUserUpdateParams.lift(buf)
}

public func FfiConverterTypeUserUpdateParams_lower(_ value: UserUpdateParams) -> RustBuffer {
    return FfiConverterTypeUserUpdateParams.lower(value)
}


public struct UserWithEditContext {
    public let id: UserId
    public let username: String
    public let name: String
    public let firstName: String
    public let lastName: String
    public let email: String
    public let url: String
    public let description: String
    public let link: String
    public let locale: String
    public let nickname: String
    public let slug: String
    public let registeredDate: String
    public let roles: [String]
    public let capabilities: [String: Bool]
    public let extraCapabilities: [String: Bool]
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId, username: String, name: String, firstName: String, lastName: String, email: String, url: String, description: String, link: String, locale: String, nickname: String, slug: String, registeredDate: String, roles: [String], capabilities: [String: Bool], extraCapabilities: [String: Bool], avatarUrls: [String: String]?) {
        self.id = id
        self.username = username
        self.name = name
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.url = url
        self.description = description
        self.link = link
        self.locale = locale
        self.nickname = nickname
        self.slug = slug
        self.registeredDate = registeredDate
        self.roles = roles
        self.capabilities = capabilities
        self.extraCapabilities = extraCapabilities
        self.avatarUrls = avatarUrls
    }
}



extension UserWithEditContext: Equatable, Hashable {
    public static func ==(lhs: UserWithEditContext, rhs: UserWithEditContext) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.registeredDate != rhs.registeredDate {
            return false
        }
        if lhs.roles != rhs.roles {
            return false
        }
        if lhs.capabilities != rhs.capabilities {
            return false
        }
        if lhs.extraCapabilities != rhs.extraCapabilities {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(username)
        hasher.combine(name)
        hasher.combine(firstName)
        hasher.combine(lastName)
        hasher.combine(email)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(locale)
        hasher.combine(nickname)
        hasher.combine(slug)
        hasher.combine(registeredDate)
        hasher.combine(roles)
        hasher.combine(capabilities)
        hasher.combine(extraCapabilities)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeUserWithEditContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserWithEditContext {
        return
            try UserWithEditContext(
                id: FfiConverterTypeUserId.read(from: &buf), 
                username: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                firstName: FfiConverterString.read(from: &buf), 
                lastName: FfiConverterString.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                link: FfiConverterString.read(from: &buf), 
                locale: FfiConverterString.read(from: &buf), 
                nickname: FfiConverterString.read(from: &buf), 
                slug: FfiConverterString.read(from: &buf), 
                registeredDate: FfiConverterString.read(from: &buf), 
                roles: FfiConverterSequenceString.read(from: &buf), 
                capabilities: FfiConverterDictionaryStringBool.read(from: &buf), 
                extraCapabilities: FfiConverterDictionaryStringBool.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: UserWithEditContext, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.id, into: &buf)
        FfiConverterString.write(value.username, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.firstName, into: &buf)
        FfiConverterString.write(value.lastName, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.link, into: &buf)
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterString.write(value.nickname, into: &buf)
        FfiConverterString.write(value.slug, into: &buf)
        FfiConverterString.write(value.registeredDate, into: &buf)
        FfiConverterSequenceString.write(value.roles, into: &buf)
        FfiConverterDictionaryStringBool.write(value.capabilities, into: &buf)
        FfiConverterDictionaryStringBool.write(value.extraCapabilities, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeUserWithEditContext_lift(_ buf: RustBuffer) throws -> UserWithEditContext {
    return try FfiConverterTypeUserWithEditContext.lift(buf)
}

public func FfiConverterTypeUserWithEditContext_lower(_ value: UserWithEditContext) -> RustBuffer {
    return FfiConverterTypeUserWithEditContext.lower(value)
}


public struct UserWithEmbedContext {
    public let id: UserId
    public let name: String
    public let url: String
    public let description: String
    public let link: String
    public let slug: String
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId, name: String, url: String, description: String, link: String, slug: String, avatarUrls: [String: String]?) {
        self.id = id
        self.name = name
        self.url = url
        self.description = description
        self.link = link
        self.slug = slug
        self.avatarUrls = avatarUrls
    }
}



extension UserWithEmbedContext: Equatable, Hashable {
    public static func ==(lhs: UserWithEmbedContext, rhs: UserWithEmbedContext) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(slug)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeUserWithEmbedContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserWithEmbedContext {
        return
            try UserWithEmbedContext(
                id: FfiConverterTypeUserId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                link: FfiConverterString.read(from: &buf), 
                slug: FfiConverterString.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: UserWithEmbedContext, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.link, into: &buf)
        FfiConverterString.write(value.slug, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeUserWithEmbedContext_lift(_ buf: RustBuffer) throws -> UserWithEmbedContext {
    return try FfiConverterTypeUserWithEmbedContext.lift(buf)
}

public func FfiConverterTypeUserWithEmbedContext_lower(_ value: UserWithEmbedContext) -> RustBuffer {
    return FfiConverterTypeUserWithEmbedContext.lower(value)
}


public struct UserWithViewContext {
    public let id: UserId
    public let name: String
    public let url: String
    public let description: String
    public let link: String
    public let slug: String
    public let avatarUrls: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UserId, name: String, url: String, description: String, link: String, slug: String, avatarUrls: [String: String]?) {
        self.id = id
        self.name = name
        self.url = url
        self.description = description
        self.link = link
        self.slug = slug
        self.avatarUrls = avatarUrls
    }
}



extension UserWithViewContext: Equatable, Hashable {
    public static func ==(lhs: UserWithViewContext, rhs: UserWithViewContext) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.link != rhs.link {
            return false
        }
        if lhs.slug != rhs.slug {
            return false
        }
        if lhs.avatarUrls != rhs.avatarUrls {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(url)
        hasher.combine(description)
        hasher.combine(link)
        hasher.combine(slug)
        hasher.combine(avatarUrls)
    }
}


public struct FfiConverterTypeUserWithViewContext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserWithViewContext {
        return
            try UserWithViewContext(
                id: FfiConverterTypeUserId.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                url: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                link: FfiConverterString.read(from: &buf), 
                slug: FfiConverterString.read(from: &buf), 
                avatarUrls: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: UserWithViewContext, into buf: inout [UInt8]) {
        FfiConverterTypeUserId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.link, into: &buf)
        FfiConverterString.write(value.slug, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.avatarUrls, into: &buf)
    }
}


public func FfiConverterTypeUserWithViewContext_lift(_ buf: RustBuffer) throws -> UserWithViewContext {
    return try FfiConverterTypeUserWithViewContext.lift(buf)
}

public func FfiConverterTypeUserWithViewContext_lower(_ value: UserWithViewContext) -> RustBuffer {
    return FfiConverterTypeUserWithViewContext.lower(value)
}


public struct WpApiApplicationPasswordDetails {
    public let siteUrl: String
    public let userLogin: String
    public let password: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(siteUrl: String, userLogin: String, password: String) {
        self.siteUrl = siteUrl
        self.userLogin = userLogin
        self.password = password
    }
}



extension WpApiApplicationPasswordDetails: Equatable, Hashable {
    public static func ==(lhs: WpApiApplicationPasswordDetails, rhs: WpApiApplicationPasswordDetails) -> Bool {
        if lhs.siteUrl != rhs.siteUrl {
            return false
        }
        if lhs.userLogin != rhs.userLogin {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(siteUrl)
        hasher.combine(userLogin)
        hasher.combine(password)
    }
}


public struct FfiConverterTypeWpApiApplicationPasswordDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiApplicationPasswordDetails {
        return
            try WpApiApplicationPasswordDetails(
                siteUrl: FfiConverterString.read(from: &buf), 
                userLogin: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WpApiApplicationPasswordDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.siteUrl, into: &buf)
        FfiConverterString.write(value.userLogin, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
    }
}


public func FfiConverterTypeWpApiApplicationPasswordDetails_lift(_ buf: RustBuffer) throws -> WpApiApplicationPasswordDetails {
    return try FfiConverterTypeWpApiApplicationPasswordDetails.lift(buf)
}

public func FfiConverterTypeWpApiApplicationPasswordDetails_lower(_ value: WpApiApplicationPasswordDetails) -> RustBuffer {
    return FfiConverterTypeWpApiApplicationPasswordDetails.lower(value)
}


public struct WpNetworkResponse {
    public let body: Data
    public let statusCode: UInt16
    public let headerMap: WpNetworkHeaderMap

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: Data, statusCode: UInt16, headerMap: WpNetworkHeaderMap) {
        self.body = body
        self.statusCode = statusCode
        self.headerMap = headerMap
    }
}



public struct FfiConverterTypeWpNetworkResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpNetworkResponse {
        return
            try WpNetworkResponse(
                body: FfiConverterData.read(from: &buf), 
                statusCode: FfiConverterUInt16.read(from: &buf), 
                headerMap: FfiConverterTypeWpNetworkHeaderMap.read(from: &buf)
        )
    }

    public static func write(_ value: WpNetworkResponse, into buf: inout [UInt8]) {
        FfiConverterData.write(value.body, into: &buf)
        FfiConverterUInt16.write(value.statusCode, into: &buf)
        FfiConverterTypeWpNetworkHeaderMap.write(value.headerMap, into: &buf)
    }
}


public func FfiConverterTypeWpNetworkResponse_lift(_ buf: RustBuffer) throws -> WpNetworkResponse {
    return try FfiConverterTypeWpNetworkResponse.lift(buf)
}

public func FfiConverterTypeWpNetworkResponse_lower(_ value: WpNetworkResponse) -> RustBuffer {
    return FfiConverterTypeWpNetworkResponse.lower(value)
}


public struct WpRestApiAuthenticationEndpoint {
    public let authorization: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(authorization: String) {
        self.authorization = authorization
    }
}



extension WpRestApiAuthenticationEndpoint: Equatable, Hashable {
    public static func ==(lhs: WpRestApiAuthenticationEndpoint, rhs: WpRestApiAuthenticationEndpoint) -> Bool {
        if lhs.authorization != rhs.authorization {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(authorization)
    }
}


public struct FfiConverterTypeWpRestApiAuthenticationEndpoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpRestApiAuthenticationEndpoint {
        return
            try WpRestApiAuthenticationEndpoint(
                authorization: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WpRestApiAuthenticationEndpoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.authorization, into: &buf)
    }
}


public func FfiConverterTypeWpRestApiAuthenticationEndpoint_lift(_ buf: RustBuffer) throws -> WpRestApiAuthenticationEndpoint {
    return try FfiConverterTypeWpRestApiAuthenticationEndpoint.lift(buf)
}

public func FfiConverterTypeWpRestApiAuthenticationEndpoint_lower(_ value: WpRestApiAuthenticationEndpoint) -> RustBuffer {
    return FfiConverterTypeWpRestApiAuthenticationEndpoint.lower(value)
}


public struct WpRestApiAuthenticationScheme {
    public let endpoints: WpRestApiAuthenticationEndpoint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(endpoints: WpRestApiAuthenticationEndpoint) {
        self.endpoints = endpoints
    }
}



extension WpRestApiAuthenticationScheme: Equatable, Hashable {
    public static func ==(lhs: WpRestApiAuthenticationScheme, rhs: WpRestApiAuthenticationScheme) -> Bool {
        if lhs.endpoints != rhs.endpoints {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(endpoints)
    }
}


public struct FfiConverterTypeWpRestApiAuthenticationScheme: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpRestApiAuthenticationScheme {
        return
            try WpRestApiAuthenticationScheme(
                endpoints: FfiConverterTypeWpRestApiAuthenticationEndpoint.read(from: &buf)
        )
    }

    public static func write(_ value: WpRestApiAuthenticationScheme, into buf: inout [UInt8]) {
        FfiConverterTypeWpRestApiAuthenticationEndpoint.write(value.endpoints, into: &buf)
    }
}


public func FfiConverterTypeWpRestApiAuthenticationScheme_lift(_ buf: RustBuffer) throws -> WpRestApiAuthenticationScheme {
    return try FfiConverterTypeWpRestApiAuthenticationScheme.lift(buf)
}

public func FfiConverterTypeWpRestApiAuthenticationScheme_lower(_ value: WpRestApiAuthenticationScheme) -> RustBuffer {
    return FfiConverterTypeWpRestApiAuthenticationScheme.lower(value)
}


public struct WpRestApiUrls {
    public let apiDetails: WpApiDetails
    public let apiRootUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(apiDetails: WpApiDetails, apiRootUrl: String) {
        self.apiDetails = apiDetails
        self.apiRootUrl = apiRootUrl
    }
}



public struct FfiConverterTypeWpRestApiUrls: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpRestApiUrls {
        return
            try WpRestApiUrls(
                apiDetails: FfiConverterTypeWpApiDetails.read(from: &buf), 
                apiRootUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WpRestApiUrls, into buf: inout [UInt8]) {
        FfiConverterTypeWpApiDetails.write(value.apiDetails, into: &buf)
        FfiConverterString.write(value.apiRootUrl, into: &buf)
    }
}


public func FfiConverterTypeWpRestApiUrls_lift(_ buf: RustBuffer) throws -> WpRestApiUrls {
    return try FfiConverterTypeWpRestApiUrls.lift(buf)
}

public func FfiConverterTypeWpRestApiUrls_lower(_ value: WpRestApiUrls) -> RustBuffer {
    return FfiConverterTypeWpRestApiUrls.lower(value)
}


public struct WpRestError {
    public let code: WpRestErrorCode
    public let message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: WpRestErrorCode, message: String) {
        self.code = code
        self.message = message
    }
}



extension WpRestError: Equatable, Hashable {
    public static func ==(lhs: WpRestError, rhs: WpRestError) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(message)
    }
}


public struct FfiConverterTypeWpRestError: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpRestError {
        return
            try WpRestError(
                code: FfiConverterTypeWpRestErrorCode.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WpRestError, into buf: inout [UInt8]) {
        FfiConverterTypeWpRestErrorCode.write(value.code, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


public func FfiConverterTypeWpRestError_lift(_ buf: RustBuffer) throws -> WpRestError {
    return try FfiConverterTypeWpRestError.lift(buf)
}

public func FfiConverterTypeWpRestError_lower(_ value: WpRestError) -> RustBuffer {
    return FfiConverterTypeWpRestError.lower(value)
}


public enum FetchApiDetailsError {

    
    
    case RequestExecutionFailed(statusCode: UInt16?, reason: String
    )
    case ApiDetailsCouldntBeParsed(reason: String, response: String
    )
}


public struct FfiConverterTypeFetchApiDetailsError: FfiConverterRustBuffer {
    typealias SwiftType = FetchApiDetailsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FetchApiDetailsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestExecutionFailed(
            statusCode: try FfiConverterOptionUInt16.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .ApiDetailsCouldntBeParsed(
            reason: try FfiConverterString.read(from: &buf), 
            response: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FetchApiDetailsError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .RequestExecutionFailed(statusCode,reason):
            writeInt(&buf, Int32(1))
            FfiConverterOptionUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .ApiDetailsCouldntBeParsed(reason,response):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(reason, into: &buf)
            FfiConverterString.write(response, into: &buf)
            
        }
    }
}


extension FetchApiDetailsError: Equatable, Hashable {}

extension FetchApiDetailsError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum FetchApiRootUrlError {

    
    
    case RequestExecutionFailed(statusCode: UInt16?, reason: String
    )
    case ApiRootLinkHeaderNotFound(headerMap: WpNetworkHeaderMap
    )
}


public struct FfiConverterTypeFetchApiRootUrlError: FfiConverterRustBuffer {
    typealias SwiftType = FetchApiRootUrlError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FetchApiRootUrlError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestExecutionFailed(
            statusCode: try FfiConverterOptionUInt16.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .ApiRootLinkHeaderNotFound(
            headerMap: try FfiConverterTypeWpNetworkHeaderMap.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FetchApiRootUrlError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .RequestExecutionFailed(statusCode,reason):
            writeInt(&buf, Int32(1))
            FfiConverterOptionUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .ApiRootLinkHeaderNotFound(headerMap):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWpNetworkHeaderMap.write(headerMap, into: &buf)
            
        }
    }
}


extension FetchApiRootUrlError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum OAuthResponseUrlError {

    
    
    case MissingSiteUrl
    case MissingUsername
    case MissingPassword
    case UnsuccessfulLogin
}


public struct FfiConverterTypeOAuthResponseUrlError: FfiConverterRustBuffer {
    typealias SwiftType = OAuthResponseUrlError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OAuthResponseUrlError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingSiteUrl
        case 2: return .MissingUsername
        case 3: return .MissingPassword
        case 4: return .UnsuccessfulLogin

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OAuthResponseUrlError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingSiteUrl:
            writeInt(&buf, Int32(1))
        
        
        case .MissingUsername:
            writeInt(&buf, Int32(2))
        
        
        case .MissingPassword:
            writeInt(&buf, Int32(3))
        
        
        case .UnsuccessfulLogin:
            writeInt(&buf, Int32(4))
        
        }
    }
}


extension OAuthResponseUrlError: Equatable, Hashable {}

extension OAuthResponseUrlError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum ParseUrlError {

    
    
    case Generic(reason: String
    )
    case EmptyHost
    case IdnaError
    case InvalidPort
    case InvalidIpv4Address
    case InvalidIpv6Address
    case InvalidDomainCharacter
    case RelativeUrlWithoutBase
    case RelativeUrlWithCannotBeABaseBase
    case SetHostOnCannotBeABaseUrl
    case Overflow
}


public struct FfiConverterTypeParseUrlError: FfiConverterRustBuffer {
    typealias SwiftType = ParseUrlError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseUrlError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .EmptyHost
        case 3: return .IdnaError
        case 4: return .InvalidPort
        case 5: return .InvalidIpv4Address
        case 6: return .InvalidIpv6Address
        case 7: return .InvalidDomainCharacter
        case 8: return .RelativeUrlWithoutBase
        case 9: return .RelativeUrlWithCannotBeABaseBase
        case 10: return .SetHostOnCannotBeABaseUrl
        case 11: return .Overflow

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseUrlError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)
            
        
        case .EmptyHost:
            writeInt(&buf, Int32(2))
        
        
        case .IdnaError:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidPort:
            writeInt(&buf, Int32(4))
        
        
        case .InvalidIpv4Address:
            writeInt(&buf, Int32(5))
        
        
        case .InvalidIpv6Address:
            writeInt(&buf, Int32(6))
        
        
        case .InvalidDomainCharacter:
            writeInt(&buf, Int32(7))
        
        
        case .RelativeUrlWithoutBase:
            writeInt(&buf, Int32(8))
        
        
        case .RelativeUrlWithCannotBeABaseBase:
            writeInt(&buf, Int32(9))
        
        
        case .SetHostOnCannotBeABaseUrl:
            writeInt(&buf, Int32(10))
        
        
        case .Overflow:
            writeInt(&buf, Int32(11))
        
        }
    }
}


extension ParseUrlError: Equatable, Hashable {}

extension ParseUrlError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PluginStatus {
    
    case active
    case inactive
    case networkActive
}


public struct FfiConverterTypePluginStatus: FfiConverterRustBuffer {
    typealias SwiftType = PluginStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .active
        
        case 2: return .inactive
        
        case 3: return .networkActive
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PluginStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .active:
            writeInt(&buf, Int32(1))
        
        
        case .inactive:
            writeInt(&buf, Int32(2))
        
        
        case .networkActive:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypePluginStatus_lift(_ buf: RustBuffer) throws -> PluginStatus {
    return try FfiConverterTypePluginStatus.lift(buf)
}

public func FfiConverterTypePluginStatus_lower(_ value: PluginStatus) -> RustBuffer {
    return FfiConverterTypePluginStatus.lower(value)
}



extension PluginStatus: Equatable, Hashable {}




public enum RequestExecutionError {

    
    
    case RequestExecutionFailed(statusCode: UInt16?, reason: String
    )
}


public struct FfiConverterTypeRequestExecutionError: FfiConverterRustBuffer {
    typealias SwiftType = RequestExecutionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestExecutionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestExecutionFailed(
            statusCode: try FfiConverterOptionUInt16.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestExecutionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .RequestExecutionFailed(statusCode,reason):
            writeInt(&buf, Int32(1))
            FfiConverterOptionUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


extension RequestExecutionError: Equatable, Hashable {}

extension RequestExecutionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RequestMethod {
    
    case get
    case post
    case put
    case delete
    case head
}


public struct FfiConverterTypeRequestMethod: FfiConverterRustBuffer {
    typealias SwiftType = RequestMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .get
        
        case 2: return .post
        
        case 3: return .put
        
        case 4: return .delete
        
        case 5: return .head
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .get:
            writeInt(&buf, Int32(1))
        
        
        case .post:
            writeInt(&buf, Int32(2))
        
        
        case .put:
            writeInt(&buf, Int32(3))
        
        
        case .delete:
            writeInt(&buf, Int32(4))
        
        
        case .head:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeRequestMethod_lift(_ buf: RustBuffer) throws -> RequestMethod {
    return try FfiConverterTypeRequestMethod.lift(buf)
}

public func FfiConverterTypeRequestMethod_lower(_ value: RequestMethod) -> RustBuffer {
    return FfiConverterTypeRequestMethod.lower(value)
}



extension RequestMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseApplicationPasswordField {
    
    case uuid
    case appId
    case name
    case created
    case lastUsed
    case lastIp
    case password
}


public struct FfiConverterTypeSparseApplicationPasswordField: FfiConverterRustBuffer {
    typealias SwiftType = SparseApplicationPasswordField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseApplicationPasswordField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .uuid
        
        case 2: return .appId
        
        case 3: return .name
        
        case 4: return .created
        
        case 5: return .lastUsed
        
        case 6: return .lastIp
        
        case 7: return .password
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseApplicationPasswordField, into buf: inout [UInt8]) {
        switch value {
        
        
        case .uuid:
            writeInt(&buf, Int32(1))
        
        
        case .appId:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .created:
            writeInt(&buf, Int32(4))
        
        
        case .lastUsed:
            writeInt(&buf, Int32(5))
        
        
        case .lastIp:
            writeInt(&buf, Int32(6))
        
        
        case .password:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeSparseApplicationPasswordField_lift(_ buf: RustBuffer) throws -> SparseApplicationPasswordField {
    return try FfiConverterTypeSparseApplicationPasswordField.lift(buf)
}

public func FfiConverterTypeSparseApplicationPasswordField_lower(_ value: SparseApplicationPasswordField) -> RustBuffer {
    return FfiConverterTypeSparseApplicationPasswordField.lower(value)
}



extension SparseApplicationPasswordField: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparsePluginField {
    
    case author
    case authorUri
    case description
    case name
    case networkOnly
    case plugin
    case pluginUri
    case requiresPhp
    case requiresWp
    case status
    case textdomain
    case version
}


public struct FfiConverterTypeSparsePluginField: FfiConverterRustBuffer {
    typealias SwiftType = SparsePluginField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparsePluginField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .author
        
        case 2: return .authorUri
        
        case 3: return .description
        
        case 4: return .name
        
        case 5: return .networkOnly
        
        case 6: return .plugin
        
        case 7: return .pluginUri
        
        case 8: return .requiresPhp
        
        case 9: return .requiresWp
        
        case 10: return .status
        
        case 11: return .textdomain
        
        case 12: return .version
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparsePluginField, into buf: inout [UInt8]) {
        switch value {
        
        
        case .author:
            writeInt(&buf, Int32(1))
        
        
        case .authorUri:
            writeInt(&buf, Int32(2))
        
        
        case .description:
            writeInt(&buf, Int32(3))
        
        
        case .name:
            writeInt(&buf, Int32(4))
        
        
        case .networkOnly:
            writeInt(&buf, Int32(5))
        
        
        case .plugin:
            writeInt(&buf, Int32(6))
        
        
        case .pluginUri:
            writeInt(&buf, Int32(7))
        
        
        case .requiresPhp:
            writeInt(&buf, Int32(8))
        
        
        case .requiresWp:
            writeInt(&buf, Int32(9))
        
        
        case .status:
            writeInt(&buf, Int32(10))
        
        
        case .textdomain:
            writeInt(&buf, Int32(11))
        
        
        case .version:
            writeInt(&buf, Int32(12))
        
        }
    }
}


public func FfiConverterTypeSparsePluginField_lift(_ buf: RustBuffer) throws -> SparsePluginField {
    return try FfiConverterTypeSparsePluginField.lift(buf)
}

public func FfiConverterTypeSparsePluginField_lower(_ value: SparsePluginField) -> RustBuffer {
    return FfiConverterTypeSparsePluginField.lower(value)
}



extension SparsePluginField: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SparseUserField {
    
    case id
    case username
    case name
    case lastName
    case email
    case url
    case description
    case link
    case locale
    case nickname
    case slug
    case registeredDate
    case roles
    case capabilities
    case extraCapabilities
    case avatarUrls
}


public struct FfiConverterTypeSparseUserField: FfiConverterRustBuffer {
    typealias SwiftType = SparseUserField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SparseUserField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .id
        
        case 2: return .username
        
        case 3: return .name
        
        case 4: return .lastName
        
        case 5: return .email
        
        case 6: return .url
        
        case 7: return .description
        
        case 8: return .link
        
        case 9: return .locale
        
        case 10: return .nickname
        
        case 11: return .slug
        
        case 12: return .registeredDate
        
        case 13: return .roles
        
        case 14: return .capabilities
        
        case 15: return .extraCapabilities
        
        case 16: return .avatarUrls
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SparseUserField, into buf: inout [UInt8]) {
        switch value {
        
        
        case .id:
            writeInt(&buf, Int32(1))
        
        
        case .username:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .lastName:
            writeInt(&buf, Int32(4))
        
        
        case .email:
            writeInt(&buf, Int32(5))
        
        
        case .url:
            writeInt(&buf, Int32(6))
        
        
        case .description:
            writeInt(&buf, Int32(7))
        
        
        case .link:
            writeInt(&buf, Int32(8))
        
        
        case .locale:
            writeInt(&buf, Int32(9))
        
        
        case .nickname:
            writeInt(&buf, Int32(10))
        
        
        case .slug:
            writeInt(&buf, Int32(11))
        
        
        case .registeredDate:
            writeInt(&buf, Int32(12))
        
        
        case .roles:
            writeInt(&buf, Int32(13))
        
        
        case .capabilities:
            writeInt(&buf, Int32(14))
        
        
        case .extraCapabilities:
            writeInt(&buf, Int32(15))
        
        
        case .avatarUrls:
            writeInt(&buf, Int32(16))
        
        }
    }
}


public func FfiConverterTypeSparseUserField_lift(_ buf: RustBuffer) throws -> SparseUserField {
    return try FfiConverterTypeSparseUserField.lift(buf)
}

public func FfiConverterTypeSparseUserField_lower(_ value: SparseUserField) -> RustBuffer {
    return FfiConverterTypeSparseUserField.lower(value)
}



extension SparseUserField: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UrlDiscoveryAttemptError {
    
    case failedToParseSiteUrl(siteUrl: String, error: ParseUrlError
    )
    case fetchApiRootUrlFailed(siteUrl: ParsedUrl, error: FetchApiRootUrlError
    )
    case fetchApiDetailsFailed(siteUrl: ParsedUrl, apiRootUrl: ParsedUrl, error: FetchApiDetailsError
    )
}


public struct FfiConverterTypeUrlDiscoveryAttemptError: FfiConverterRustBuffer {
    typealias SwiftType = UrlDiscoveryAttemptError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlDiscoveryAttemptError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .failedToParseSiteUrl(siteUrl: try FfiConverterString.read(from: &buf), error: try FfiConverterTypeParseUrlError.read(from: &buf)
        )
        
        case 2: return .fetchApiRootUrlFailed(siteUrl: try FfiConverterTypeParsedUrl.read(from: &buf), error: try FfiConverterTypeFetchApiRootUrlError.read(from: &buf)
        )
        
        case 3: return .fetchApiDetailsFailed(siteUrl: try FfiConverterTypeParsedUrl.read(from: &buf), apiRootUrl: try FfiConverterTypeParsedUrl.read(from: &buf), error: try FfiConverterTypeFetchApiDetailsError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UrlDiscoveryAttemptError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .failedToParseSiteUrl(siteUrl,error):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(siteUrl, into: &buf)
            FfiConverterTypeParseUrlError.write(error, into: &buf)
            
        
        case let .fetchApiRootUrlFailed(siteUrl,error):
            writeInt(&buf, Int32(2))
            FfiConverterTypeParsedUrl.write(siteUrl, into: &buf)
            FfiConverterTypeFetchApiRootUrlError.write(error, into: &buf)
            
        
        case let .fetchApiDetailsFailed(siteUrl,apiRootUrl,error):
            writeInt(&buf, Int32(3))
            FfiConverterTypeParsedUrl.write(siteUrl, into: &buf)
            FfiConverterTypeParsedUrl.write(apiRootUrl, into: &buf)
            FfiConverterTypeFetchApiDetailsError.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeUrlDiscoveryAttemptError_lift(_ buf: RustBuffer) throws -> UrlDiscoveryAttemptError {
    return try FfiConverterTypeUrlDiscoveryAttemptError.lift(buf)
}

public func FfiConverterTypeUrlDiscoveryAttemptError_lower(_ value: UrlDiscoveryAttemptError) -> RustBuffer {
    return FfiConverterTypeUrlDiscoveryAttemptError.lower(value)
}





public enum UrlDiscoveryError {

    
    
    case UrlDiscoveryFailed(attempts: [UrlDiscoveryState]
    )
}


public struct FfiConverterTypeUrlDiscoveryError: FfiConverterRustBuffer {
    typealias SwiftType = UrlDiscoveryError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlDiscoveryError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .UrlDiscoveryFailed(
            attempts: try FfiConverterSequenceTypeUrlDiscoveryState.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UrlDiscoveryError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .UrlDiscoveryFailed(attempts):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeUrlDiscoveryState.write(attempts, into: &buf)
            
        }
    }
}


extension UrlDiscoveryError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UrlDiscoveryState {
    
    case success(UrlDiscoveryAttemptSuccess
    )
    case failure(UrlDiscoveryAttemptError
    )
}


public struct FfiConverterTypeUrlDiscoveryState: FfiConverterRustBuffer {
    typealias SwiftType = UrlDiscoveryState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlDiscoveryState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success(try FfiConverterTypeUrlDiscoveryAttemptSuccess.read(from: &buf)
        )
        
        case 2: return .failure(try FfiConverterTypeUrlDiscoveryAttemptError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UrlDiscoveryState, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .success(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUrlDiscoveryAttemptSuccess.write(v1, into: &buf)
            
        
        case let .failure(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUrlDiscoveryAttemptError.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeUrlDiscoveryState_lift(_ buf: RustBuffer) throws -> UrlDiscoveryState {
    return try FfiConverterTypeUrlDiscoveryState.lift(buf)
}

public func FfiConverterTypeUrlDiscoveryState_lower(_ value: UrlDiscoveryState) -> RustBuffer {
    return FfiConverterTypeUrlDiscoveryState.lower(value)
}





public enum WpApiError {

    
    
    case RequestExecutionFailed(statusCode: UInt16?, reason: String
    )
    case RestError(restError: WpRestErrorWrapper, statusCode: UInt16, response: String
    )
    case SiteUrlParsingError(reason: String
    )
    case ParsingError(reason: String, response: String
    )
    case UnknownError(statusCode: UInt16, response: String
    )
}


public struct FfiConverterTypeWpApiError: FfiConverterRustBuffer {
    typealias SwiftType = WpApiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestExecutionFailed(
            statusCode: try FfiConverterOptionUInt16.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .RestError(
            restError: try FfiConverterTypeWpRestErrorWrapper.read(from: &buf), 
            statusCode: try FfiConverterUInt16.read(from: &buf), 
            response: try FfiConverterString.read(from: &buf)
            )
        case 3: return .SiteUrlParsingError(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 4: return .ParsingError(
            reason: try FfiConverterString.read(from: &buf), 
            response: try FfiConverterString.read(from: &buf)
            )
        case 5: return .UnknownError(
            statusCode: try FfiConverterUInt16.read(from: &buf), 
            response: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpApiError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .RequestExecutionFailed(statusCode,reason):
            writeInt(&buf, Int32(1))
            FfiConverterOptionUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .RestError(restError,statusCode,response):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWpRestErrorWrapper.write(restError, into: &buf)
            FfiConverterUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(response, into: &buf)
            
        
        case let .SiteUrlParsingError(reason):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .ParsingError(reason,response):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(reason, into: &buf)
            FfiConverterString.write(response, into: &buf)
            
        
        case let .UnknownError(statusCode,response):
            writeInt(&buf, Int32(5))
            FfiConverterUInt16.write(statusCode, into: &buf)
            FfiConverterString.write(response, into: &buf)
            
        }
    }
}


extension WpApiError: Equatable, Hashable {}

extension WpApiError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpApiParamOrder {
    
    case asc
    case desc
}


public struct FfiConverterTypeWpApiParamOrder: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamOrder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiParamOrder {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .asc
        
        case 2: return .desc
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpApiParamOrder, into buf: inout [UInt8]) {
        switch value {
        
        
        case .asc:
            writeInt(&buf, Int32(1))
        
        
        case .desc:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeWpApiParamOrder_lift(_ buf: RustBuffer) throws -> WpApiParamOrder {
    return try FfiConverterTypeWpApiParamOrder.lift(buf)
}

public func FfiConverterTypeWpApiParamOrder_lower(_ value: WpApiParamOrder) -> RustBuffer {
    return FfiConverterTypeWpApiParamOrder.lower(value)
}



extension WpApiParamOrder: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpApiParamUsersHasPublishedPosts {
    
    case `true`
    case `false`
    case postTypes([String]
    )
}


public struct FfiConverterTypeWpApiParamUsersHasPublishedPosts: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersHasPublishedPosts

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiParamUsersHasPublishedPosts {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`true`
        
        case 2: return .`false`
        
        case 3: return .postTypes(try FfiConverterSequenceString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpApiParamUsersHasPublishedPosts, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`true`:
            writeInt(&buf, Int32(1))
        
        
        case .`false`:
            writeInt(&buf, Int32(2))
        
        
        case let .postTypes(v1):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceString.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeWpApiParamUsersHasPublishedPosts_lift(_ buf: RustBuffer) throws -> WpApiParamUsersHasPublishedPosts {
    return try FfiConverterTypeWpApiParamUsersHasPublishedPosts.lift(buf)
}

public func FfiConverterTypeWpApiParamUsersHasPublishedPosts_lower(_ value: WpApiParamUsersHasPublishedPosts) -> RustBuffer {
    return FfiConverterTypeWpApiParamUsersHasPublishedPosts.lower(value)
}



extension WpApiParamUsersHasPublishedPosts: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpApiParamUsersOrderBy {
    
    case id
    case include
    case name
    case registeredDate
    case slug
    case includeSlugs
    case email
    case url
}


public struct FfiConverterTypeWpApiParamUsersOrderBy: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersOrderBy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiParamUsersOrderBy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .id
        
        case 2: return .include
        
        case 3: return .name
        
        case 4: return .registeredDate
        
        case 5: return .slug
        
        case 6: return .includeSlugs
        
        case 7: return .email
        
        case 8: return .url
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpApiParamUsersOrderBy, into buf: inout [UInt8]) {
        switch value {
        
        
        case .id:
            writeInt(&buf, Int32(1))
        
        
        case .include:
            writeInt(&buf, Int32(2))
        
        
        case .name:
            writeInt(&buf, Int32(3))
        
        
        case .registeredDate:
            writeInt(&buf, Int32(4))
        
        
        case .slug:
            writeInt(&buf, Int32(5))
        
        
        case .includeSlugs:
            writeInt(&buf, Int32(6))
        
        
        case .email:
            writeInt(&buf, Int32(7))
        
        
        case .url:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypeWpApiParamUsersOrderBy_lift(_ buf: RustBuffer) throws -> WpApiParamUsersOrderBy {
    return try FfiConverterTypeWpApiParamUsersOrderBy.lift(buf)
}

public func FfiConverterTypeWpApiParamUsersOrderBy_lower(_ value: WpApiParamUsersOrderBy) -> RustBuffer {
    return FfiConverterTypeWpApiParamUsersOrderBy.lower(value)
}



extension WpApiParamUsersOrderBy: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpApiParamUsersWho {
    
    case all
    case authors
}


public struct FfiConverterTypeWpApiParamUsersWho: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersWho

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpApiParamUsersWho {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all
        
        case 2: return .authors
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpApiParamUsersWho, into buf: inout [UInt8]) {
        switch value {
        
        
        case .all:
            writeInt(&buf, Int32(1))
        
        
        case .authors:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeWpApiParamUsersWho_lift(_ buf: RustBuffer) throws -> WpApiParamUsersWho {
    return try FfiConverterTypeWpApiParamUsersWho.lift(buf)
}

public func FfiConverterTypeWpApiParamUsersWho_lower(_ value: WpApiParamUsersWho) -> RustBuffer {
    return FfiConverterTypeWpApiParamUsersWho.lower(value)
}



extension WpApiParamUsersWho: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpAuthentication {
    
    case authorizationHeader(token: String
    )
    case none
}


public struct FfiConverterTypeWpAuthentication: FfiConverterRustBuffer {
    typealias SwiftType = WpAuthentication

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpAuthentication {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .authorizationHeader(token: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpAuthentication, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .authorizationHeader(token):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(token, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeWpAuthentication_lift(_ buf: RustBuffer) throws -> WpAuthentication {
    return try FfiConverterTypeWpAuthentication.lift(buf)
}

public func FfiConverterTypeWpAuthentication_lower(_ value: WpAuthentication) -> RustBuffer {
    return FfiConverterTypeWpAuthentication.lower(value)
}



extension WpAuthentication: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpContext {
    
    case edit
    case embed
    case view
}


public struct FfiConverterTypeWpContext: FfiConverterRustBuffer {
    typealias SwiftType = WpContext

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpContext {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .edit
        
        case 2: return .embed
        
        case 3: return .view
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpContext, into buf: inout [UInt8]) {
        switch value {
        
        
        case .edit:
            writeInt(&buf, Int32(1))
        
        
        case .embed:
            writeInt(&buf, Int32(2))
        
        
        case .view:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeWpContext_lift(_ buf: RustBuffer) throws -> WpContext {
    return try FfiConverterTypeWpContext.lift(buf)
}

public func FfiConverterTypeWpContext_lower(_ value: WpContext) -> RustBuffer {
    return FfiConverterTypeWpContext.lower(value)
}



extension WpContext: Equatable, Hashable {}




public enum WpInternalErrorCode {

    
    
    case FsError
    case FsNoPluginsDir
    case FsUnavailable
    case CouldNotRemovePlugin
    case CouldNotResumePlugin
    case NoPluginHeader
    case PluginMissingDependencies
    case PluginNotFound
    case PluginInvalid
    case PluginPhpIncompatible
    case PluginWpIncompatible
    case PluginWpPhpIncompatible
    case PluginsInvalid
    case UnableToConnectToFilesystem
    case UnableToDetermineInstalledPlugin
    case UnexpectedOutput
}


public struct FfiConverterTypeWpInternalErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = WpInternalErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpInternalErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .FsError
        case 2: return .FsNoPluginsDir
        case 3: return .FsUnavailable
        case 4: return .CouldNotRemovePlugin
        case 5: return .CouldNotResumePlugin
        case 6: return .NoPluginHeader
        case 7: return .PluginMissingDependencies
        case 8: return .PluginNotFound
        case 9: return .PluginInvalid
        case 10: return .PluginPhpIncompatible
        case 11: return .PluginWpIncompatible
        case 12: return .PluginWpPhpIncompatible
        case 13: return .PluginsInvalid
        case 14: return .UnableToConnectToFilesystem
        case 15: return .UnableToDetermineInstalledPlugin
        case 16: return .UnexpectedOutput

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpInternalErrorCode, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .FsError:
            writeInt(&buf, Int32(1))
        
        
        case .FsNoPluginsDir:
            writeInt(&buf, Int32(2))
        
        
        case .FsUnavailable:
            writeInt(&buf, Int32(3))
        
        
        case .CouldNotRemovePlugin:
            writeInt(&buf, Int32(4))
        
        
        case .CouldNotResumePlugin:
            writeInt(&buf, Int32(5))
        
        
        case .NoPluginHeader:
            writeInt(&buf, Int32(6))
        
        
        case .PluginMissingDependencies:
            writeInt(&buf, Int32(7))
        
        
        case .PluginNotFound:
            writeInt(&buf, Int32(8))
        
        
        case .PluginInvalid:
            writeInt(&buf, Int32(9))
        
        
        case .PluginPhpIncompatible:
            writeInt(&buf, Int32(10))
        
        
        case .PluginWpIncompatible:
            writeInt(&buf, Int32(11))
        
        
        case .PluginWpPhpIncompatible:
            writeInt(&buf, Int32(12))
        
        
        case .PluginsInvalid:
            writeInt(&buf, Int32(13))
        
        
        case .UnableToConnectToFilesystem:
            writeInt(&buf, Int32(14))
        
        
        case .UnableToDetermineInstalledPlugin:
            writeInt(&buf, Int32(15))
        
        
        case .UnexpectedOutput:
            writeInt(&buf, Int32(16))
        
        }
    }
}


extension WpInternalErrorCode: Equatable, Hashable {}

extension WpInternalErrorCode: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum WpNetworkHeaderMapError {

    
    
    case InvalidHeaderName(headerName: String
    )
    case InvalidHeaderValue(headerValue: String
    )
}


public struct FfiConverterTypeWpNetworkHeaderMapError: FfiConverterRustBuffer {
    typealias SwiftType = WpNetworkHeaderMapError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpNetworkHeaderMapError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidHeaderName(
            headerName: try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidHeaderValue(
            headerValue: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpNetworkHeaderMapError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidHeaderName(headerName):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(headerName, into: &buf)
            
        
        case let .InvalidHeaderValue(headerValue):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(headerValue, into: &buf)
            
        }
    }
}


extension WpNetworkHeaderMapError: Equatable, Hashable {}

extension WpNetworkHeaderMapError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


public enum WpRestErrorCode {

    
    
    case ApplicationPasswordNotFound
    case CannotCreateApplicationPasswords
    case CannotCreateUser
    case CannotDeleteActivePlugin
    case CannotDeleteApplicationPassword
    case CannotDeleteApplicationPasswords
    case CannotEdit
    case CannotEditApplicationPassword
    case CannotEditRoles
    case CannotIntrospectAppPasswordForNonAuthenticatedUser
    case CannotInstallPlugin
    case CannotListApplicationPasswords
    case CannotManagePlugins
    case CannotReadApplicationPassword
    case CannotViewPlugin
    case CannotViewPlugins
    case ForbiddenContext
    case ForbiddenOrderBy
    case ForbiddenWho
    case InvalidParam
    case PluginNotFound
    case Unauthorized
    case UserCannotDelete
    case UserCannotView
    case UserInvalidEmail
    case UserInvalidId
    case UserInvalidReassign
    case UserInvalidRole
    case UserInvalidSlug
    case ApplicationPasswordsDisabled
    case ApplicationPasswordsDisabledForUser
    case CannotManageApplicationPasswords
    case NoAuthenticatedAppPassword
    case CannotManageNetworkPlugins
    case NetworkOnlyPlugin
    case UserCreate
    /**
     * If a plugin is tried to be activated without the `activate_plugin` permission.
     * However, in a default setup a prior check of `activate_plugins` will fail
     * resulting in `CannotManagePlugins` error instead.
     */
    case CannotActivatePlugin
    /**
     * If a plugin is tried to be deactivated without the `deactivate_plugin` permission.
     * However, in a default setup a prior check of `deactivate_plugin` will fail
     * resulting in `CannotManagePlugins` error instead.
     */
    case CannotDeactivatePlugin
    case TrashNotSupported
    case UserExists
    case UserInvalidArgument
    case UserInvalidUsername
    case UserInvalidPassword
}


public struct FfiConverterTypeWpRestErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = WpRestErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpRestErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ApplicationPasswordNotFound
        case 2: return .CannotCreateApplicationPasswords
        case 3: return .CannotCreateUser
        case 4: return .CannotDeleteActivePlugin
        case 5: return .CannotDeleteApplicationPassword
        case 6: return .CannotDeleteApplicationPasswords
        case 7: return .CannotEdit
        case 8: return .CannotEditApplicationPassword
        case 9: return .CannotEditRoles
        case 10: return .CannotIntrospectAppPasswordForNonAuthenticatedUser
        case 11: return .CannotInstallPlugin
        case 12: return .CannotListApplicationPasswords
        case 13: return .CannotManagePlugins
        case 14: return .CannotReadApplicationPassword
        case 15: return .CannotViewPlugin
        case 16: return .CannotViewPlugins
        case 17: return .ForbiddenContext
        case 18: return .ForbiddenOrderBy
        case 19: return .ForbiddenWho
        case 20: return .InvalidParam
        case 21: return .PluginNotFound
        case 22: return .Unauthorized
        case 23: return .UserCannotDelete
        case 24: return .UserCannotView
        case 25: return .UserInvalidEmail
        case 26: return .UserInvalidId
        case 27: return .UserInvalidReassign
        case 28: return .UserInvalidRole
        case 29: return .UserInvalidSlug
        case 30: return .ApplicationPasswordsDisabled
        case 31: return .ApplicationPasswordsDisabledForUser
        case 32: return .CannotManageApplicationPasswords
        case 33: return .NoAuthenticatedAppPassword
        case 34: return .CannotManageNetworkPlugins
        case 35: return .NetworkOnlyPlugin
        case 36: return .UserCreate
        case 37: return .CannotActivatePlugin
        case 38: return .CannotDeactivatePlugin
        case 39: return .TrashNotSupported
        case 40: return .UserExists
        case 41: return .UserInvalidArgument
        case 42: return .UserInvalidUsername
        case 43: return .UserInvalidPassword

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpRestErrorCode, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .ApplicationPasswordNotFound:
            writeInt(&buf, Int32(1))
        
        
        case .CannotCreateApplicationPasswords:
            writeInt(&buf, Int32(2))
        
        
        case .CannotCreateUser:
            writeInt(&buf, Int32(3))
        
        
        case .CannotDeleteActivePlugin:
            writeInt(&buf, Int32(4))
        
        
        case .CannotDeleteApplicationPassword:
            writeInt(&buf, Int32(5))
        
        
        case .CannotDeleteApplicationPasswords:
            writeInt(&buf, Int32(6))
        
        
        case .CannotEdit:
            writeInt(&buf, Int32(7))
        
        
        case .CannotEditApplicationPassword:
            writeInt(&buf, Int32(8))
        
        
        case .CannotEditRoles:
            writeInt(&buf, Int32(9))
        
        
        case .CannotIntrospectAppPasswordForNonAuthenticatedUser:
            writeInt(&buf, Int32(10))
        
        
        case .CannotInstallPlugin:
            writeInt(&buf, Int32(11))
        
        
        case .CannotListApplicationPasswords:
            writeInt(&buf, Int32(12))
        
        
        case .CannotManagePlugins:
            writeInt(&buf, Int32(13))
        
        
        case .CannotReadApplicationPassword:
            writeInt(&buf, Int32(14))
        
        
        case .CannotViewPlugin:
            writeInt(&buf, Int32(15))
        
        
        case .CannotViewPlugins:
            writeInt(&buf, Int32(16))
        
        
        case .ForbiddenContext:
            writeInt(&buf, Int32(17))
        
        
        case .ForbiddenOrderBy:
            writeInt(&buf, Int32(18))
        
        
        case .ForbiddenWho:
            writeInt(&buf, Int32(19))
        
        
        case .InvalidParam:
            writeInt(&buf, Int32(20))
        
        
        case .PluginNotFound:
            writeInt(&buf, Int32(21))
        
        
        case .Unauthorized:
            writeInt(&buf, Int32(22))
        
        
        case .UserCannotDelete:
            writeInt(&buf, Int32(23))
        
        
        case .UserCannotView:
            writeInt(&buf, Int32(24))
        
        
        case .UserInvalidEmail:
            writeInt(&buf, Int32(25))
        
        
        case .UserInvalidId:
            writeInt(&buf, Int32(26))
        
        
        case .UserInvalidReassign:
            writeInt(&buf, Int32(27))
        
        
        case .UserInvalidRole:
            writeInt(&buf, Int32(28))
        
        
        case .UserInvalidSlug:
            writeInt(&buf, Int32(29))
        
        
        case .ApplicationPasswordsDisabled:
            writeInt(&buf, Int32(30))
        
        
        case .ApplicationPasswordsDisabledForUser:
            writeInt(&buf, Int32(31))
        
        
        case .CannotManageApplicationPasswords:
            writeInt(&buf, Int32(32))
        
        
        case .NoAuthenticatedAppPassword:
            writeInt(&buf, Int32(33))
        
        
        case .CannotManageNetworkPlugins:
            writeInt(&buf, Int32(34))
        
        
        case .NetworkOnlyPlugin:
            writeInt(&buf, Int32(35))
        
        
        case .UserCreate:
            writeInt(&buf, Int32(36))
        
        
        case .CannotActivatePlugin:
            writeInt(&buf, Int32(37))
        
        
        case .CannotDeactivatePlugin:
            writeInt(&buf, Int32(38))
        
        
        case .TrashNotSupported:
            writeInt(&buf, Int32(39))
        
        
        case .UserExists:
            writeInt(&buf, Int32(40))
        
        
        case .UserInvalidArgument:
            writeInt(&buf, Int32(41))
        
        
        case .UserInvalidUsername:
            writeInt(&buf, Int32(42))
        
        
        case .UserInvalidPassword:
            writeInt(&buf, Int32(43))
        
        }
    }
}


extension WpRestErrorCode: Equatable, Hashable {}

extension WpRestErrorCode: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WpRestErrorWrapper {
    
    case recognized(WpRestError
    )
    case unrecognized(UnrecognizedWpRestError
    )
}


public struct FfiConverterTypeWpRestErrorWrapper: FfiConverterRustBuffer {
    typealias SwiftType = WpRestErrorWrapper

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpRestErrorWrapper {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .recognized(try FfiConverterTypeWpRestError.read(from: &buf)
        )
        
        case 2: return .unrecognized(try FfiConverterTypeUnrecognizedWpRestError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WpRestErrorWrapper, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .recognized(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWpRestError.write(v1, into: &buf)
            
        
        case let .unrecognized(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUnrecognizedWpRestError.write(v1, into: &buf)
            
        }
    }
}


public func FfiConverterTypeWpRestErrorWrapper_lift(_ buf: RustBuffer) throws -> WpRestErrorWrapper {
    return try FfiConverterTypeWpRestErrorWrapper.lift(buf)
}

public func FfiConverterTypeWpRestErrorWrapper_lower(_ value: WpRestErrorWrapper) -> RustBuffer {
    return FfiConverterTypeWpRestErrorWrapper.lower(value)
}



extension WpRestErrorWrapper: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpNetworkRequestBody: FfiConverterRustBuffer {
    typealias SwiftType = WpNetworkRequestBody?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpNetworkRequestBody.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpNetworkRequestBody.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeApplicationPasswordAppId: FfiConverterRustBuffer {
    typealias SwiftType = ApplicationPasswordAppId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeApplicationPasswordAppId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeApplicationPasswordAppId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeApplicationPasswordUuid: FfiConverterRustBuffer {
    typealias SwiftType = ApplicationPasswordUuid?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeApplicationPasswordUuid.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeApplicationPasswordUuid.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIpAddress: FfiConverterRustBuffer {
    typealias SwiftType = IpAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIpAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIpAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePluginDescription: FfiConverterRustBuffer {
    typealias SwiftType = PluginDescription?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePluginDescription.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePluginDescription.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePluginSlug: FfiConverterRustBuffer {
    typealias SwiftType = PluginSlug?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePluginSlug.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePluginSlug.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePluginStatus: FfiConverterRustBuffer {
    typealias SwiftType = PluginStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePluginStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePluginStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpApiParamOrder: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamOrder?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpApiParamOrder.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpApiParamOrder.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpApiParamUsersHasPublishedPosts: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersHasPublishedPosts?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpApiParamUsersHasPublishedPosts.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpApiParamUsersHasPublishedPosts.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpApiParamUsersOrderBy: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersOrderBy?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpApiParamUsersOrderBy.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpApiParamUsersOrderBy.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeWpApiParamUsersWho: FfiConverterRustBuffer {
    typealias SwiftType = WpApiParamUsersWho?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWpApiParamUsersWho.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWpApiParamUsersWho.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryStringBool: FfiConverterRustBuffer {
    typealias SwiftType = [String: Bool]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUserId: FfiConverterRustBuffer {
    typealias SwiftType = UserId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeApplicationPasswordWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [ApplicationPasswordWithEditContext]

    public static func write(_ value: [ApplicationPasswordWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeApplicationPasswordWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ApplicationPasswordWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [ApplicationPasswordWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeApplicationPasswordWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeApplicationPasswordWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [ApplicationPasswordWithEmbedContext]

    public static func write(_ value: [ApplicationPasswordWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeApplicationPasswordWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ApplicationPasswordWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [ApplicationPasswordWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeApplicationPasswordWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeApplicationPasswordWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [ApplicationPasswordWithViewContext]

    public static func write(_ value: [ApplicationPasswordWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeApplicationPasswordWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ApplicationPasswordWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [ApplicationPasswordWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeApplicationPasswordWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePluginWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [PluginWithEditContext]

    public static func write(_ value: [PluginWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePluginWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PluginWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [PluginWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePluginWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePluginWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [PluginWithEmbedContext]

    public static func write(_ value: [PluginWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePluginWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PluginWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [PluginWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePluginWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePluginWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [PluginWithViewContext]

    public static func write(_ value: [PluginWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePluginWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PluginWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [PluginWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePluginWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseApplicationPassword: FfiConverterRustBuffer {
    typealias SwiftType = [SparseApplicationPassword]

    public static func write(_ value: [SparseApplicationPassword], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseApplicationPassword.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseApplicationPassword] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseApplicationPassword]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseApplicationPassword.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePlugin: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePlugin]

    public static func write(_ value: [SparsePlugin], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePlugin.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePlugin] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePlugin]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePlugin.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseUser: FfiConverterRustBuffer {
    typealias SwiftType = [SparseUser]

    public static func write(_ value: [SparseUser], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseUser.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseUser] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseUser]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseUser.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserWithEditContext: FfiConverterRustBuffer {
    typealias SwiftType = [UserWithEditContext]

    public static func write(_ value: [UserWithEditContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserWithEditContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserWithEditContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserWithEditContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserWithEditContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserWithEmbedContext: FfiConverterRustBuffer {
    typealias SwiftType = [UserWithEmbedContext]

    public static func write(_ value: [UserWithEmbedContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserWithEmbedContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserWithEmbedContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserWithEmbedContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserWithEmbedContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserWithViewContext: FfiConverterRustBuffer {
    typealias SwiftType = [UserWithViewContext]

    public static func write(_ value: [UserWithViewContext], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserWithViewContext.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserWithViewContext] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserWithViewContext]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserWithViewContext.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseApplicationPasswordField: FfiConverterRustBuffer {
    typealias SwiftType = [SparseApplicationPasswordField]

    public static func write(_ value: [SparseApplicationPasswordField], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseApplicationPasswordField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseApplicationPasswordField] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseApplicationPasswordField]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseApplicationPasswordField.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparsePluginField: FfiConverterRustBuffer {
    typealias SwiftType = [SparsePluginField]

    public static func write(_ value: [SparsePluginField], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparsePluginField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparsePluginField] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparsePluginField]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparsePluginField.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSparseUserField: FfiConverterRustBuffer {
    typealias SwiftType = [SparseUserField]

    public static func write(_ value: [SparseUserField], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSparseUserField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SparseUserField] {
        let len: Int32 = try readInt(&buf)
        var seq = [SparseUserField]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSparseUserField.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUrlDiscoveryState: FfiConverterRustBuffer {
    typealias SwiftType = [UrlDiscoveryState]

    public static func write(_ value: [UrlDiscoveryState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUrlDiscoveryState.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UrlDiscoveryState] {
        let len: Int32 = try readInt(&buf)
        var seq = [UrlDiscoveryState]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUrlDiscoveryState.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUserId: FfiConverterRustBuffer {
    typealias SwiftType = [UserId]

    public static func write(_ value: [UserId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserId] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UserId = Int32
public struct FfiConverterTypeUserId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserId {
        return try FfiConverterInt32.read(from: &buf)
    }

    public static func write(_ value: UserId, into buf: inout [UInt8]) {
        return FfiConverterInt32.write(value, into: &buf)
    }

    public static func lift(_ value: Int32) throws -> UserId {
        return try FfiConverterInt32.lift(value)
    }

    public static func lower(_ value: UserId) -> Int32 {
        return FfiConverterInt32.lower(value)
    }
}


public func FfiConverterTypeUserId_lift(_ value: Int32) throws -> UserId {
    return try FfiConverterTypeUserId.lift(value)
}

public func FfiConverterTypeUserId_lower(_ value: UserId) -> Int32 {
    return FfiConverterTypeUserId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WpEndpointUrl = String
public struct FfiConverterTypeWpEndpointUrl: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WpEndpointUrl {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: WpEndpointUrl, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> WpEndpointUrl {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: WpEndpointUrl) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeWpEndpointUrl_lift(_ value: RustBuffer) throws -> WpEndpointUrl {
    return try FfiConverterTypeWpEndpointUrl.lift(value)
}

public func FfiConverterTypeWpEndpointUrl_lower(_ value: WpEndpointUrl) -> RustBuffer {
    return FfiConverterTypeWpEndpointUrl.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountWpApi() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func extractLoginDetailsFromUrl(url: ParsedUrl)throws  -> WpApiApplicationPasswordDetails {
    return try  FfiConverterTypeWpApiApplicationPasswordDetails.lift(try rustCallWithError(FfiConverterTypeOAuthResponseUrlError.lift) {
    uniffi_wp_api_fn_func_extract_login_details_from_url(
        FfiConverterTypeParsedUrl.lower(url),$0
    )
})
}
public func wpAuthenticationFromUsernameAndPassword(username: String, password: String) -> WpAuthentication {
    return try!  FfiConverterTypeWpAuthentication.lift(try! rustCall() {
    uniffi_wp_api_fn_func_wp_authentication_from_username_and_password(
        FfiConverterString.lower(username),
        FfiConverterString.lower(password),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_wp_api_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_wp_api_checksum_func_extract_login_details_from_url() != 33603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_func_wp_authentication_from_username_and_password() != 52469) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_create() != 28747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_delete() != 64126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_delete_all() != 21799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_list() != 44549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_retrieve() != 51125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_filter_retrieve_current() != 44971) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_list_with_edit_context() != 36746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_list_with_embed_context() != 44351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_list_with_view_context() != 15295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_current_with_edit_context() != 13545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_current_with_embed_context() != 26033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_current_with_view_context() != 35743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_with_edit_context() != 58711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_with_embed_context() != 20644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_retrieve_with_view_context() != 12386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestbuilder_update() != 17590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_create() != 5377) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_delete() != 29928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_delete_all() != 748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_list() != 6950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_retrieve() != 28293) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_filter_retrieve_current() != 466) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_list_with_edit_context() != 62518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_list_with_embed_context() != 64156) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_list_with_view_context() != 30495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_current_with_edit_context() != 37377) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_current_with_embed_context() != 43046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_current_with_view_context() != 51319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_with_edit_context() != 10005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_with_embed_context() != 26992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_retrieve_with_view_context() != 9092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_applicationpasswordsrequestexecutor_update() != 29032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_parsedurl_url() != 51586) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_create() != 5886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_delete() != 21139) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_filter_list() != 24122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_filter_retrieve() != 7597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_list_with_edit_context() != 28144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_list_with_embed_context() != 51715) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_list_with_view_context() != 22725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_retrieve_with_edit_context() != 42499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_retrieve_with_embed_context() != 11482) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_retrieve_with_view_context() != 57123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestbuilder_update() != 4390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_create() != 51926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_delete() != 38438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_filter_list() != 21173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_filter_retrieve() != 34110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_list_with_edit_context() != 57195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_list_with_embed_context() != 50734) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_list_with_view_context() != 20383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_retrieve_with_edit_context() != 55162) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_retrieve_with_embed_context() != 19830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_retrieve_with_view_context() != 18919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_pluginsrequestexecutor_update() != 46564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_requestexecutor_execute() != 39962) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapiclient_application_passwords() != 57830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapiclient_plugins() != 54558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapiclient_users() != 2759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapirequestbuilder_application_passwords() != 12259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapirequestbuilder_plugins() != 65526) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwpapirequestbuilder_users() != 41529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_uniffiwploginclient_api_discovery() != 28272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_create() != 6684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_delete() != 54398) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_delete_me() != 63972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_list() != 22051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_retrieve() != 58227) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_filter_retrieve_me() != 14904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_list_with_edit_context() != 1885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_list_with_embed_context() != 49398) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_list_with_view_context() != 7811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_me_with_edit_context() != 51915) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_me_with_embed_context() != 34510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_me_with_view_context() != 62545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_with_edit_context() != 50322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_with_embed_context() != 61113) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_retrieve_with_view_context() != 21480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_update() != 6966) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestbuilder_update_me() != 32323) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_create() != 50724) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_delete() != 20471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_delete_me() != 18459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_list() != 49932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_retrieve() != 3122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_filter_retrieve_me() != 52072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_list_with_edit_context() != 51811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_list_with_embed_context() != 8582) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_list_with_view_context() != 17140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_me_with_edit_context() != 42507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_me_with_embed_context() != 58296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_me_with_view_context() != 28326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_with_edit_context() != 61453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_with_embed_context() != 12341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_retrieve_with_view_context() != 49013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_update() != 25129) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_usersrequestexecutor_update_me() != 52559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpapidetails_find_application_passwords_authentication_url() != 4304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkheadermap_to_map() != 38263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequest_body() != 14272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequest_body_as_string() != 16088) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequest_header_map() != 64881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequest_method() != 5762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequest_url() != 46843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_method_wpnetworkrequestbody_contents() != 62522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_parsedurl_parse() != 30042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_uniffiwpapiclient_new() != 23745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_uniffiwpapirequestbuilder_new() != 62069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_uniffiwploginclient_new() != 26720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_wpnetworkheadermap_from_map() != 30501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_wp_api_checksum_constructor_wpnetworkheadermap_from_multi_map() != 50205) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitRequestExecutor()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all